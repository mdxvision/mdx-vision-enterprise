package com.mdxvision

import android.Manifest
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.content.pm.PackageManager
import android.net.ConnectivityManager
import android.net.NetworkCapabilities
import android.os.Bundle
import android.speech.RecognitionListener
import android.speech.RecognizerIntent
import android.speech.SpeechRecognizer
import android.speech.tts.TextToSpeech
import java.util.Locale
import android.util.Log
import android.widget.TextView
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import okhttp3.*
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONArray
import org.json.JSONObject
import java.io.IOException
import androidx.lifecycle.lifecycleScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.coroutines.delay
import com.android.volley.toolbox.StringRequest
import com.android.volley.toolbox.Volley
import androidx.localbroadcastmanager.content.LocalBroadcastManager

sealed class VoiceIntent {
    data class LoadPatient(val name: String) : VoiceIntent()
    object ShowVitals : VoiceIntent()
    object ShowLabs : VoiceIntent()
    object SpeakSummary : VoiceIntent()
}

data class VoiceIntentExecutor(
    val loadPatient: (String) -> Unit,
    val showVitals: () -> Unit,
    val showLabs: () -> Unit,
    val speakSummary: () -> Unit,
    val interIntentDelayMillis: Long = 300L,
    val postLoadDelayMillis: Long = 1200L,
) {
    suspend fun execute(intents: List<VoiceIntent>) {
        intents.forEachIndexed { index, intent ->
            executeIntent(intent)
            if (index < intents.lastIndex) {
                val delayMillis = if (intent is VoiceIntent.LoadPatient) {
                    postLoadDelayMillis
                } else {
                    interIntentDelayMillis
                }
                delay(delayMillis)
            }
        }
    }

    private fun executeIntent(intent: VoiceIntent) {
        when (intent) {
            is VoiceIntent.LoadPatient -> loadPatient(intent.name)
            VoiceIntent.ShowVitals -> showVitals()
            VoiceIntent.ShowLabs -> showLabs()
            VoiceIntent.SpeakSummary -> speakSummary()
        }
    }
}

fun parseVoiceIntents(utterance: String): List<VoiceIntent> {
    val normalized = utterance.replace("’", "'")
    val delimiterRegex = Regex("\\b(and|then|also|plus|as well as)\\b", RegexOption.IGNORE_CASE)
    val clauses = delimiterRegex.split(normalized).map { it.trim() }.filter { it.isNotEmpty() }
    val intents = mutableListOf<VoiceIntent>()

    clauses.forEach { clause ->
        val clauseLower = clause.lowercase()
        val clauseIntents = mutableListOf<Pair<Int, VoiceIntent>>()

        val loadRegex = Regex("(open|load|show)\\s+(?:patient\\s+)?(.+?)\\s+(chart|record|file|patient)", RegexOption.IGNORE_CASE)
        val loadMatch = loadRegex.find(clause)
        val loadIndex = loadMatch?.range?.first ?: -1
        val loadName = loadMatch?.groupValues?.getOrNull(2)?.trim()?.removeSuffix("'s")?.removeSuffix("’s")
        if (loadIndex >= 0 && !loadName.isNullOrBlank()) {
            clauseIntents.add(loadIndex to VoiceIntent.LoadPatient(loadName.trim()))
        }

        val vitalsIndex = clauseLower.indexOf("vital")
        if (vitalsIndex >= 0) {
            clauseIntents.add(vitalsIndex to VoiceIntent.ShowVitals)
        }

        val labsIndex = clauseLower.indexOf("lab")
        if (labsIndex >= 0) {
            clauseIntents.add(labsIndex to VoiceIntent.ShowLabs)
        }

        val speakTriggers = listOf(
            "read it back",
            "read back",
            "read it",
            "read summary",
            "speak summary",
            "speak",
            "brief",
            "tell me about",
        )
        val speakIndex = speakTriggers.map { trigger -> clauseLower.indexOf(trigger) }.filter { it >= 0 }.minOrNull()
        if (speakIndex != null) {
            clauseIntents.add(speakIndex to VoiceIntent.SpeakSummary)
        }

        clauseIntents.sortedBy { it.first }.forEach { intents.add(it.second) }
    }

    return intents
}

/**
 * MDx Vision - Main Activity
 * AR Smart Glasses Healthcare Documentation
 *
 * Patent Implementation:
 * - Claim 1-2: Voice commands via microphone
 * - Claim 5-7: Camera patient identification
 * - Claim 8: AR display overlay
 * - Claim 9: Wireless EHR connection
 */
class MainActivity : AppCompatActivity() {

    companion object {
        private const val TAG = "MDxVision"
        private const val PERMISSION_REQUEST_CODE = 1001

        // Server URL configuration - set via SharedPreferences or use default
        // For local dev: Your Mac's IP (check with `ifconfig | grep inet`)
        // For Vuzix testing: Ensure device is on same WiFi network as Mac
        // For production: Use cloud URL (e.g., https://api.mdxvision.com)
        private const val PREF_SERVER_URL = "server_url"
        private const val DEFAULT_SERVER_URL = "http://192.168.1.243:8002"
        private var serverUrl: String = DEFAULT_SERVER_URL

        val EHR_PROXY_URL: String
            get() = serverUrl

        /**
         * Configure the server URL at runtime
         * Call this before making API calls
         */
        fun setServerUrl(url: String) {
            serverUrl = url.trimEnd('/')
            // Also configure AudioStreamingService WebSocket URL
            val wsUrl = url.replace("http://", "ws://")
                          .replace("https://", "wss://")
                          .trimEnd('/') + "/ws/transcribe"
            AudioStreamingService.setDeviceUrl(wsUrl)
            Log.d(TAG, "Server URL configured: HTTP=$serverUrl, WS=$wsUrl")
        }
        // Test patient from Cerner sandbox
        private const val TEST_PATIENT_ID = "12724066"
        // DEBUG: Set to true to skip TOTP authentication for testing
        private const val DEBUG_SKIP_AUTH = true  // TODO: Set to false for production!
        // Offline cache
        private const val PREFS_NAME = "MDxVisionCache"
        private const val CACHE_PREFIX = "patient_"
        private const val CACHE_TIMESTAMP_SUFFIX = "_timestamp"
        private const val CACHE_MAX_AGE_MS = 24 * 60 * 60 * 1000L // 24 hours
        // Font size settings
        private const val PREF_FONT_SIZE = "font_size_level"
        private const val FONT_SIZE_SMALL = 0
        private const val FONT_SIZE_MEDIUM = 1
        private const val FONT_SIZE_LARGE = 2
        private const val FONT_SIZE_EXTRA_LARGE = 3
        // Clinician name setting
        private const val PREF_CLINICIAN_NAME = "clinician_name"
        private const val DEFAULT_CLINICIAN_NAME = "Clinician"
        // Speech feedback setting
        private const val PREF_SPEECH_FEEDBACK = "speech_feedback_enabled"
        // Offline note drafts
        private const val DRAFT_PREFIX = "note_draft_"
        private const val DRAFT_IDS_KEY = "pending_draft_ids"
        private const val MAX_SYNC_ATTEMPTS = 5
        // Patient history
        private const val HISTORY_KEY = "patient_history"
        private const val MAX_HISTORY_SIZE = 10
        // Session timeout (HIPAA compliance)
        private const val PREF_SESSION_TIMEOUT = "session_timeout_minutes"
        private const val DEFAULT_SESSION_TIMEOUT_MINUTES = 5
        private const val SESSION_CHECK_INTERVAL_MS = 30_000L // Check every 30 seconds
        // Multi-language support
        private const val PREF_LANGUAGE = "app_language"
        private const val LANG_ENGLISH = "en"
        private const val LANG_SPANISH = "es"
        private const val LANG_MANDARIN = "zh"
        private const val LANG_PORTUGUESE = "pt"
        private const val LANG_RUSSIAN = "ru"
        // Device authentication (TOTP + QR pairing)
        private const val PREF_DEVICE_ID = "device_id"
        private const val PREF_SESSION_TOKEN = "session_token"
        private const val PREF_CLINICIAN_ID = "clinician_id"
        private const val PREF_DEVICE_PAIRED = "device_paired"
        private const val PREF_VOICEPRINT_ENROLLED = "voiceprint_enrolled"
        private const val PREF_LAST_VOICEPRINT_VERIFY = "last_voiceprint_verification"
        private const val PREF_VOICEPRINT_CONFIDENCE = "voiceprint_confidence"
        private const val PREF_REVERIFY_INTERVAL = "reverify_interval_seconds"
        private const val QR_SCAN_REQUEST_CODE = 1003
    }

    // Offline cache
    private lateinit var cachePrefs: SharedPreferences

    private lateinit var speechRecognizer: SpeechRecognizer
    private lateinit var statusText: TextView
    private lateinit var transcriptText: TextView
    private lateinit var patientDataText: TextView
    private val httpClient = OkHttpClient.Builder()
        .connectTimeout(60, java.util.concurrent.TimeUnit.SECONDS)
        .readTimeout(120, java.util.concurrent.TimeUnit.SECONDS)
        .writeTimeout(30, java.util.concurrent.TimeUnit.SECONDS)
        .retryOnConnectionFailure(true)
        .connectionPool(okhttp3.ConnectionPool(0, 1, java.util.concurrent.TimeUnit.MILLISECONDS))
        .protocols(listOf(okhttp3.Protocol.HTTP_1_1))
        .build()

    // Documentation mode
    private var isDocumentationMode = false
    private val documentationTranscripts = mutableListOf<String>()

    // Wake word and continuous listening (Patent Claims 1-4)
    private var isContinuousListening = false
    private val WAKE_WORD = "mdx"
    private var awaitingCommand = false

    // Live transcription via WebSocket (AssemblyAI/Deepgram)
    private var audioStreamingService: AudioStreamingService? = null
    private var isLiveTranscribing = false

    // WebSocket fallback for voice commands (Vuzix/devices without Google Speech)
    private var useWebSocketForCommands = false
    private var commandStreamingService: AudioStreamingService? = null
    private var isCommandListening = false
    private var liveTranscriptText: TextView? = null
    private val liveTranscriptBuffer = StringBuilder()

    // Last generated note for saving
    private var lastGeneratedNote: JSONObject? = null
    private var lastNoteTranscript: String? = null

    // Pending transcript for preview (before note generation)
    private var pendingTranscript: String? = null

    // Editable note content (for edit before save)
    private var editableNoteContent: String? = null
    private var noteEditText: android.widget.EditText? = null
    private var isNoteEditing: Boolean = false

    // Font size for accessibility
    private var currentFontSizeLevel: Int = FONT_SIZE_MEDIUM

    // Auto-scroll for live transcription
    private var isAutoScrollEnabled: Boolean = true
    private var liveTranscriptScrollView: android.widget.ScrollView? = null

    // Offline note drafts
    private var networkCallback: ConnectivityManager.NetworkCallback? = null
    private var isSyncing = false

    // Note type for clinical documentation (SOAP, PROGRESS, HP, CONSULT, AUTO)
    private var currentNoteType: String = "AUTO"  // Default to auto-detect

    // Clinician name for speaker context (can be configured in settings)
    private var clinicianName: String = "Clinician"  // Default name, update from settings/login

    // Text-to-Speech for spoken patient summaries (hands-free while walking)
    private var textToSpeech: TextToSpeech? = null
    private var isTtsReady: Boolean = false
    private var isSpeechFeedbackEnabled: Boolean = true  // Audible confirmations for actions

    // Session timeout for HIPAA compliance
    private var lastActivityTime: Long = System.currentTimeMillis()
    private var isSessionLocked: Boolean = false
    private var sessionTimeoutMinutes: Int = DEFAULT_SESSION_TIMEOUT_MINUTES
    private var sessionCheckHandler: android.os.Handler? = null
    private var sessionCheckRunnable: Runnable? = null
    private var lockScreenOverlay: android.widget.FrameLayout? = null

    // Device authentication (TOTP + voiceprint)
    private var deviceId: String = ""
    private var sessionToken: String? = null
    private var clinicianId: String? = null
    private var isDevicePaired: Boolean = false
    private var isVoiceprintEnrolled: Boolean = false
    private var pendingTotpCode: String? = null  // Accumulates spoken digits
    private var isAwaitingTotpCode: Boolean = false
    private var totpDigitBuffer: StringBuilder = StringBuilder()

    // Voiceprint enrollment
    private var isRecordingVoiceprint: Boolean = false
    private var voiceprintEnrollmentPhrases: List<String> = listOf()
    private var voiceprintRecordingIndex: Int = 0
    private var voiceprintAudioSamples: MutableList<String> = mutableListOf()
    private var voiceprintEnrollmentOverlay: android.widget.FrameLayout? = null

    private val voiceIntentExecutor = VoiceIntentExecutor(
        loadPatient = { name -> searchPatients(name) },
        showVitals = { fetchPatientSection("vitals") },
        showLabs = { fetchPatientSection("labs") },
        speakSummary = { speakPatientSummary() },
    )
    private var isAwaitingVoiceprintVerify: Boolean = false
    private var voiceprintVerifyCallback: ((Boolean) -> Unit)? = null

    // Feature #77: Continuous voiceprint authentication
    private var lastVoiceprintVerification: Long = 0L
    private var voiceprintConfidence: Float = 0f
    private var reVerifyIntervalMs: Long = 5 * 60 * 1000L  // 5 minutes default
    private val CONTINUOUS_AUTH_CHECK_INTERVAL_MS = 30 * 1000L  // Check every 30 seconds
    private var continuousAuthHandler: android.os.Handler? = null
    private var continuousAuthRunnable: Runnable? = null

    // Proximity sensor for auto-lock when glasses removed
    private var proximitySensor: android.hardware.Sensor? = null
    private var sensorManager: android.hardware.SensorManager? = null
    private var isGlassesOnFace: Boolean = true

    // Gesture Control (Feature #75) - Head nod (yes), shake (no), touchpad navigation
    private var headGestureDetector: HeadGestureDetector? = null
    private var isGestureControlEnabled: Boolean = true

    // Multi-language support (English, Spanish, Mandarin, Portuguese, Russian)
    private var currentLanguage: String = LANG_ENGLISH
    private var currentLocale: Locale = Locale.US

    // ═══════════════════════════════════════════════════════════════════════════
    // AI CLINICAL CO-PILOT (Feature #78)
    // ═══════════════════════════════════════════════════════════════════════════
    private var copilotConversationHistory: MutableList<Pair<String, String>> = mutableListOf()  // (role, content)
    private var isCopilotActive: Boolean = false
    private var lastCopilotQuestion: String = ""

    // ═══════════════════════════════════════════════════════════════════════════
    // RACIAL MEDICINE AWARENESS (Feature #79) - Addressing "white default" in medicine
    // ═══════════════════════════════════════════════════════════════════════════
    private var currentPatientSkinType: String? = null  // Fitzpatrick I-VI
    private var currentPatientAncestry: String? = null  // For pharmacogenomics
    private var racialMedicineAlerts: MutableList<JSONObject> = mutableListOf()
    private var skinAssessmentGuidance: JSONObject? = null

    // ═══════════════════════════════════════════════════════════════════════════
    // CULTURAL CARE PREFERENCES (Feature #80) - Religious/cultural healthcare needs
    // ═══════════════════════════════════════════════════════════════════════════
    private var culturalCarePreferences: JSONObject? = null
    private var culturalCareAlerts: MutableList<JSONObject> = mutableListOf()
    private var religiousGuidance: JSONObject? = null

    // ═══════════════════════════════════════════════════════════════════════════
    // IMPLICIT BIAS ALERTS (Feature #81) - Gentle reminders during documentation
    // ═══════════════════════════════════════════════════════════════════════════
    private var biasAlertsEnabled: Boolean = true  // Can be toggled off
    private var lastBiasAlert: JSONObject? = null
    private var biasAlertShownThisSession: Boolean = false  // Don't spam alerts
    private var currentBiasContext: String? = null  // "pain_assessment", "cardiac_symptoms", etc.

    // ═══════════════════════════════════════════════════════════════════════════
    // MATERNAL HEALTH MONITORING (Feature #82) - High-risk OB alerts for Black mothers
    // ═══════════════════════════════════════════════════════════════════════════
    private var currentMaternalStatus: String? = null  // "pregnant", "postpartum", null
    private var maternalRiskLevel: String = "standard"  // "standard", "elevated", "high"
    private var maternalAlerts: MutableList<JSONObject> = mutableListOf()
    private var postpartumChecklist: List<String> = emptyList()

    // ═══════════════════════════════════════════════════════════════════════════
    // SDOH INTEGRATION (Feature #84) - Social Determinants of Health
    // ═══════════════════════════════════════════════════════════════════════════
    private var patientSdohFactors: MutableList<String> = mutableListOf()  // Factor IDs
    private var sdohRiskLevel: String = "low"  // "low", "moderate", "high", "critical"
    private var sdohAlerts: MutableList<JSONObject> = mutableListOf()
    private var sdohInterventions: MutableList<JSONObject> = mutableListOf()
    private var sdohScreeningComplete: Boolean = false

    // ═══════════════════════════════════════════════════════════════════════════
    // HEALTH LITERACY ASSESSMENT (Feature #85)
    // ═══════════════════════════════════════════════════════════════════════════
    private var patientLiteracyLevel: String = "adequate"  // "inadequate", "marginal", "adequate", "proficient"
    private var literacyAssessed: Boolean = false
    private var teachBackRequired: Boolean = false
    private var currentDischargeCondition: String? = null

    // ═══════════════════════════════════════════════════════════════════════════
    // INTERPRETER INTEGRATION (Feature #86) - Real-time language services
    // ═══════════════════════════════════════════════════════════════════════════
    private var interpreterSessionActive: Boolean = false
    private var interpreterSessionId: String? = null
    private var interpreterType: String = "phone"  // "in_person", "video", "phone", "staff", "ad_hoc"
    private var patientPreferredLanguage: String? = null  // ISO code (es, zh, vi, etc.)
    private var patientPreferredLanguageName: String? = null  // Full name (Spanish, Chinese, etc.)
    private var interpreterRequired: Boolean = false
    private var familyInterpreterDeclined: Boolean = false
    private var currentInterpreterService: String? = null  // "language_line", "cyracom", "stratus"
    private var interpreterPhoneNumber: String? = null  // For phone interpretation
    private var clinicalPhrases: MutableList<JSONObject> = mutableListOf()  // Pre-translated phrases

    // ═══════════════════════════════════════════════════════════════════════════
    // AMBIENT CLINICAL INTELLIGENCE (ACI) - Auto-documentation from room audio
    // ═══════════════════════════════════════════════════════════════════════════
    private var isAmbientMode: Boolean = false  // Continuous background listening
    private var ambientTranscriptBuffer: StringBuilder = StringBuilder()
    private var ambientStartTime: Long = 0L
    private val extractedEntities = AmbientClinicalEntities()
    private var aciOverlay: android.widget.FrameLayout? = null
    private var aciEntitiesText: TextView? = null
    private var aciTranscriptText: TextView? = null
    private var lastEntityUpdateTime: Long = 0L
    private val ENTITY_UPDATE_DEBOUNCE_MS = 500L  // Debounce entity extraction

    // Clinical entity storage for ACI
    data class AmbientClinicalEntities(
        val chiefComplaints: MutableList<String> = mutableListOf(),
        val symptoms: MutableList<String> = mutableListOf(),
        val medications: MutableList<String> = mutableListOf(),
        val allergiesMentioned: MutableList<String> = mutableListOf(),
        val vitalsMentioned: MutableMap<String, String> = mutableMapOf(),
        val medicalHistory: MutableList<String> = mutableListOf(),
        val socialHistory: MutableList<String> = mutableListOf(),
        val familyHistory: MutableList<String> = mutableListOf(),
        val reviewOfSystems: MutableMap<String, MutableList<String>> = mutableMapOf(),
        val physicalExamFindings: MutableList<String> = mutableListOf(),
        val assessments: MutableList<String> = mutableListOf(),
        val plans: MutableList<String> = mutableListOf(),
        val speakerSegments: MutableList<SpeakerSegment> = mutableListOf()
    ) {
        fun clear() {
            chiefComplaints.clear()
            symptoms.clear()
            medications.clear()
            allergiesMentioned.clear()
            vitalsMentioned.clear()
            medicalHistory.clear()
            socialHistory.clear()
            familyHistory.clear()
            reviewOfSystems.clear()
            physicalExamFindings.clear()
            assessments.clear()
            plans.clear()
            speakerSegments.clear()
        }

        fun hasEntities(): Boolean {
            return chiefComplaints.isNotEmpty() || symptoms.isNotEmpty() ||
                   medications.isNotEmpty() || vitalsMentioned.isNotEmpty() ||
                   assessments.isNotEmpty() || plans.isNotEmpty()
        }
    }

    data class SpeakerSegment(
        val speaker: String,  // "Patient", "Clinician", "Unknown"
        val text: String,
        val timestamp: Long
    )

    // Voice note editing - edit history for undo functionality
    private val editHistory = mutableListOf<String>()
    private val MAX_EDIT_HISTORY = 10

    // Section aliases for voice commands (maps spoken words to canonical section names)
    private val sectionAliases = mapOf(
        "subjective" to listOf("subjective", "chief complaint", "chief", "cc", "hpi", "history"),
        "objective" to listOf("objective", "exam", "physical", "vitals", "physical exam"),
        "assessment" to listOf("assessment", "diagnosis", "impression", "dx", "diagnoses"),
        "plan" to listOf("plan", "treatment", "recommendations", "rx", "orders")
    )

    // ═══════════════════════════════════════════════════════════════════════════
    // MULTI-LANGUAGE SUPPORT - Command translations
    // ═══════════════════════════════════════════════════════════════════════════

    // Spanish command mappings (Spanish phrase -> English command keyword)
    private val spanishCommands = mapOf(
        // Patient commands
        "cargar paciente" to "load patient",
        "buscar paciente" to "find patient",
        "escanear pulsera" to "scan wristband",
        "resumen del paciente" to "patient summary",
        "dime sobre el paciente" to "tell me about patient",
        "información del paciente" to "brief me",

        // Data display commands
        "mostrar signos vitales" to "show vitals",
        "mostrar alergias" to "show allergies",
        "mostrar medicamentos" to "show meds",
        "mostrar laboratorios" to "show labs",
        "mostrar procedimientos" to "show procedures",
        "mostrar inmunizaciones" to "show immunizations",
        "mostrar condiciones" to "show conditions",
        "mostrar planes de cuidado" to "show care plans",
        "notas clínicas" to "clinical notes",

        // Documentation commands
        "iniciar nota" to "start note",
        "terminar nota" to "stop note",
        "guardar nota" to "save note",
        "enviar a historia clínica" to "push to ehr",
        "editar nota" to "edit note",
        "restaurar nota" to "reset note",

        // Transcription commands
        "transcripción en vivo" to "live transcribe",
        "iniciar transcripción" to "start transcription",
        "detener transcripción" to "stop transcription",
        "generar nota" to "generate note",
        "volver a grabar" to "re-record",

        // Navigation and control
        "cerrar" to "close",
        "volver" to "go back",
        "ayuda" to "help",
        "comandos" to "show commands",
        "dejar de escuchar" to "stop listening",
        "silencio" to "mute",
        "desbloquear" to "unlock",
        "bloquear sesión" to "lock session",

        // Note sections (Spanish to English)
        "subjetivo" to "subjective",
        "objetivo" to "objective",
        "evaluación" to "assessment",
        "diagnóstico" to "diagnosis",
        "tratamiento" to "plan",

        // SOAP editing
        "cambiar" to "change",
        "agregar a" to "add to",
        "borrar última oración" to "delete last sentence",
        "deshacer" to "undo",
        "limpiar" to "clear",

        // Orders
        "ordenar" to "order",
        "laboratorios" to "labs",
        "hemograma" to "cbc",
        "química sanguínea" to "cmp",
        "análisis de orina" to "ua",
        "radiografía" to "xray",
        "radiografía de tórax" to "chest xray",
        "tomografía" to "ct",
        "resonancia" to "mri",
        "mostrar órdenes" to "show orders",
        "cancelar orden" to "cancel order",

        // Handoff and discharge
        "reporte de entrega" to "handoff report",
        "resumen de alta" to "discharge summary",
        "instrucciones de alta" to "discharge instructions",
        "leer alta" to "read discharge",

        // Checklists
        "mostrar listas" to "show checklists",
        "iniciar lista" to "start checklist",
        "marcar" to "check",
        "marcar todo" to "check all",

        // Timer
        "iniciar temporizador" to "start timer",
        "detener temporizador" to "stop timer",
        "cuánto tiempo" to "how long",

        // Medical calculator
        "calcular" to "calculate",
        "índice de masa corporal" to "bmi",
        "tasa de filtración" to "egfr",
        "calculadora médica" to "medical calculator"
    )

    // Spanish section aliases
    private val spanishSectionAliases = mapOf(
        "subjective" to listOf("subjetivo", "queja principal", "historia", "motivo de consulta"),
        "objective" to listOf("objetivo", "examen", "físico", "signos vitales", "examen físico"),
        "assessment" to listOf("evaluación", "diagnóstico", "impresión", "dx"),
        "plan" to listOf("plan", "tratamiento", "recomendaciones", "indicaciones")
    )

    // Russian command mappings (Russian phrase -> English command keyword)
    private val russianCommands = mapOf(
        // Patient commands
        "загрузить пациента" to "load patient",
        "найти пациента" to "find patient",
        "сканировать браслет" to "scan wristband",
        "информация о пациенте" to "patient summary",
        "расскажи о пациенте" to "tell me about patient",
        "краткая информация" to "brief me",

        // Data display commands
        "показать витальные" to "show vitals",
        "показать жизненные показатели" to "show vitals",
        "показать аллергии" to "show allergies",
        "показать лекарства" to "show meds",
        "показать медикаменты" to "show meds",
        "показать анализы" to "show labs",
        "показать лаборатории" to "show labs",
        "показать процедуры" to "show procedures",
        "показать прививки" to "show immunizations",
        "показать вакцинации" to "show immunizations",
        "показать состояния" to "show conditions",
        "показать диагнозы" to "show conditions",
        "показать план лечения" to "show care plans",
        "клинические записи" to "clinical notes",

        // Documentation commands
        "начать запись" to "start note",
        "начать заметку" to "start note",
        "закончить запись" to "stop note",
        "сохранить запись" to "save note",
        "сохранить заметку" to "save note",
        "отправить в историю болезни" to "push to ehr",
        "редактировать запись" to "edit note",
        "сбросить запись" to "reset note",

        // Transcription commands
        "живая транскрипция" to "live transcribe",
        "начать транскрипцию" to "start transcription",
        "остановить транскрипцию" to "stop transcription",
        "создать заметку" to "generate note",
        "перезаписать" to "re-record",

        // Navigation and control
        "закрыть" to "close",
        "назад" to "go back",
        "помощь" to "help",
        "команды" to "show commands",
        "перестать слушать" to "stop listening",
        "молчать" to "mute",
        "разблокировать" to "unlock",
        "заблокировать сессию" to "lock session",

        // Note sections (Russian to English)
        "субъективное" to "subjective",
        "объективное" to "objective",
        "оценка" to "assessment",
        "диагноз" to "diagnosis",
        "лечение" to "plan",

        // SOAP editing
        "изменить" to "change",
        "добавить к" to "add to",
        "удалить последнее предложение" to "delete last sentence",
        "отменить" to "undo",
        "очистить" to "clear",

        // Orders
        "назначить" to "order",
        "заказать" to "order",
        "общий анализ крови" to "cbc",
        "биохимия крови" to "cmp",
        "анализ мочи" to "ua",
        "рентген" to "xray",
        "рентген грудной клетки" to "chest xray",
        "компьютерная томография" to "ct",
        "мрт" to "mri",
        "показать назначения" to "show orders",
        "отменить назначение" to "cancel order",

        // Handoff and discharge
        "отчёт о передаче" to "handoff report",
        "выписка" to "discharge summary",
        "инструкции при выписке" to "discharge instructions",
        "прочитать выписку" to "read discharge",

        // Checklists
        "показать чек-листы" to "show checklists",
        "начать чек-лист" to "start checklist",
        "отметить" to "check",
        "отметить всё" to "check all",

        // Timer
        "запустить таймер" to "start timer",
        "остановить таймер" to "stop timer",
        "сколько времени" to "how long",

        // Medical calculator
        "рассчитать" to "calculate",
        "индекс массы тела" to "bmi",
        "скорость клубочковой фильтрации" to "egfr",
        "медицинский калькулятор" to "medical calculator"
    )

    // Russian section aliases
    private val russianSectionAliases = mapOf(
        "subjective" to listOf("субъективное", "жалобы", "анамнез", "история болезни"),
        "objective" to listOf("объективное", "осмотр", "физикальное", "витальные"),
        "assessment" to listOf("оценка", "диагноз", "заключение"),
        "plan" to listOf("план", "лечение", "рекомендации", "назначения")
    )

    // ═══════════════════════════════════════════════════════════════════════════
    // AMBIENT CLINICAL INTELLIGENCE - Entity Extraction Patterns
    // ═══════════════════════════════════════════════════════════════════════════

    // Symptom keywords for automatic detection
    private val symptomPatterns = listOf(
        // Pain
        "pain", "ache", "aching", "hurts", "hurting", "sore", "soreness", "tender", "tenderness",
        "sharp pain", "dull pain", "burning", "throbbing", "stabbing", "cramping", "cramps",
        // General symptoms
        "fever", "chills", "fatigue", "tired", "weakness", "malaise", "weight loss", "weight gain",
        "night sweats", "loss of appetite", "nausea", "vomiting", "diarrhea", "constipation",
        // Respiratory
        "cough", "coughing", "shortness of breath", "difficulty breathing", "wheezing", "congestion",
        "runny nose", "sore throat", "hoarseness", "chest tightness",
        // Cardiac
        "chest pain", "palpitations", "racing heart", "irregular heartbeat", "swelling", "edema",
        // Neurological
        "headache", "dizziness", "lightheaded", "vertigo", "numbness", "tingling", "weakness",
        "confusion", "memory problems", "seizure", "tremor", "balance problems",
        // GI
        "abdominal pain", "stomach pain", "bloating", "heartburn", "reflux", "difficulty swallowing",
        "blood in stool", "black stool", "yellow skin", "jaundice",
        // Musculoskeletal
        "joint pain", "back pain", "neck pain", "stiffness", "swollen joints", "limited range",
        // Skin
        "rash", "itching", "hives", "bruising", "wound", "lesion", "discoloration",
        // Urinary
        "frequent urination", "painful urination", "blood in urine", "incontinence",
        // Mental health
        "anxiety", "depression", "insomnia", "trouble sleeping", "stress"
    )

    // Chief complaint trigger phrases
    private val chiefComplaintTriggers = listOf(
        "i came in because", "i'm here because", "my main problem is", "what brought me in",
        "i've been having", "i've been experiencing", "started having", "been dealing with",
        "the reason i'm here", "my concern is", "i'm worried about", "bothering me",
        "chief complaint", "presenting with", "complains of", "reports"
    )

    // Medication mention patterns
    private val medicationPatterns = listOf(
        // Common medications
        "aspirin", "tylenol", "acetaminophen", "ibuprofen", "advil", "motrin", "naproxen", "aleve",
        "lisinopril", "metoprolol", "amlodipine", "losartan", "hydrochlorothiazide", "atenolol",
        "metformin", "glipizide", "insulin", "januvia", "ozempic", "trulicity",
        "atorvastatin", "lipitor", "simvastatin", "pravastatin", "rosuvastatin", "crestor",
        "omeprazole", "prilosec", "pantoprazole", "protonix", "famotidine", "pepcid",
        "levothyroxine", "synthroid", "prednisone", "gabapentin", "lyrica", "tramadol",
        "hydrocodone", "oxycodone", "morphine", "percocet", "vicodin", "norco",
        "amoxicillin", "azithromycin", "zithromax", "ciprofloxacin", "doxycycline",
        "sertraline", "zoloft", "fluoxetine", "prozac", "escitalopram", "lexapro",
        "alprazolam", "xanax", "lorazepam", "ativan", "clonazepam", "klonopin",
        "warfarin", "coumadin", "eliquis", "xarelto", "plavix", "clopidogrel",
        // Trigger phrases
        "taking", "prescribed", "medication", "medicine", "drug", "pills", "tablet", "capsule",
        "started on", "switched to", "stopped taking", "ran out of", "refill"
    )

    // Allergy mention patterns
    private val allergyPatterns = listOf(
        "allergic to", "allergy to", "allergies", "can't take", "react to", "reaction to",
        "breaks out", "anaphylaxis", "hives from", "swelling from", "rash from"
    )

    // Vital sign patterns (for extraction from conversation)
    private val vitalPatterns = mapOf(
        "blood_pressure" to listOf("blood pressure", "bp", "pressure is", "pressure was", "systolic", "diastolic"),
        "heart_rate" to listOf("heart rate", "pulse", "pulse is", "pulse was", "beats per minute", "bpm"),
        "temperature" to listOf("temperature", "temp", "fever of", "running a fever"),
        "respiratory_rate" to listOf("respiratory rate", "breathing rate", "breaths per minute"),
        "oxygen" to listOf("oxygen", "o2 sat", "saturation", "pulse ox", "spo2"),
        "weight" to listOf("weight", "weigh", "pounds", "kilograms", "kg", "lbs"),
        "height" to listOf("height", "tall", "feet", "inches")
    )

    // Medical history triggers
    private val medicalHistoryTriggers = listOf(
        "history of", "diagnosed with", "had a", "previous", "past medical", "pmh",
        "surgery for", "hospitalized for", "treated for"
    )

    // Social history triggers
    private val socialHistoryTriggers = listOf(
        "smoke", "smoking", "cigarettes", "tobacco", "vape", "vaping",
        "drink", "drinking", "alcohol", "beer", "wine", "liquor",
        "drugs", "marijuana", "cannabis", "cocaine", "heroin", "opioids",
        "exercise", "diet", "occupation", "work", "job", "married", "single", "divorced",
        "live alone", "live with", "caregiver", "support system"
    )

    // Family history triggers
    private val familyHistoryTriggers = listOf(
        "family history", "mother had", "father had", "parents", "siblings", "brother", "sister",
        "grandmother", "grandfather", "runs in the family", "hereditary", "genetic"
    )

    // Review of systems categories
    private val rosCategories = mapOf(
        "constitutional" to listOf("fever", "chills", "weight", "fatigue", "malaise", "appetite"),
        "heent" to listOf("headache", "vision", "hearing", "ear", "nose", "throat", "sinus"),
        "cardiovascular" to listOf("chest pain", "palpitations", "edema", "leg swelling"),
        "respiratory" to listOf("cough", "shortness of breath", "wheezing", "sputum"),
        "gastrointestinal" to listOf("nausea", "vomiting", "diarrhea", "constipation", "abdominal"),
        "genitourinary" to listOf("urination", "frequency", "urgency", "dysuria", "hematuria"),
        "musculoskeletal" to listOf("joint", "muscle", "back pain", "weakness", "stiffness"),
        "neurological" to listOf("numbness", "tingling", "weakness", "dizziness", "seizure"),
        "psychiatric" to listOf("depression", "anxiety", "sleep", "mood", "stress"),
        "skin" to listOf("rash", "itching", "lesion", "wound", "discoloration")
    )

    // Physical exam triggers
    private val physicalExamTriggers = listOf(
        "on exam", "examination shows", "physical exam", "upon examination",
        "lungs are", "heart sounds", "abdomen is", "extremities", "neurologically",
        "no tenderness", "tenderness to", "normal", "abnormal", "unremarkable"
    )

    // Assessment/diagnosis triggers
    private val assessmentTriggers = listOf(
        "i think", "likely", "probably", "appears to be", "consistent with", "suggestive of",
        "differential includes", "diagnosis", "assessment", "impression", "most likely"
    )

    // Plan triggers
    private val planTriggers = listOf(
        "i'm going to", "we'll", "let's", "plan is", "i recommend", "i suggest",
        "order", "prescribe", "start you on", "refer to", "follow up", "come back",
        "blood work", "imaging", "x-ray", "ct scan", "mri", "ultrasound"
    )

    // Speaker identification patterns
    private val patientSpeakerPatterns = listOf(
        "i have", "i feel", "i've been", "my", "i'm", "i am", "i can't", "i don't",
        "it hurts", "it started", "for me", "bothering me",
        "i noticed", "i woke up", "i took", "i tried", "i think",
        "fever", "pain", "hurts", "ache", "sore", "tired", "nausea",
        "for days", "for weeks", "since yesterday", "last night", "this morning"
    )

    private val clinicianSpeakerPatterns = listOf(
        "let me", "i'm going to", "we need to", "i'll order", "i recommend",
        "your labs", "your vitals", "examination shows", "on exam",
        "looking at", "i see", "i notice", "deep breath", "breathe in", "breathe out",
        "follow my", "look at me", "squeeze my", "can you", "does this", "any pain when"
    )

    // Voice commands to filter from ACI transcript (these are not clinical content)
    private val aciVoiceCommands = listOf(
        "stop ambient", "end ambient", "finish ambient", "stop listening",
        "cancel ambient", "discard", "never mind",
        "generate note", "create note", "make note", "document this",
        "hey mdx", "mdx mode", "stop", "delete", "cancel",
        "show entities", "view transcript", "save note",
        "start ambient", "ambient mode"
    )

    // Track last speaker for context-aware identification
    private var lastIdentifiedSpeaker: String = "Clinician"

    // TTS feedback messages in multiple languages
    private val ttsMessages = mapOf(
        "patient_loaded" to mapOf(
            LANG_ENGLISH to "Patient loaded",
            LANG_SPANISH to "Paciente cargado",
            LANG_RUSSIAN to "Пациент загружен"
        ),
        "no_patient" to mapOf(
            LANG_ENGLISH to "No patient loaded. Say load patient first.",
            LANG_SPANISH to "No hay paciente cargado. Diga cargar paciente primero.",
            LANG_RUSSIAN to "Пациент не загружен. Скажите загрузить пациента."
        ),
        "recording_started" to mapOf(
            LANG_ENGLISH to "Recording started",
            LANG_SPANISH to "Grabación iniciada",
            LANG_RUSSIAN to "Запись начата"
        ),
        "recording_stopped" to mapOf(
            LANG_ENGLISH to "Recording stopped",
            LANG_SPANISH to "Grabación detenida",
            LANG_RUSSIAN to "Запись остановлена"
        ),
        "note_saved" to mapOf(
            LANG_ENGLISH to "Note saved",
            LANG_SPANISH to "Nota guardada",
            LANG_RUSSIAN to "Запись сохранена"
        ),
        "note_generated" to mapOf(
            LANG_ENGLISH to "Note generated",
            LANG_SPANISH to "Nota generada",
            LANG_RUSSIAN to "Запись создана"
        ),
        "voice_commands_off" to mapOf(
            LANG_ENGLISH to "Voice commands disabled",
            LANG_SPANISH to "Comandos de voz desactivados",
            LANG_RUSSIAN to "Голосовые команды отключены"
        ),
        "language_changed" to mapOf(
            LANG_ENGLISH to "Language changed to English",
            LANG_SPANISH to "Idioma cambiado a español",
            LANG_RUSSIAN to "Язык изменён на русский"
        ),
        "listening" to mapOf(
            LANG_ENGLISH to "Listening",
            LANG_SPANISH to "Escuchando",
            LANG_RUSSIAN to "Слушаю"
        ),
        "critical_allergy" to mapOf(
            LANG_ENGLISH to "Warning! Critical allergy:",
            LANG_SPANISH to "¡Advertencia! Alergia crítica:",
            LANG_RUSSIAN to "Внимание! Критическая аллергия:"
        ),
        "critical_vital" to mapOf(
            LANG_ENGLISH to "Alert! Critical vital sign:",
            LANG_SPANISH to "¡Alerta! Signo vital crítico:",
            LANG_RUSSIAN to "Тревога! Критический показатель:"
        )
    )

    // Macro templates for quick insertion
    private val macroTemplates = mapOf(
        "normal_exam" to """General: Alert, oriented, no acute distress
HEENT: Normocephalic, PERRL, oropharynx clear
Neck: Supple, no lymphadenopathy
Lungs: Clear to auscultation bilaterally
Heart: Regular rate and rhythm, no murmurs
Abdomen: Soft, non-tender, non-distended
Extremities: No edema, pulses intact
Neuro: Grossly intact""",
        "normal_vitals" to "Vital signs within normal limits",
        "negative_ros" to "Review of systems negative except as noted in HPI",
        "follow_up" to "Follow up in 2 weeks, or sooner if symptoms worsen. Return to ED for fever >101, difficulty breathing, or worsening symptoms.",
        "diabetes_followup" to "Continue current diabetes regimen. Check A1C in 3 months. Continue dietary modifications. Return for routine follow-up.",
        "hypertension_followup" to "Continue current antihypertensive medications. Monitor blood pressure at home. Low sodium diet. Return in 1 month for BP check."
    )

    // Voice navigation - track current active scroll view for scroll commands
    private var currentScrollView: android.widget.ScrollView? = null
    private var currentContentText: TextView? = null  // For read-back

    // Voice dictation mode - direct speech-to-text into note sections
    private var isDictationMode: Boolean = false
    private var dictationTargetSection: String? = null  // Which section to dictate into
    private var dictationBuffer: StringBuilder = StringBuilder()  // Accumulates dictated text

    // ═══════════════════════════════════════════════════════════════════════════
    // ENCOUNTER TIMER - Track time spent with patient
    // ═══════════════════════════════════════════════════════════════════════════
    private var encounterStartTime: Long? = null  // System.currentTimeMillis() when timer started
    private var encounterTimerRunning: Boolean = false
    private var timerIndicatorView: TextView? = null  // Visual indicator showing elapsed time
    private var timerUpdateHandler: android.os.Handler? = null
    private var timerUpdateRunnable: Runnable? = null

    // ═══════════════════════════════════════════════════════════════════════════
    // VOICE ORDERS - State Variables
    // ═══════════════════════════════════════════════════════════════════════════
    private val orderQueue = mutableListOf<Order>()  // Pending orders for current patient
    private var pendingConfirmationOrder: Order? = null  // Order awaiting yes/no confirmation
    private val pendingPlanItems = mutableListOf<String>()  // Orders to add to Plan when note is generated
    private val ORDERS_KEY = "pending_orders"
    private val ORDERS_PATIENT_KEY = "orders_patient_id"

    // Lab orders database
    private val labOrders = mapOf(
        "cbc" to LabOrderInfo("CBC", "Complete Blood Count", "85025", listOf("cbc", "complete blood count", "blood count", "hemogram")),
        "cmp" to LabOrderInfo("CMP", "Comprehensive Metabolic Panel", "80053", listOf("cmp", "comprehensive metabolic", "metabolic panel", "chem 14")),
        "bmp" to LabOrderInfo("BMP", "Basic Metabolic Panel", "80048", listOf("bmp", "basic metabolic", "chem 7", "electrolytes")),
        "ua" to LabOrderInfo("UA", "Urinalysis", "81003", listOf("ua", "urinalysis", "urine test", "urine analysis")),
        "lipid" to LabOrderInfo("Lipid Panel", "Lipid Panel", "80061", listOf("lipid panel", "lipids", "cholesterol panel", "cholesterol")),
        "tsh" to LabOrderInfo("TSH", "Thyroid Stimulating Hormone", "84443", listOf("tsh", "thyroid", "thyroid function")),
        "hba1c" to LabOrderInfo("HbA1c", "Hemoglobin A1c", "83036", listOf("a1c", "hba1c", "hemoglobin a1c", "glycated")),
        "ptinr" to LabOrderInfo("PT/INR", "Prothrombin Time / INR", "85610", listOf("pt", "inr", "pt inr", "protime", "coagulation")),
        "troponin" to LabOrderInfo("Troponin", "Troponin I/T", "84484", listOf("troponin", "trop", "cardiac enzymes")),
        "bun" to LabOrderInfo("BUN/Creatinine", "BUN / Creatinine", "84520", listOf("bun", "creatinine", "renal function", "kidney function")),
        "uculture" to LabOrderInfo("Urine Culture", "Urine Culture and Sensitivity", "87086", listOf("urine culture", "ucx", "u culture")),
        "bculture" to LabOrderInfo("Blood Culture", "Blood Culture", "87040", listOf("blood culture", "bcx", "blood cx"))
    )

    // Imaging orders database
    private val imagingOrders = mapOf(
        "cxr" to ImagingOrderInfo("Chest X-ray", "Chest Radiograph", "71046", "chest", "xray", listOf("chest x-ray", "chest xray", "cxr", "chest radiograph", "chest film")),
        "cthead" to ImagingOrderInfo("CT Head", "CT Scan of Head", "70450", "head", "ct", listOf("ct head", "head ct", "ct brain", "brain ct", "ct scan head"), true),
        "ctchest" to ImagingOrderInfo("CT Chest", "CT Scan of Chest", "71250", "chest", "ct", listOf("ct chest", "chest ct", "ct thorax"), true),
        "ctabdomen" to ImagingOrderInfo("CT Abdomen/Pelvis", "CT Scan of Abdomen and Pelvis", "74176", "abdomen", "ct", listOf("ct abdomen", "abdominal ct", "ct abd pelvis", "ct belly", "ct abdomen pelvis"), true),
        "mribrain" to ImagingOrderInfo("MRI Brain", "MRI of Brain", "70551", "brain", "mri", listOf("mri brain", "brain mri", "mri head", "head mri"), true),
        "mrispine" to ImagingOrderInfo("MRI Spine", "MRI of Spine", "72148", "spine", "mri", listOf("mri spine", "spine mri", "mri lumbar", "mri cervical", "lumbar mri", "cervical mri"), true),
        "usabdomen" to ImagingOrderInfo("Ultrasound Abdomen", "Abdominal Ultrasound", "76700", "abdomen", "ultrasound", listOf("ultrasound abdomen", "abdominal ultrasound", "us abdomen", "abd us", "ruq ultrasound")),
        "uspelvis" to ImagingOrderInfo("Ultrasound Pelvis", "Pelvic Ultrasound", "76856", "pelvis", "ultrasound", listOf("pelvic ultrasound", "ultrasound pelvis", "us pelvis", "pelvic us")),
        "echo" to ImagingOrderInfo("Echocardiogram", "Transthoracic Echocardiogram", "93306", "heart", "ultrasound", listOf("echo", "echocardiogram", "tte", "heart ultrasound")),
        "xray" to ImagingOrderInfo("X-ray", "Radiograph", "73030", "extremity", "xray", listOf("x-ray", "xray", "radiograph"))
    )

    // Medication orders database
    private val medicationOrders = mapOf(
        "amoxicillin" to MedicationOrderInfo("Amoxicillin", "antibiotic", listOf("250mg", "500mg", "875mg"), listOf("TID", "BID"), listOf("7 days", "10 days", "14 days"), "PO", listOf("amoxicillin", "amox", "amoxil"), listOf("warfarin", "methotrexate"), listOf("penicillin", "ampicillin", "cephalosporin")),
        "azithromycin" to MedicationOrderInfo("Azithromycin", "antibiotic", listOf("250mg", "500mg"), listOf("daily"), listOf("3 days", "5 days"), "PO", listOf("azithromycin", "zithromax", "z-pack", "zpack"), listOf("warfarin"), listOf("macrolide", "erythromycin")),
        "ibuprofen" to MedicationOrderInfo("Ibuprofen", "nsaid", listOf("200mg", "400mg", "600mg", "800mg"), listOf("TID", "Q6H", "PRN"), listOf("5 days", "7 days", "as needed"), "PO", listOf("ibuprofen", "advil", "motrin"), listOf("warfarin", "aspirin", "lisinopril", "lithium", "methotrexate"), listOf("nsaid", "aspirin")),
        "acetaminophen" to MedicationOrderInfo("Acetaminophen", "analgesic", listOf("325mg", "500mg", "650mg", "1000mg"), listOf("Q4-6H", "PRN"), listOf("as needed"), "PO", listOf("acetaminophen", "tylenol", "apap"), listOf("warfarin"), listOf()),
        "prednisone" to MedicationOrderInfo("Prednisone", "corticosteroid", listOf("5mg", "10mg", "20mg", "40mg", "60mg"), listOf("daily", "BID"), listOf("5 days", "7 days", "taper"), "PO", listOf("prednisone", "deltasone", "pred"), listOf("nsaid", "warfarin", "insulin"), listOf("corticosteroid")),
        "omeprazole" to MedicationOrderInfo("Omeprazole", "ppi", listOf("20mg", "40mg"), listOf("daily", "BID"), listOf("2 weeks", "4 weeks", "8 weeks"), "PO", listOf("omeprazole", "prilosec", "ppi"), listOf("clopidogrel", "methotrexate"), listOf()),
        "metformin" to MedicationOrderInfo("Metformin", "antidiabetic", listOf("500mg", "850mg", "1000mg"), listOf("BID", "TID"), listOf("ongoing"), "PO", listOf("metformin", "glucophage"), listOf("contrast", "alcohol"), listOf()),
        "lisinopril" to MedicationOrderInfo("Lisinopril", "ace_inhibitor", listOf("2.5mg", "5mg", "10mg", "20mg", "40mg"), listOf("daily"), listOf("ongoing"), "PO", listOf("lisinopril", "zestril", "prinivil"), listOf("potassium", "spironolactone", "nsaid", "lithium"), listOf("ace inhibitor")),
        "amlodipine" to MedicationOrderInfo("Amlodipine", "calcium_channel_blocker", listOf("2.5mg", "5mg", "10mg"), listOf("daily"), listOf("ongoing"), "PO", listOf("amlodipine", "norvasc"), listOf("simvastatin"), listOf()),
        "hydrocodone" to MedicationOrderInfo("Hydrocodone/APAP", "opioid", listOf("5/325mg", "7.5/325mg", "10/325mg"), listOf("Q4-6H PRN"), listOf("3 days", "5 days", "7 days"), "PO", listOf("hydrocodone", "vicodin", "norco", "lortab"), listOf("benzodiazepine", "alcohol", "gabapentin"), listOf("opioid"), true)
    )

    // Frequency aliases for natural language parsing
    private val frequencyAliases = mapOf(
        "once daily" to "daily", "one time a day" to "daily", "once a day" to "daily",
        "twice daily" to "BID", "two times daily" to "BID", "twice a day" to "BID",
        "three times daily" to "TID", "three times a day" to "TID",
        "four times daily" to "QID", "four times a day" to "QID",
        "every 4 hours" to "Q4H", "every 6 hours" to "Q6H", "every 8 hours" to "Q8H", "every 12 hours" to "Q12H",
        "as needed" to "PRN", "when needed" to "PRN", "prn" to "PRN",
        "at bedtime" to "QHS", "before bed" to "QHS"
    )

    // ═══════════════════════════════════════════════════════════════════════════
    // ORDER SETS - Predefined bundles of orders for common clinical scenarios
    // ═══════════════════════════════════════════════════════════════════════════

    data class OrderSetItem(
        val type: OrderType,
        val orderKey: String,  // Key in the respective order database (labOrders, imagingOrders, etc.)
        val details: String = ""  // Optional details (e.g., "with contrast" for imaging)
    )

    data class OrderSetInfo(
        val id: String,
        val name: String,
        val displayName: String,
        val description: String,
        val items: List<OrderSetItem>,
        val aliases: List<String>
    )

    private val orderSets = mapOf(
        "chest_pain" to OrderSetInfo(
            id = "chest_pain",
            name = "Chest Pain Workup",
            displayName = "Chest Pain Workup",
            description = "Initial workup for acute chest pain / ACS rule-out",
            items = listOf(
                OrderSetItem(OrderType.LAB, "troponin"),
                OrderSetItem(OrderType.LAB, "cbc"),
                OrderSetItem(OrderType.LAB, "bmp"),
                OrderSetItem(OrderType.LAB, "ptinr"),
                OrderSetItem(OrderType.IMAGING, "cxr"),
                OrderSetItem(OrderType.IMAGING, "echo")
            ),
            aliases = listOf("chest pain", "chest pain workup", "acs workup", "acs", "cardiac workup", "rule out mi", "mi workup")
        ),
        "sepsis" to OrderSetInfo(
            id = "sepsis",
            name = "Sepsis Bundle",
            displayName = "Sepsis Bundle / Workup",
            description = "Initial sepsis workup per Surviving Sepsis guidelines",
            items = listOf(
                OrderSetItem(OrderType.LAB, "bculture"),
                OrderSetItem(OrderType.LAB, "cbc"),
                OrderSetItem(OrderType.LAB, "cmp"),
                OrderSetItem(OrderType.LAB, "ua"),
                OrderSetItem(OrderType.LAB, "uculture"),
                OrderSetItem(OrderType.IMAGING, "cxr")
            ),
            aliases = listOf("sepsis", "sepsis bundle", "sepsis workup", "septic workup", "infection workup")
        ),
        "dka" to OrderSetInfo(
            id = "dka",
            name = "DKA Protocol",
            displayName = "Diabetic Ketoacidosis Protocol",
            description = "Initial workup for DKA / hyperglycemic emergency",
            items = listOf(
                OrderSetItem(OrderType.LAB, "bmp"),
                OrderSetItem(OrderType.LAB, "cbc"),
                OrderSetItem(OrderType.LAB, "ua"),
                OrderSetItem(OrderType.LAB, "hba1c")
            ),
            aliases = listOf("dka", "dka protocol", "dka workup", "diabetic ketoacidosis", "hyperglycemia workup")
        ),
        "admission" to OrderSetInfo(
            id = "admission",
            name = "Admission Labs",
            displayName = "Standard Admission Labs",
            description = "Basic admission laboratory panel",
            items = listOf(
                OrderSetItem(OrderType.LAB, "cbc"),
                OrderSetItem(OrderType.LAB, "cmp"),
                OrderSetItem(OrderType.LAB, "ua"),
                OrderSetItem(OrderType.LAB, "ptinr")
            ),
            aliases = listOf("admission labs", "admission", "admit labs", "admission panel", "admit workup")
        ),
        "preop" to OrderSetInfo(
            id = "preop",
            name = "Preop Labs",
            displayName = "Preoperative Laboratory Panel",
            description = "Standard preoperative clearance labs",
            items = listOf(
                OrderSetItem(OrderType.LAB, "cbc"),
                OrderSetItem(OrderType.LAB, "bmp"),
                OrderSetItem(OrderType.LAB, "ptinr"),
                OrderSetItem(OrderType.IMAGING, "cxr")
            ),
            aliases = listOf("preop", "preop labs", "pre op", "pre-op labs", "surgical clearance", "preoperative")
        ),
        "stroke" to OrderSetInfo(
            id = "stroke",
            name = "Stroke Workup",
            displayName = "Acute Stroke Workup",
            description = "Initial workup for suspected stroke/CVA",
            items = listOf(
                OrderSetItem(OrderType.LAB, "cbc"),
                OrderSetItem(OrderType.LAB, "bmp"),
                OrderSetItem(OrderType.LAB, "ptinr"),
                OrderSetItem(OrderType.IMAGING, "cthead")
            ),
            aliases = listOf("stroke", "stroke workup", "cva", "cva workup", "code stroke")
        ),
        "chf" to OrderSetInfo(
            id = "chf",
            name = "CHF Exacerbation",
            displayName = "CHF Exacerbation Workup",
            description = "Workup for acute heart failure exacerbation",
            items = listOf(
                OrderSetItem(OrderType.LAB, "cbc"),
                OrderSetItem(OrderType.LAB, "bmp"),
                OrderSetItem(OrderType.LAB, "troponin"),
                OrderSetItem(OrderType.IMAGING, "cxr"),
                OrderSetItem(OrderType.IMAGING, "echo")
            ),
            aliases = listOf("chf", "chf exacerbation", "heart failure", "hf exacerbation", "fluid overload")
        ),
        "copd" to OrderSetInfo(
            id = "copd",
            name = "COPD Exacerbation",
            displayName = "COPD Exacerbation Workup",
            description = "Workup for acute COPD exacerbation",
            items = listOf(
                OrderSetItem(OrderType.LAB, "cbc"),
                OrderSetItem(OrderType.LAB, "bmp"),
                OrderSetItem(OrderType.IMAGING, "cxr")
            ),
            aliases = listOf("copd", "copd exacerbation", "copd flare", "respiratory distress")
        ),
        "abdominal_pain" to OrderSetInfo(
            id = "abdominal_pain",
            name = "Abdominal Pain Workup",
            displayName = "Acute Abdominal Pain Workup",
            description = "Initial workup for acute abdominal pain",
            items = listOf(
                OrderSetItem(OrderType.LAB, "cbc"),
                OrderSetItem(OrderType.LAB, "cmp"),
                OrderSetItem(OrderType.LAB, "lipid"),
                OrderSetItem(OrderType.LAB, "ua"),
                OrderSetItem(OrderType.IMAGING, "ctabdomen")
            ),
            aliases = listOf("abdominal pain", "abd pain", "belly pain", "abdominal workup", "acute abdomen")
        ),
        "uti" to OrderSetInfo(
            id = "uti",
            name = "UTI Workup",
            displayName = "Urinary Tract Infection Workup",
            description = "Workup for suspected urinary tract infection",
            items = listOf(
                OrderSetItem(OrderType.LAB, "ua"),
                OrderSetItem(OrderType.LAB, "uculture"),
                OrderSetItem(OrderType.LAB, "cbc"),
                OrderSetItem(OrderType.LAB, "bmp")
            ),
            aliases = listOf("uti", "uti workup", "urinary tract infection", "dysuria workup", "pyelonephritis")
        ),
        "pneumonia" to OrderSetInfo(
            id = "pneumonia",
            name = "Pneumonia Workup",
            displayName = "Community Acquired Pneumonia Workup",
            description = "Workup for suspected pneumonia",
            items = listOf(
                OrderSetItem(OrderType.LAB, "cbc"),
                OrderSetItem(OrderType.LAB, "bmp"),
                OrderSetItem(OrderType.LAB, "bculture"),
                OrderSetItem(OrderType.IMAGING, "cxr")
            ),
            aliases = listOf("pneumonia", "pneumonia workup", "cap", "community acquired pneumonia", "lung infection")
        ),
        "pe" to OrderSetInfo(
            id = "pe",
            name = "PE Workup",
            displayName = "Pulmonary Embolism Workup",
            description = "Workup for suspected pulmonary embolism",
            items = listOf(
                OrderSetItem(OrderType.LAB, "cbc"),
                OrderSetItem(OrderType.LAB, "bmp"),
                OrderSetItem(OrderType.LAB, "ptinr"),
                OrderSetItem(OrderType.LAB, "troponin"),
                OrderSetItem(OrderType.IMAGING, "ctchest")
            ),
            aliases = listOf("pe", "pe workup", "pulmonary embolism", "pulmonary embolus", "dvt pe workup")
        )
    )

    // ═══════════════════════════════════════════════════════════════════════════
    // VOICE VITALS ENTRY - Capture vitals by voice
    // ═══════════════════════════════════════════════════════════════════════════

    enum class VitalType {
        BLOOD_PRESSURE,
        HEART_RATE,
        TEMPERATURE,
        OXYGEN_SATURATION,
        RESPIRATORY_RATE,
        WEIGHT,
        HEIGHT,
        PAIN_LEVEL
    }

    data class CapturedVital(
        val type: VitalType,
        val value: String,           // "120/80", "72", "98.6"
        val unit: String,            // "mmHg", "bpm", "°F"
        val displayName: String,     // "Blood Pressure", "Heart Rate"
        val timestamp: Long = System.currentTimeMillis()
    )

    // Vital reference ranges for validation
    data class VitalRange(
        val min: Double,
        val max: Double,
        val criticalLow: Double? = null,
        val criticalHigh: Double? = null
    )

    private val vitalRanges = mapOf(
        "systolic" to VitalRange(60.0, 250.0, 70.0, 180.0),
        "diastolic" to VitalRange(30.0, 150.0, 40.0, 120.0),
        "heart_rate" to VitalRange(20.0, 250.0, 40.0, 150.0),
        "temperature_f" to VitalRange(90.0, 110.0, 95.0, 104.0),
        "temperature_c" to VitalRange(32.0, 43.0, 35.0, 40.0),
        "oxygen_saturation" to VitalRange(50.0, 100.0, 88.0, null),
        "respiratory_rate" to VitalRange(4.0, 60.0, 8.0, 30.0),
        "weight_lbs" to VitalRange(1.0, 1000.0),
        "weight_kg" to VitalRange(0.5, 500.0),
        "height_in" to VitalRange(10.0, 100.0),
        "height_cm" to VitalRange(25.0, 250.0),
        "pain" to VitalRange(0.0, 10.0)
    )

    // Vital aliases for voice recognition
    private val vitalAliases = mapOf(
        VitalType.BLOOD_PRESSURE to listOf("bp", "blood pressure", "pressure", "b p"),
        VitalType.HEART_RATE to listOf("heart rate", "pulse", "hr", "heartrate", "heart beat", "bpm"),
        VitalType.TEMPERATURE to listOf("temp", "temperature", "fever"),
        VitalType.OXYGEN_SATURATION to listOf("o2", "oxygen", "sat", "sats", "o2 sat", "oxygen saturation", "spo2", "pulse ox"),
        VitalType.RESPIRATORY_RATE to listOf("respiratory rate", "respirations", "resp rate", "rr", "breathing rate", "breaths"),
        VitalType.WEIGHT to listOf("weight", "wt"),
        VitalType.HEIGHT to listOf("height", "ht", "tall"),
        VitalType.PAIN_LEVEL to listOf("pain", "pain level", "pain scale", "pain score")
    )

    // Captured vitals storage
    private val capturedVitals = mutableListOf<CapturedVital>()

    // Voice templates - built-in note templates with auto-fill variables
    // Variables: {{patient_name}}, {{dob}}, {{age}}, {{gender}}, {{medications}}, {{allergies}}, {{vitals}}, {{conditions}}, {{date}}
    private val USER_TEMPLATES_KEY = "user_note_templates"

    // Custom voice commands - user-defined command aliases and macros
    private val CUSTOM_COMMANDS_KEY = "custom_voice_commands"

    /**
     * Custom voice command that maps a trigger phrase to one or more actions
     */
    data class CustomCommand(
        val name: String,           // Display name (e.g., "Admission Check")
        val trigger: String,        // Trigger phrase (e.g., "admission check")
        val actions: List<String>,  // List of actions to execute (e.g., ["show vitals", "show meds"])
        val description: String = "" // Optional description
    ) {
        fun toJson(): JSONObject {
            return JSONObject().apply {
                put("name", name)
                put("trigger", trigger)
                put("actions", JSONArray(actions))
                put("description", description)
            }
        }

        companion object {
            fun fromJson(json: JSONObject): CustomCommand {
                val actionsArray = json.optJSONArray("actions") ?: JSONArray()
                val actions = mutableListOf<String>()
                for (i in 0 until actionsArray.length()) {
                    actions.add(actionsArray.getString(i))
                }
                return CustomCommand(
                    name = json.optString("name", ""),
                    trigger = json.optString("trigger", ""),
                    actions = actions,
                    description = json.optString("description", "")
                )
            }
        }
    }

    private val builtInTemplates = mapOf(
        "diabetes" to NoteTemplate(
            name = "Diabetes Follow-up",
            category = "Primary Care",
            noteType = "SOAP",
            content = """▸ S:
{{patient_name}} presents for diabetes follow-up.
Reports compliance with medications and diet.
No hypoglycemic episodes. No polyuria/polydipsia.
Current medications: {{medications}}

▸ O:
Vitals: {{vitals}}
General: Alert, well-appearing
Foot exam: Skin intact, sensation normal, pulses palpable
Eyes: No retinopathy noted

▸ A:
Type 2 Diabetes Mellitus - management ongoing
{{conditions}}

▸ P:
• Continue current diabetes regimen
• A1C recheck in 3 months
• Annual eye exam reminder given
• Foot care education reinforced
• Diet and exercise counseling provided
• Follow up in 3 months"""
        ),
        "hypertension" to NoteTemplate(
            name = "Hypertension Follow-up",
            category = "Primary Care",
            noteType = "SOAP",
            content = """▸ S:
{{patient_name}} presents for hypertension follow-up.
Reports taking medications as prescribed.
Denies headaches, chest pain, or shortness of breath.
Home BP readings: [patient to report]
Current medications: {{medications}}

▸ O:
Vitals: {{vitals}}
General: Alert, no acute distress
CV: Regular rate and rhythm, no murmurs
Lungs: Clear bilaterally

▸ A:
Essential Hypertension - {{controlled/uncontrolled}}
{{conditions}}

▸ P:
• Continue current antihypertensive regimen
• Low sodium diet reinforced
• Continue home BP monitoring
• Labs: BMP, lipid panel if due
• Follow up in 1-3 months"""
        ),
        "uri" to NoteTemplate(
            name = "Upper Respiratory Infection",
            category = "Urgent Care",
            noteType = "SOAP",
            content = """▸ S:
{{patient_name}} presents with upper respiratory symptoms.
Duration: [X] days
Symptoms: Nasal congestion, rhinorrhea, sore throat, cough
Denies fever, shortness of breath, ear pain.
No known sick contacts. Allergies: {{allergies}}

▸ O:
Vitals: {{vitals}}
General: Mild distress, appears fatigued
HEENT: TMs clear, oropharynx mildly erythematous, no exudates
Neck: No lymphadenopathy
Lungs: Clear to auscultation bilaterally

▸ A:
Acute Upper Respiratory Infection (viral)

▸ P:
• Supportive care: rest, fluids, OTC decongestants
• Honey for cough (if >1 year old)
• Acetaminophen or ibuprofen for discomfort
• Return if: fever >101, symptoms >10 days, difficulty breathing
• No antibiotics indicated at this time"""
        ),
        "annual_physical" to NoteTemplate(
            name = "Annual Physical",
            category = "Primary Care",
            noteType = "HP",
            content = """▸ CHIEF COMPLAINT:
Annual wellness examination

▸ HPI:
{{patient_name}}, {{age}} year old {{gender}}, presents for annual physical.
No acute complaints today.
Medications: {{medications}}
Allergies: {{allergies}}

▸ PMH:
{{conditions}}

▸ SOCIAL HISTORY:
Tobacco: [Never/Former/Current]
Alcohol: [None/Social/Daily]
Exercise: [Frequency]
Diet: [Description]

▸ FAMILY HISTORY:
[To be documented]

▸ ROS:
Constitutional: No fever, weight changes
Eyes: No vision changes
ENT: No hearing loss, sore throat
CV: No chest pain, palpitations
Respiratory: No cough, shortness of breath
GI: No abdominal pain, changes in bowel habits
GU: No dysuria, frequency
MSK: No joint pain
Neuro: No headaches, weakness
Psych: No depression, anxiety

▸ PHYSICAL EXAM:
Vitals: {{vitals}}
General: Well-appearing, no acute distress
HEENT: Normocephalic, PERRL, TMs clear, oropharynx normal
Neck: Supple, no lymphadenopathy, thyroid normal
Lungs: Clear to auscultation bilaterally
Heart: Regular rate and rhythm, no murmurs
Abdomen: Soft, non-tender, no masses
Extremities: No edema, pulses intact
Skin: No suspicious lesions
Neuro: Alert, oriented, cranial nerves intact

▸ ASSESSMENT:
Annual wellness examination - {{age}} year old {{gender}}
{{conditions}}

▸ PLAN:
• Health maintenance counseling provided
• Age-appropriate cancer screenings discussed
• Immunizations: [Updated/Due]
• Labs ordered: CBC, CMP, Lipid panel, A1C
• Follow up in 1 year or as needed"""
        ),
        "back_pain" to NoteTemplate(
            name = "Low Back Pain",
            category = "Urgent Care",
            noteType = "SOAP",
            content = """▸ S:
{{patient_name}} presents with low back pain.
Onset: [Acute/Gradual]
Duration: [X] days/weeks
Location: [Lumbar/Sacral], [Unilateral/Bilateral]
Radiation: [None/To legs]
Severity: [X]/10
Aggravating factors: [Bending/Lifting/Sitting]
Relieving factors: [Rest/Ice/Heat/Medication]
Red flags: Denies bowel/bladder dysfunction, saddle anesthesia, fever
No trauma reported. Allergies: {{allergies}}

▸ O:
Vitals: {{vitals}}
General: Mild distress due to pain
Back: Tenderness at [location], no spinal step-off
ROM: Limited [flexion/extension] due to pain
Neuro: Strength 5/5 bilateral lower extremities
Sensation intact, DTRs 2+ symmetric
Straight leg raise: [Negative/Positive]
Gait: [Antalgic/Normal]

▸ A:
Acute Low Back Pain - Musculoskeletal/Mechanical
No red flag symptoms

▸ P:
• NSAIDs: Ibuprofen 600mg TID with food x 7 days
• Muscle relaxant: [If appropriate]
• Ice/heat as needed
• Gentle stretching, avoid heavy lifting
• Activity as tolerated, avoid bed rest
• Return if: weakness, numbness, bowel/bladder changes
• Follow up in 1-2 weeks if not improving"""
        ),
        "uti" to NoteTemplate(
            name = "Urinary Tract Infection",
            category = "Urgent Care",
            noteType = "SOAP",
            content = """▸ S:
{{patient_name}} presents with urinary symptoms.
Duration: [X] days
Symptoms: Dysuria, frequency, urgency
[Hematuria: Yes/No]
Denies fever, flank pain, nausea/vomiting.
No vaginal discharge. LMP: [Date]
Allergies: {{allergies}}

▸ O:
Vitals: {{vitals}}
General: No acute distress
Abdomen: Soft, mild suprapubic tenderness, no CVA tenderness
UA: [Results - typically positive LE, nitrites]

▸ A:
Acute Uncomplicated Urinary Tract Infection (Cystitis)

▸ P:
• Nitrofurantoin 100mg BID x 5 days
  OR Trimethoprim-sulfamethoxazole DS BID x 3 days
• Increase fluid intake
• Urinate frequently, especially after intercourse
• Return if: fever, flank pain, symptoms not improving in 48h
• Follow up if recurrent UTIs"""
        ),
        "well_child" to NoteTemplate(
            name = "Well Child Visit",
            category = "Pediatrics",
            noteType = "HP",
            content = """▸ CHIEF COMPLAINT:
Well child visit - [Age] month/year check

▸ HPI:
{{patient_name}}, {{age}}, presents for routine well child examination.
Parent reports child is doing well.
Feeding: [Breast/Formula/Table foods]
Sleep: [Hours, pattern]
Development: Meeting milestones appropriately

▸ BIRTH HISTORY:
[Term/Preterm], [Vaginal/C-section]
Birth weight: [X] lbs
No NICU stay

▸ MEDICATIONS:
{{medications}}

▸ ALLERGIES:
{{allergies}}

▸ DEVELOPMENT:
Gross Motor: [Age appropriate]
Fine Motor: [Age appropriate]
Language: [Age appropriate]
Social: [Age appropriate]

▸ PHYSICAL EXAM:
Vitals: {{vitals}}
Growth: Weight [X]%, Height [X]%, HC [X]%
General: Alert, active, well-appearing
HEENT: Normocephalic, fontanelle [if applicable], TMs clear, red reflex present
Neck: Supple
Heart: Regular rhythm, no murmurs
Lungs: Clear
Abdomen: Soft, no hepatosplenomegaly
GU: [Normal male/female]
Hips: Stable, no click
Skin: No rashes
Neuro: Age-appropriate tone and reflexes

▸ ASSESSMENT:
Well child - {{age}} - healthy, developing appropriately

▸ PLAN:
• Immunizations: [Given today]
• Anticipatory guidance provided
• Safety counseling: [Age appropriate]
• Nutrition counseling provided
• Next visit: [Age] check"""
        ),
        "chest_pain" to NoteTemplate(
            name = "Chest Pain Evaluation",
            category = "Urgent Care",
            noteType = "SOAP",
            content = """▸ S:
{{patient_name}} presents with chest pain.
Onset: [Sudden/Gradual]
Duration: [Minutes/Hours/Days]
Location: [Substernal/Left/Right chest]
Quality: [Sharp/Pressure/Burning]
Radiation: [None/Arm/Jaw/Back]
Severity: [X]/10
Associated symptoms: [SOB/Diaphoresis/Nausea/Palpitations]
Aggravating factors: [Exertion/Breathing/Position/Food]
Relieving factors: [Rest/Antacids/Position change]
Risk factors: [HTN/DM/Smoking/Family hx CAD/Hyperlipidemia]
Medications: {{medications}}
Allergies: {{allergies}}

▸ O:
Vitals: {{vitals}}
General: [Distress level]
CV: Regular rate and rhythm, no murmurs, no JVD
Lungs: Clear bilaterally, no wheezes
Chest wall: [Reproducible tenderness: Yes/No]
Extremities: No edema, pulses equal
EKG: [Normal sinus rhythm/Findings]

▸ A:
Chest Pain - [Etiology]
Differential: [Musculoskeletal/GERD/Anxiety/ACS ruled out]

▸ P:
• [Based on presentation]
• Return immediately if: worsening pain, shortness of breath, diaphoresis
• Follow up with PCP in [X] days
• Consider cardiology referral if indicated"""
        ),
        // ═══════════════════════════════════════════════════════════════════════════
        // SPECIALTY-SPECIFIC TEMPLATES
        // ═══════════════════════════════════════════════════════════════════════════

        // CARDIOLOGY
        "cardiology_chest_pain" to NoteTemplate(
            name = "Cardiology - Chest Pain Evaluation",
            category = "Cardiology",
            noteType = "HP",
            content = """▸ CHIEF COMPLAINT:
Chest pain evaluation

▸ HPI:
{{patient_name}} presents with chest pain.
Location: substernal / left-sided / right-sided
Quality: sharp / dull / pressure / burning
Radiation: jaw / left arm / back / none
Duration: [X] hours/days
Provoking factors: exertion / rest / eating / breathing
Relieving factors: rest / nitroglycerin / antacids
Associated symptoms: dyspnea, diaphoresis, nausea, palpitations
Risk factors: HTN, DM, hyperlipidemia, smoking, family history

▸ PAST MEDICAL HISTORY:
{{conditions}}

▸ MEDICATIONS:
{{medications}}

▸ ALLERGIES:
{{allergies}}

▸ PHYSICAL EXAM:
Vitals: {{vitals}}
General: Alert, no acute distress / mild distress
CV: Regular rate and rhythm, no murmurs, gallops, or rubs
Lungs: Clear bilaterally, no wheezes or crackles
Chest wall: Non-tender to palpation
Extremities: No edema, pulses 2+ bilaterally

▸ DIAGNOSTICS:
ECG: [pending/results]
Troponin: [pending/results]
CXR: [pending/results]

▸ ASSESSMENT:
Chest pain - differential includes ACS, stable angina, GERD, MSK

▸ PLAN:
• Serial troponins q3-6h
• Continuous telemetry monitoring
• ASA 325mg if not contraindicated
• Risk stratification with HEART score
• Cardiology consultation if indicated"""
        ),
        "cardiology_heart_failure" to NoteTemplate(
            name = "Cardiology - Heart Failure",
            category = "Cardiology",
            noteType = "SOAP",
            content = """▸ S:
{{patient_name}} presents with heart failure symptoms.
Dyspnea: at rest / with exertion / PND / orthopnea
Edema: lower extremity / abdominal / none
Weight change: gained [X] lbs over [X] days
Diet compliance: low sodium adherence
Medication compliance: taking all medications as prescribed
Current medications: {{medications}}

▸ O:
Vitals: {{vitals}}
General: Mild respiratory distress / no acute distress
Neck: JVD present / absent
CV: Irregularly irregular / regular, S3 present / absent
Lungs: Crackles bases / clear
Abdomen: Hepatomegaly present / absent
Extremities: 2+ pitting edema / trace / none
Daily weight: [X] kg

▸ A:
Heart Failure - NYHA Class [I-IV]
Acute exacerbation / compensated
EF: [X]% (HFrEF / HFpEF)
{{conditions}}

▸ P:
• IV diuretics: Lasix [X]mg IV
• Daily weights and strict I/Os
• Fluid restriction 1.5-2L/day
• Low sodium diet <2g/day
• Optimize GDMT: BB, ACEi/ARB/ARNI, MRA, SGLT2i
• BNP/proBNP trending
• Consider inotropes if decompensated
• Echo if not recent"""
        ),
        "cardiology_afib" to NoteTemplate(
            name = "Cardiology - Atrial Fibrillation",
            category = "Cardiology",
            noteType = "SOAP",
            content = """▸ S:
{{patient_name}} presents with atrial fibrillation.
Symptoms: palpitations / chest discomfort / dyspnea / fatigue / asymptomatic
Duration: paroxysmal / persistent / permanent
Onset: [date/time]
Triggers identified: alcohol, caffeine, stress, illness
Current medications: {{medications}}

▸ O:
Vitals: {{vitals}}
General: No acute distress
CV: Irregularly irregular rhythm, rate [X], no murmurs
Lungs: Clear bilaterally
Extremities: No edema

▸ A:
Atrial Fibrillation - paroxysmal / persistent / permanent
Rate: controlled / uncontrolled
CHADS2-VASc Score: [X]
HAS-BLED Score: [X]
{{conditions}}

▸ P:
Rate control:
• Beta-blocker: Metoprolol [X]mg
• Or Diltiazem [X]mg
Target HR <110 at rest

Anticoagulation (CHADS2-VASc ≥2):
• Apixaban 5mg BID / Rivaroxaban 20mg daily / Warfarin
• Bleeding risk counseling provided

Rhythm control (if indicated):
• Consider cardioversion if <48h or anticoagulated ≥3 weeks
• Antiarrhythmic consideration
• Cardiology/EP referral"""
        ),

        // ORTHOPEDICS
        "ortho_joint_pain" to NoteTemplate(
            name = "Orthopedics - Joint Pain",
            category = "Orthopedics",
            noteType = "SOAP",
            content = """▸ S:
{{patient_name}} presents with joint pain.
Location: [specific joint]
Laterality: right / left / bilateral
Onset: acute / chronic / gradual
Duration: [X] days/weeks/months
Mechanism: injury / overuse / spontaneous
Quality: sharp / dull / aching / throbbing
Severity: [X]/10
Aggravating factors: movement / weight-bearing / rest
Alleviating factors: rest / ice / heat / medications
Associated: swelling, stiffness, locking, instability, weakness
Prior episodes: yes / no
Current medications: {{medications}}

▸ O:
Vitals: {{vitals}}
Inspection: Swelling / erythema / deformity / atrophy
Palpation: Point tenderness at [location]
ROM: Active [X]° / Passive [X]° (normal [X]°)
Strength: [X]/5
Special tests: [test name] positive / negative
Neurovascular: Intact distally

▸ A:
[Diagnosis] - right/left [joint]
Differential: OA, RA, gout, septic arthritis, bursitis, tendinitis
{{conditions}}

▸ P:
• RICE: Rest, Ice, Compression, Elevation
• NSAIDs: Ibuprofen 600mg TID with food
• Activity modification
• Physical therapy referral
• X-ray [joint] if not done
• Consider MRI if no improvement
• Follow up in [X] weeks"""
        ),
        "ortho_fracture" to NoteTemplate(
            name = "Orthopedics - Fracture Follow-up",
            category = "Orthopedics",
            noteType = "SOAP",
            content = """▸ S:
{{patient_name}} presents for fracture follow-up.
Fracture: [bone] fracture, [date of injury]
Treatment: cast / splint / ORIF / conservative
Pain level: [X]/10 (improving / stable / worsening)
Swelling: improved / stable / worse
Neurovascular symptoms: numbness / tingling / none
Weight-bearing status: non-weight bearing / TTWB / WBAT / FWB
Compliance with restrictions: yes / no

▸ O:
Vitals: {{vitals}}
Cast/Splint: Intact, no odor, no drainage
Skin: Intact at edges, no pressure sores
Distal circulation: Cap refill <2 sec, pulses palpable
Sensation: Intact to light touch
Motor: [X]/5 strength distal to injury

X-ray findings: [describe alignment, callus formation, hardware position]

▸ A:
[Bone] fracture - [weeks] post injury/surgery
Healing: progressing well / delayed union / non-union concern
{{conditions}}

▸ P:
• Continue immobilization for [X] more weeks
• Weight-bearing status: [status]
• Pain management: [medication]
• Repeat X-ray in [X] weeks
• Physical therapy when cleared
• Return precautions given
• Follow up in [X] weeks"""
        ),

        // NEUROLOGY
        "neuro_headache" to NoteTemplate(
            name = "Neurology - Headache Evaluation",
            category = "Neurology",
            noteType = "HP",
            content = """▸ CHIEF COMPLAINT:
Headache evaluation

▸ HPI:
{{patient_name}} presents with headache.
Location: frontal / temporal / occipital / unilateral / bilateral
Quality: throbbing / pressure / sharp / dull
Severity: [X]/10
Duration: [X] hours/days
Frequency: [X] episodes per week/month
Aura: visual / sensory / motor / none
Associated: nausea, vomiting, photophobia, phonophobia
Red flags: worst headache, thunderclap, fever, neuro deficits, papilledema
Triggers: stress, sleep, foods, menses
Family history of migraines: yes / no

▸ PAST MEDICAL HISTORY:
{{conditions}}

▸ MEDICATIONS:
{{medications}}
Previous headache treatments tried: [list]

▸ ALLERGIES:
{{allergies}}

▸ PHYSICAL EXAM:
Vitals: {{vitals}}
General: Comfortable / photophobic / distressed
HEENT: No temporal artery tenderness, sinuses non-tender
Neck: Supple, no meningismus
Neuro: CN II-XII intact, strength 5/5, sensation intact, reflexes 2+, coordination normal
Fundoscopic: No papilledema

▸ ASSESSMENT:
Headache - Primary: Migraine / Tension / Cluster
Secondary causes ruled out

▸ PLAN:
Acute treatment:
• NSAIDs / Triptans / Antiemetics

Preventive (if frequent):
• Beta-blocker / Topiramate / Amitriptyline / CGRP inhibitor

Lifestyle:
• Headache diary
• Sleep hygiene
• Trigger avoidance
• Hydration
• Follow up in 4-6 weeks"""
        ),
        "neuro_stroke" to NoteTemplate(
            name = "Neurology - Stroke Follow-up",
            category = "Neurology",
            noteType = "SOAP",
            content = """▸ S:
{{patient_name}} presents for stroke follow-up.
Stroke date: [date]
Type: ischemic / hemorrhagic
Territory: MCA / PCA / ACA / vertebrobasilar
Treatment received: tPA / thrombectomy / conservative
Residual deficits: weakness / numbness / speech / vision / none
Rehabilitation: PT / OT / Speech therapy
Medication compliance: yes / no
Current medications: {{medications}}

▸ O:
Vitals: {{vitals}}
General: Alert and oriented x3
Speech: Fluent / non-fluent / dysarthric
Cranial Nerves: [document any deficits]
Motor: RUE [X]/5, RLE [X]/5, LUE [X]/5, LLE [X]/5
Sensation: Intact / diminished [location]
Coordination: Finger-to-nose, heel-to-shin
Gait: Normal / wide-based / hemiparetic
NIHSS Score: [X]

▸ A:
Status post [ischemic/hemorrhagic] stroke - [territory]
[X] weeks/months post event
Functional status: improving / stable / declining
{{conditions}}

▸ P:
Secondary Prevention:
• Antiplatelet: ASA 81mg / Plavix 75mg / Aggrenox
• Statin: High-intensity (Atorvastatin 80mg)
• BP goal <130/80
• Diabetes control if applicable
• Smoking cessation

Ongoing:
• Continue rehabilitation
• Driving restrictions discussed
• Depression screening
• Follow up MRI/MRA if indicated
• Neurology follow-up in [X] months"""
        ),

        // GASTROENTEROLOGY
        "gi_abdominal_pain" to NoteTemplate(
            name = "GI - Abdominal Pain",
            category = "Gastroenterology",
            noteType = "HP",
            content = """▸ CHIEF COMPLAINT:
Abdominal pain evaluation

▸ HPI:
{{patient_name}} presents with abdominal pain.
Location: RUQ / LUQ / RLQ / LLQ / epigastric / periumbilical / diffuse
Quality: sharp / crampy / burning / colicky
Severity: [X]/10
Onset: sudden / gradual
Duration: [X] hours/days
Radiation: back / shoulder / groin
Timing: constant / intermittent / postprandial
Associated: nausea, vomiting, diarrhea, constipation, fever, blood
Last bowel movement: [date], quality
Last meal: [time]
Menstrual history (if applicable): LMP [date]

▸ PAST MEDICAL HISTORY:
{{conditions}}
Prior abdominal surgeries: [list]

▸ MEDICATIONS:
{{medications}}

▸ ALLERGIES:
{{allergies}}

▸ PHYSICAL EXAM:
Vitals: {{vitals}}
General: Comfortable / distressed, lying still / moving
Abdomen:
  Inspection: Flat / distended, no surgical scars / scars present
  Auscultation: Bowel sounds present / hyperactive / absent
  Palpation: Soft / rigid, tender [location], no rebound / guarding
  Special signs: Murphy's / McBurney's / Rovsing's / psoas negative

▸ DIAGNOSTICS:
Labs: CBC, CMP, lipase, UA, urine pregnancy
Imaging: CT abdomen/pelvis / ultrasound / X-ray

▸ ASSESSMENT:
Abdominal pain - differential includes [list based on location]

▸ PLAN:
• NPO status
• IV fluids
• Pain management
• Labs and imaging as above
• Surgical consultation if indicated
• GI consultation if indicated"""
        ),
        "gi_gerd" to NoteTemplate(
            name = "GI - GERD Follow-up",
            category = "Gastroenterology",
            noteType = "SOAP",
            content = """▸ S:
{{patient_name}} presents for GERD follow-up.
Symptoms: heartburn / regurgitation / dysphagia / chest pain
Frequency: daily / weekly / monthly
Timing: postprandial / nocturnal / with bending
Triggers: spicy foods, citrus, caffeine, alcohol, large meals
Alarm symptoms: weight loss / dysphagia / bleeding / anemia - NONE
PPI compliance: taking as prescribed
Current medications: {{medications}}

▸ O:
Vitals: {{vitals}}
General: No acute distress
Abdomen: Soft, non-tender, no organomegaly
Oropharynx: No erythema or lesions

▸ A:
GERD - controlled / uncontrolled
No alarm symptoms
{{conditions}}

▸ P:
Medications:
• Continue PPI: [medication] [dose] daily/BID
• Step down to H2 blocker if controlled >8 weeks
• PRN antacids

Lifestyle modifications:
• Avoid trigger foods
• Small frequent meals
• No eating 3 hours before bed
• Elevate head of bed
• Weight loss if overweight
• Smoking cessation

If refractory:
• EGD referral
• pH monitoring
• Consider GI referral
• Follow up in [X] months"""
        ),

        // PULMONOLOGY
        "pulm_copd" to NoteTemplate(
            name = "Pulmonology - COPD",
            category = "Pulmonology",
            noteType = "SOAP",
            content = """▸ S:
{{patient_name}} presents for COPD management.
Baseline dyspnea: at rest / with activity / with exertion
Current symptoms: stable / worsening
Exacerbations in past year: [X]
Hospitalizations in past year: [X]
Oxygen use: none / PRN / continuous at [X] L/min
Smoking status: current / former / never, [X] pack-years
Inhaler technique reviewed: yes
Medication compliance: yes / no
Current medications: {{medications}}

▸ O:
Vitals: {{vitals}}
SpO2: [X]% on room air / [X]L O2
General: No acute distress / using accessory muscles
Chest: Barrel chest / normal
Lungs: Decreased breath sounds / wheezes / prolonged expiration
Extremities: No clubbing or cyanosis

▸ A:
COPD - GOLD Stage [I-IV], Group [A-D]
FEV1: [X]% predicted
Currently: stable / acute exacerbation
{{conditions}}

▸ P:
Maintenance therapy (stepwise):
• LAMA: Tiotropium / Umeclidinium
• LABA: Salmeterol / Formoterol
• ICS (if frequent exacerbations): Fluticasone / Budesonide
• Triple therapy if severe

Rescue: Albuterol PRN

Preventive:
• Annual flu vaccine
• Pneumococcal vaccines (PCV20, PPSV23)
• Smoking cessation counseling
• Pulmonary rehabilitation referral

Monitoring:
• PFTs annually
• Assess CAT score / mMRC dyspnea
• Follow up in [X] months"""
        ),
        "pulm_asthma" to NoteTemplate(
            name = "Pulmonology - Asthma",
            category = "Pulmonology",
            noteType = "SOAP",
            content = """▸ S:
{{patient_name}} presents for asthma management.
Daytime symptoms: [X] times per week
Nighttime symptoms: [X] times per month
Rescue inhaler use: [X] times per week
Activity limitation: yes / no
Exacerbations: [X] in past year requiring steroids / ED / hospitalization
Triggers: allergens, exercise, cold air, illness, stress
Peak flow: [X] L/min (personal best [X])
Current medications: {{medications}}

▸ O:
Vitals: {{vitals}}
SpO2: [X]% on room air
General: No acute distress / mild distress / severe distress
Lungs: Clear / wheezes / prolonged expiration
Peak flow: [X] L/min ([X]% of personal best)

▸ A:
Asthma - intermittent / mild persistent / moderate persistent / severe persistent
Currently: well-controlled / not well-controlled / very poorly controlled
{{conditions}}

▸ P:
Step therapy (based on control):
Step 1: PRN SABA (albuterol)
Step 2: Add low-dose ICS
Step 3: Low-dose ICS + LABA or medium-dose ICS
Step 4: Medium-dose ICS + LABA
Step 5: High-dose ICS + LABA, consider biologics

Current regimen:
• Controller: [medication]
• Rescue: Albuterol 2 puffs PRN

Action plan:
• Green zone: Continue maintenance
• Yellow zone: Increase controller, add rescue
• Red zone: Oral steroids, seek care

• Trigger avoidance education
• Spacer technique reviewed
• Peak flow monitoring
• Follow up in [X] months"""
        ),

        // PSYCHIATRY
        "psych_depression" to NoteTemplate(
            name = "Psychiatry - Depression",
            category = "Psychiatry",
            noteType = "SOAP",
            content = """▸ S:
{{patient_name}} presents for depression management.
PHQ-9 Score: [X]/27
Mood: depressed / sad / hopeless / irritable
Duration: [X] weeks/months
Sleep: insomnia / hypersomnia / [X] hours per night
Appetite: decreased / increased / stable
Energy: low / fatigue
Concentration: impaired / intact
Interest/pleasure: anhedonia present / absent
Psychomotor: agitation / retardation / normal
Guilt: excessive / appropriate
Suicidal ideation: DENIES / passive ("better off dead") / active with plan
Safety: No access to firearms / medications secured
Substance use: alcohol [X]/week, drugs none
Current medications: {{medications}}

▸ O:
Vitals: {{vitals}}
Appearance: Groomed / disheveled
Behavior: Cooperative / guarded / agitated
Speech: Normal rate/tone / slow / pressured
Mood: "depressed" / "[patient's words]"
Affect: Constricted / flat / congruent / tearful
Thought process: Linear / circumstantial
Thought content: No SI/HI, no delusions
Cognition: Alert and oriented x3
Insight/Judgment: Fair / poor / good

▸ A:
Major Depressive Disorder - mild / moderate / severe
Episode: single / recurrent
PHQ-9: [X] (minimal/mild/moderate/moderately severe/severe)
{{conditions}}

▸ P:
Pharmacotherapy:
• SSRI: [medication] [dose] (continue / start / adjust)
• Consider augmentation if partial response

Psychotherapy:
• CBT / IPT referral
• Continue current therapy

Safety:
• Crisis resources provided (988 Suicide & Crisis Lifeline)
• Safety plan reviewed
• Emergency plan if worsening

Lifestyle:
• Sleep hygiene
• Exercise recommendation
• Social support engagement
• Follow up in [X] weeks"""
        ),
        "psych_anxiety" to NoteTemplate(
            name = "Psychiatry - Anxiety",
            category = "Psychiatry",
            noteType = "SOAP",
            content = """▸ S:
{{patient_name}} presents for anxiety management.
GAD-7 Score: [X]/21
Primary symptoms: worry / panic / social anxiety / specific phobia
Duration: [X] weeks/months
Panic attacks: frequency [X]/week, duration [X] minutes
Physical symptoms: palpitations, sweating, tremor, GI upset, dyspnea
Avoidance behaviors: [describe]
Functional impairment: work / social / daily activities
Sleep: difficulty initiating / maintaining / [X] hours
Substances: caffeine / alcohol / none
Current medications: {{medications}}

▸ O:
Vitals: {{vitals}}
Appearance: Anxious / restless / fidgeting / calm
Behavior: Cooperative / hypervigilant
Speech: Rapid / normal / pressured
Mood: "anxious" / "nervous"
Affect: Anxious / constricted
Thought process: Linear / racing
Thought content: Worried about [topics], no SI/HI
Cognition: Intact, distractible
Insight/Judgment: Fair

▸ A:
Generalized Anxiety Disorder / Panic Disorder / Social Anxiety
GAD-7: [X] (minimal/mild/moderate/severe)
{{conditions}}

▸ P:
Pharmacotherapy:
• First-line: SSRI/SNRI - [medication] [dose]
• PRN rescue: Hydroxyzine 25mg for acute anxiety
• Avoid benzodiazepines if possible (short-term only if needed)

Psychotherapy:
• CBT referral (gold standard)
• Exposure therapy if specific phobia

Lifestyle:
• Limit caffeine
• Regular exercise
• Sleep hygiene
• Relaxation techniques (deep breathing, mindfulness)

• Follow up in [X] weeks"""
        ),

        // EMERGENCY
        "ed_trauma" to NoteTemplate(
            name = "Emergency - Trauma",
            category = "Emergency",
            noteType = "HP",
            content = """▸ CHIEF COMPLAINT:
Trauma evaluation - [mechanism]

▸ HPI:
{{patient_name}} presents following [mechanism of injury].
Time of injury: [time]
Mechanism: MVC / fall / assault / penetrating / blunt
Loss of consciousness: yes / no, duration [X]
Neck pain: yes / no
Back pain: yes / no
Extremity complaints: [list]
Ambulatory at scene: yes / no
GCS at scene: [X]/15

▸ ALLERGIES:
{{allergies}}

▸ MEDICATIONS:
{{medications}}
Anticoagulants: yes / no

▸ PRIMARY SURVEY:
A - Airway: Patent / compromised, C-spine immobilized
B - Breathing: Bilateral breath sounds, no crepitus, SpO2 [X]%
C - Circulation: HR [X], BP [X], pulses present, no active hemorrhage
D - Disability: GCS [X] (E[X]V[X]M[X]), pupils equal/reactive
E - Exposure: Temp [X], logrolled, no deformities

▸ SECONDARY SURVEY:
Head: No lacerations, no hematoma, no step-off
Face: No deformity, no malocclusion
Neck: Midline, no TTP, C-collar in place
Chest: No crepitus, no flail, breath sounds equal
Abdomen: Soft, non-tender / tender [location], no distension
Pelvis: Stable, no tenderness
Spine: No step-off, no midline TTP
Extremities: No deformity, pulses intact, sensation intact
Neuro: Moving all extremities, no focal deficits

▸ DIAGNOSTICS:
Labs: Type and screen, CBC, CMP, coags, lactate, UA
Imaging: CXR, pelvis XR, FAST exam, CT [areas]

▸ ASSESSMENT:
Trauma - [blunt/penetrating] to [areas]
Injuries identified: [list]

▸ PLAN:
• Trauma team activation if indicated
• Resuscitation: [IV fluids, blood products if needed]
• Pain management
• Tetanus prophylaxis if indicated
• Trauma surgery consultation
• Admit / observe / discharge with precautions"""
        ),
        "ed_sepsis" to NoteTemplate(
            name = "Emergency - Sepsis",
            category = "Emergency",
            noteType = "HP",
            content = """▸ CHIEF COMPLAINT:
Sepsis evaluation / Suspected infection

▸ HPI:
{{patient_name}} presents with suspected sepsis.
Source suspected: pulmonary / urinary / abdominal / skin/soft tissue / unknown
Symptoms: fever / chills / altered mental status / weakness
Duration: [X] hours/days
Associated: cough / dysuria / abdominal pain / wound
Immune status: normal / immunocompromised
Recent antibiotics: yes / no
Recent hospitalization: yes / no

▸ PAST MEDICAL HISTORY:
{{conditions}}

▸ MEDICATIONS:
{{medications}}

▸ ALLERGIES:
{{allergies}}

▸ PHYSICAL EXAM:
Vitals: {{vitals}}
SIRS Criteria: Temp >38 or <36, HR >90, RR >20, WBC >12k or <4k
qSOFA: AMS, SBP ≤100, RR ≥22

General: Ill-appearing / toxic / diaphoretic
Mental status: Alert / confused / obtunded
Skin: Warm / cool, mottled / petechiae / rash
Lungs: Clear / crackles / rhonchi
CV: Tachycardic, hypotensive / normotensive
Abdomen: Soft / tender / peritoneal signs
GU: CVA tenderness / suprapubic tenderness

▸ DIAGNOSTICS:
Labs: CBC, CMP, lactate, procalcitonin, coags, blood cultures x2
UA and urine culture
CXR
Consider: CT chest/abdomen/pelvis, LP

▸ SEPSIS BUNDLE - HOUR 1:
[ ] Lactate measured: [X] mmol/L
[ ] Blood cultures before antibiotics
[ ] Broad-spectrum antibiotics given: [medication]
[ ] Crystalloid 30 mL/kg for hypotension/lactate ≥4
[ ] Vasopressors if hypotensive after fluids (MAP ≥65)

▸ ASSESSMENT:
Sepsis / Severe sepsis / Septic shock
Source: [suspected source]
SOFA Score: [X]

▸ PLAN:
• Continue aggressive resuscitation
• Source control if identified
• ICU admission for shock
• Re-measure lactate if initial >2
• Central line / arterial line if vasopressors
• Reassess volume status frequently"""
        )
    )

    // Data class for note templates
    data class NoteTemplate(
        val name: String,
        val category: String,
        val noteType: String,  // SOAP, HP, PROGRESS, CONSULT
        val content: String
    )

    // ═══════════════════════════════════════════════════════════════════════════
    // VOICE ORDERS - Data Classes
    // ═══════════════════════════════════════════════════════════════════════════

    // Order type enum
    enum class OrderType {
        LAB, IMAGING, MEDICATION
    }

    // Order status enum
    enum class OrderStatus {
        PENDING, CONFIRMED, CANCELLED
    }

    // Safety warning types
    enum class SafetyWarningType {
        ALLERGY, DRUG_INTERACTION, DUPLICATE_ORDER, CONTRAINDICATION
    }

    // Safety warning data class
    data class SafetyWarning(
        val type: SafetyWarningType,
        val severity: String,  // "high", "moderate", "low"
        val message: String,
        val details: String = ""
    )

    // Order data class
    data class Order(
        val id: String = java.util.UUID.randomUUID().toString(),
        val type: OrderType,
        val name: String,                    // "CBC", "Amoxicillin"
        val displayName: String,             // "Complete Blood Count"
        val details: String = "",            // "500mg TID x 10 days"
        val status: OrderStatus = OrderStatus.PENDING,
        val timestamp: Long = System.currentTimeMillis(),
        val safetyWarnings: List<SafetyWarning> = emptyList(),
        val requiresConfirmation: Boolean = false,
        // Medication-specific fields
        val dose: String? = null,
        val frequency: String? = null,
        val duration: String? = null,
        val route: String? = null,
        val prn: Boolean = false,
        // Imaging-specific fields
        val contrast: Boolean? = null,
        val bodyPart: String? = null,
        val laterality: String? = null
    ) {
        fun toJson(): org.json.JSONObject {
            return org.json.JSONObject().apply {
                put("id", id)
                put("type", type.name)
                put("name", name)
                put("displayName", displayName)
                put("details", details)
                put("status", status.name)
                put("timestamp", timestamp)
                put("dose", dose)
                put("frequency", frequency)
                put("duration", duration)
                put("route", route)
                put("prn", prn)
                put("contrast", contrast)
                put("bodyPart", bodyPart)
                put("laterality", laterality)
                put("safetyWarnings", org.json.JSONArray().apply {
                    safetyWarnings.forEach { warning ->
                        put(org.json.JSONObject().apply {
                            put("type", warning.type.name)
                            put("severity", warning.severity)
                            put("message", warning.message)
                            put("details", warning.details)
                        })
                    }
                })
            }
        }

        companion object {
            fun fromJson(json: org.json.JSONObject): Order {
                val warnings = mutableListOf<SafetyWarning>()
                val warningsArray = json.optJSONArray("safetyWarnings")
                if (warningsArray != null) {
                    for (i in 0 until warningsArray.length()) {
                        val w = warningsArray.getJSONObject(i)
                        warnings.add(SafetyWarning(
                            type = SafetyWarningType.valueOf(w.getString("type")),
                            severity = w.getString("severity"),
                            message = w.getString("message"),
                            details = w.optString("details", "")
                        ))
                    }
                }
                return Order(
                    id = json.getString("id"),
                    type = OrderType.valueOf(json.getString("type")),
                    name = json.getString("name"),
                    displayName = json.getString("displayName"),
                    details = json.optString("details", ""),
                    status = OrderStatus.valueOf(json.getString("status")),
                    timestamp = json.getLong("timestamp"),
                    safetyWarnings = warnings,
                    dose = json.optString("dose", null),
                    frequency = json.optString("frequency", null),
                    duration = json.optString("duration", null),
                    route = json.optString("route", null),
                    prn = json.optBoolean("prn", false),
                    contrast = if (json.has("contrast") && !json.isNull("contrast")) json.getBoolean("contrast") else null,
                    bodyPart = json.optString("bodyPart", null),
                    laterality = json.optString("laterality", null)
                )
            }
        }
    }

    // Lab order info
    data class LabOrderInfo(
        val name: String,
        val displayName: String,
        val cptCode: String,
        val aliases: List<String>
    )

    // Imaging order info
    data class ImagingOrderInfo(
        val name: String,
        val displayName: String,
        val cptCode: String,
        val bodyPart: String,
        val modality: String,
        val aliases: List<String>,
        val supportsContrast: Boolean = false
    )

    // Medication order info
    data class MedicationOrderInfo(
        val name: String,
        val drugClass: String,
        val commonDoses: List<String>,
        val commonFrequencies: List<String>,
        val commonDurations: List<String>,
        val route: String,
        val aliases: List<String>,
        val interactionsWith: List<String>,
        val allergyCrossReact: List<String>,
        val isControlled: Boolean = false
    )

    // ═══════════════════════════════════════════════════════════════════════════
    // DIFFERENTIAL DIAGNOSIS - Data Classes
    // ═══════════════════════════════════════════════════════════════════════════

    data class DifferentialDiagnosis(
        val rank: Int,
        val diagnosis: String,
        val icd10Code: String,
        val likelihood: String,  // "high", "moderate", "low"
        val supportingFindings: List<String>,
        val redFlags: List<String>,
        val nextSteps: List<String>
    )

    data class DdxResponse(
        val differentials: List<DifferentialDiagnosis>,
        val clinicalReasoning: String,
        val urgentConsiderations: List<String>,
        val timestamp: String
    )

    // Store last DDx response for TTS readback
    private var lastDdxResponse: DdxResponse? = null

    // Image Analysis data classes (Feature #70)
    data class ImageFinding(
        val finding: String,
        val confidence: String,  // "high", "moderate", "low"
        val location: String?,
        val characteristics: List<String>
    )

    data class ImageAnalysisResponse(
        val assessment: String,
        val findings: List<ImageFinding>,
        val icd10Codes: List<Map<String, String>>,
        val recommendations: List<String>,
        val redFlags: List<String>,
        val differentialConsiderations: List<String>,
        val disclaimer: String,
        val timestamp: String
    )

    // Store last image analysis for TTS readback
    private var lastImageAnalysis: ImageAnalysisResponse? = null
    private var pendingImageContext: String? = null

    // Image capture launcher (Feature #70)
    private val imageCaptureUrl = registerForActivityResult(
        ActivityResultContracts.StartActivityForResult()
    ) { result ->
        if (result.resultCode == RESULT_OK) {
            val imageBase64 = result.data?.getStringExtra(ImageCaptureActivity.EXTRA_IMAGE_BASE64)
            val mediaType = result.data?.getStringExtra(ImageCaptureActivity.EXTRA_MEDIA_TYPE) ?: "image/jpeg"
            val context = result.data?.getStringExtra(ImageCaptureActivity.EXTRA_ANALYSIS_CONTEXT)

            if (imageBase64 != null) {
                Log.d(TAG, "Image captured, base64 length: ${imageBase64.length}, context: $context")
                transcriptText.text = "Image captured. Analyzing..."
                speakFeedback("Analyzing image")
                analyzeMedicalImage(imageBase64, mediaType, context)
            }
        } else {
            speakFeedback("Image capture cancelled")
        }
    }

    // Billing/Claim data classes (Feature #71)
    enum class ClaimStatus { DRAFT, SUBMITTED, ACCEPTED, REJECTED }

    data class BillingDiagnosisCode(
        val code: String,
        val description: String,
        val sequence: Int = 1,
        val isPrincipal: Boolean = false
    )

    data class BillingProcedureCode(
        val code: String,
        val description: String,
        val modifiers: List<String> = emptyList(),
        val units: Int = 1
    )

    data class BillingServiceLine(
        val lineNumber: Int,
        val serviceDate: String,
        val procedure: BillingProcedureCode,
        val diagnosisPointers: List<Int> = listOf(1)
    )

    data class BillingClaim(
        val claimId: String?,
        val status: ClaimStatus,
        val patientId: String,
        val patientName: String?,
        val noteId: String?,
        val serviceDate: String,
        val diagnoses: List<BillingDiagnosisCode>,
        val serviceLines: List<BillingServiceLine>,
        val totalCharge: Float = 0f,
        val createdAt: String?,
        val submittedAt: String?,
        val fhirClaimId: String?
    )

    // Billing state
    private var currentClaim: BillingClaim? = null
    private var billingOverlay: android.widget.FrameLayout? = null
    private var isAwaitingClaimConfirmation = false

    // DNFB (Discharged Not Final Billed) Models (Feature #72)
    enum class DNFBReason {
        CODING_INCOMPLETE,
        DOCUMENTATION_MISSING,
        CHARGES_PENDING,
        PRIOR_AUTH_MISSING,
        PRIOR_AUTH_EXPIRED,
        PRIOR_AUTH_DENIED,
        INSURANCE_VERIFICATION,
        PHYSICIAN_QUERY,
        CLAIM_EDIT_REQUIRED,
        OTHER
    }

    enum class PriorAuthStatus {
        NOT_REQUIRED,
        PENDING,
        APPROVED,
        DENIED,
        EXPIRED,
        NOT_OBTAINED
    }

    data class PriorAuthInfo(
        val authNumber: String?,
        val status: PriorAuthStatus,
        val payerName: String?,
        val procedureCodes: List<String>,
        val expirationDate: String?,
        val denialReason: String?
    )

    data class DNFBAccount(
        val dnfbId: String,
        val patientId: String,
        val patientName: String?,
        val mrn: String?,
        val dischargeDate: String,
        val serviceType: String?,
        val principalDiagnosis: String?,
        val estimatedCharges: Float,
        val reason: DNFBReason,
        val reasonDetail: String?,
        val priorAuth: PriorAuthInfo?,
        val daysSinceDischarge: Int,
        val agingBucket: String,
        val isResolved: Boolean
    )

    // DNFB state
    private var dnfbAccounts = mutableListOf<DNFBAccount>()
    private var currentDNFBFilter: String? = null  // reason filter

    // Barcode scanner launcher
    private val barcodeLauncher = registerForActivityResult(
        ActivityResultContracts.StartActivityForResult()
    ) { result ->
        if (result.resultCode == RESULT_OK) {
            val mrn = result.data?.getStringExtra(BarcodeScannerActivity.EXTRA_MRN)
            if (mrn != null) {
                Log.d(TAG, "Scanned MRN: $mrn")
                transcriptText.text = "Scanned MRN: $mrn"
                fetchPatientByMrn(mrn)
            }
        }
    }

    private val requiredPermissions = arrayOf(
        Manifest.permission.RECORD_AUDIO,
        Manifest.permission.CAMERA
    )

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Initialize offline cache and settings
        cachePrefs = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        loadFontSizeSetting()
        loadClinicianName()
        loadSpeechFeedbackSetting()
        loadSessionTimeoutSetting()
        loadLanguagePreference()  // Multi-language support
        loadServerUrl()  // Configure server URL for API calls and WebSocket

        // Initialize device authentication (TOTP + proximity lock)
        initializeDeviceAuth()

        // Start session timeout checker for HIPAA compliance
        startSessionTimeoutChecker()

        // Register network callback for auto-sync of offline drafts
        registerNetworkCallback()

        // Check for pending drafts on startup
        val draftCount = getPendingDraftCount()
        if (draftCount > 0) {
            Log.d(TAG, "Found $draftCount pending draft(s) on startup")
        }

        // Initialize Text-to-Speech for hands-free patient summaries
        initTextToSpeech()

        // Simple layout for AR glasses
        setupUI()

        Log.d(TAG, "MDx Vision starting on ${android.os.Build.MANUFACTURER} ${android.os.Build.MODEL}")

        // Check if running on Vuzix
        if (isVuzixDevice()) {
            Log.d(TAG, "Vuzix device detected - starting HUD service")
            statusText.text = "MDx Vision - Vuzix Mode"
            startVuzixHudService()
            initializeGestureControl()
        } else {
            statusText.text = "MDx Vision - Standard Mode"
        }

        checkPermissions()

        // Auto-load test patient on Samsung devices
        if (android.os.Build.MANUFACTURER.lowercase().contains("samsung")) {
            // Samsung needs quick endpoint due to network restrictions
            testNetworkConnection()
        }
    }

    // Data overlay for showing patient info
    private var dataOverlay: android.widget.FrameLayout? = null

    private fun setupUI() {
        // Main container
        val rootLayout = android.widget.FrameLayout(this).apply {
            setBackgroundColor(0xFF0A1628.toInt())
        }

        // Voice command grid layout
        val mainLayout = android.widget.LinearLayout(this).apply {
            orientation = android.widget.LinearLayout.VERTICAL
            setPadding(24, 24, 24, 24)
        }

        // Status bar at top
        val statusBar = android.widget.LinearLayout(this).apply {
            orientation = android.widget.LinearLayout.HORIZONTAL
            setPadding(0, 0, 0, 16)
        }

        statusText = TextView(this).apply {
            text = "MDx Vision"
            textSize = 20f
            setTextColor(0xFF10B981.toInt())
            layoutParams = android.widget.LinearLayout.LayoutParams(0, android.widget.LinearLayout.LayoutParams.WRAP_CONTENT, 1f)
        }
        statusBar.addView(statusText)

        transcriptText = TextView(this).apply {
            text = "Tap or speak a command"
            textSize = 14f
            setTextColor(0xFF94A3B8.toInt())
            gravity = android.view.Gravity.END
        }
        statusBar.addView(transcriptText)
        mainLayout.addView(statusBar)

        // Voice commands grid - 2 columns, 6 rows (12 buttons)
        // Hidden on Vuzix for simplified voice-only interface
        val gridLayout = android.widget.GridLayout(this).apply {
            columnCount = 2
            rowCount = 6
            layoutParams = android.widget.LinearLayout.LayoutParams(
                android.widget.LinearLayout.LayoutParams.MATCH_PARENT,
                0, 1f
            )
            // Hide buttons on Vuzix - voice-first interface
            if (isVuzixDevice()) {
                visibility = android.view.View.GONE
            }
        }

        // Vuzix-specific: Add simple voice indicator
        if (isVuzixDevice()) {
            val vuzixStatus = TextView(this).apply {
                text = "🎤 Voice Ready - Say \"help\" for commands"
                textSize = 18f
                setTextColor(0xFF10B981.toInt())
                gravity = android.view.Gravity.CENTER
                setPadding(16, 48, 16, 48)
            }
            mainLayout.addView(vuzixStatus)
        }

        // Define all voice commands
        val commands = listOf(
            CommandButton("MDX MODE", 0xFF3B82F6.toInt()) { toggleContinuousListening() },
            CommandButton("LOAD PATIENT", 0xFF6366F1.toInt()) { fetchPatientData(TEST_PATIENT_ID) },
            CommandButton("FIND PATIENT", 0xFF8B5CF6.toInt()) { promptFindPatient() },
            CommandButton("SCAN WRISTBAND", 0xFFEC4899.toInt()) { startBarcodeScanner() },
            CommandButton("SHOW VITALS", 0xFF10B981.toInt()) { fetchPatientSection("vitals") },
            CommandButton("SHOW ALLERGIES", 0xFFEF4444.toInt()) { fetchPatientSection("allergies") },
            CommandButton("SHOW MEDS", 0xFFF59E0B.toInt()) { fetchPatientSection("medications") },
            CommandButton("SHOW LABS", 0xFF06B6D4.toInt()) { fetchPatientSection("labs") },
            CommandButton("SHOW PROCEDURES", 0xFF84CC16.toInt()) { fetchPatientSection("procedures") },
            CommandButton("START NOTE", 0xFFFFB800.toInt()) { toggleDocumentationMode() },
            CommandButton("LIVE TRANSCRIBE", 0xFFE11D48.toInt()) { toggleLiveTranscription() },
            CommandButton("SAVE NOTE", 0xFF22C55E.toInt()) { saveCurrentNote() }
        )

        commands.forEachIndexed { index, cmd ->
            val button = android.widget.Button(this).apply {
                text = cmd.label
                setBackgroundColor(cmd.color)
                setTextColor(0xFFFFFFFF.toInt())
                textSize = 16f
                isAllCaps = true
                setPadding(16, 32, 16, 32)

                val params = android.widget.GridLayout.LayoutParams().apply {
                    width = 0
                    height = 0
                    columnSpec = android.widget.GridLayout.spec(index % 2, 1f)
                    rowSpec = android.widget.GridLayout.spec(index / 2, 1f)
                    setMargins(8, 8, 8, 8)
                }
                layoutParams = params

                setOnClickListener { cmd.action() }
            }
            gridLayout.addView(button)
        }

        mainLayout.addView(gridLayout)
        rootLayout.addView(mainLayout)

        // Hidden patient data overlay (shown when data is loaded)
        patientDataText = TextView(this) // Hidden placeholder

        setContentView(rootLayout)
    }

    private data class CommandButton(val label: String, val color: Int, val action: () -> Unit)

    private fun promptFindPatient() {
        // Start voice recognition for patient name search
        statusText.text = "Say patient name..."
        transcriptText.text = "Listening for name"
        startVoiceRecognition()
    }

    private fun toggleContinuousListening() {
        isContinuousListening = !isContinuousListening

        if (isContinuousListening) {
            statusText.text = "Listening..."
            transcriptText.text = "Just speak naturally"
            awaitingCommand = false
            startVoiceRecognition()
        } else {
            statusText.text = "MDx Vision"
            transcriptText.text = "Tap or speak a command"
            awaitingCommand = false
            try {
                speechRecognizer.stopListening()
            } catch (e: Exception) {
                Log.e(TAG, "Error stopping speech: ${e.message}")
            }
        }
    }

    private fun showDataOverlay(title: String, content: String) {
        // Remove existing overlay if any
        dataOverlay?.let { (it.parent as? android.view.ViewGroup)?.removeView(it) }

        val rootView = window.decorView.findViewById<android.view.ViewGroup>(android.R.id.content)

        dataOverlay = android.widget.FrameLayout(this).apply {
            setBackgroundColor(0xEE0A1628.toInt())
            isClickable = true

            val innerLayout = android.widget.LinearLayout(context).apply {
                orientation = android.widget.LinearLayout.VERTICAL
                setPadding(32, 32, 32, 32)
                layoutParams = android.widget.FrameLayout.LayoutParams(
                    android.widget.FrameLayout.LayoutParams.MATCH_PARENT,
                    android.widget.FrameLayout.LayoutParams.MATCH_PARENT
                )
            }

            // Title
            val titleText = TextView(context).apply {
                text = title
                textSize = getTitleFontSize()
                setTextColor(0xFF10B981.toInt())
                setPadding(0, 0, 0, 16)
            }
            innerLayout.addView(titleText)

            // Scrollable content
            val scrollView = android.widget.ScrollView(context).apply {
                layoutParams = android.widget.LinearLayout.LayoutParams(
                    android.widget.LinearLayout.LayoutParams.MATCH_PARENT, 0, 1f
                )
            }

            val contentText = TextView(context).apply {
                text = content
                textSize = getContentFontSize()
                setTextColor(0xFFF8FAFC.toInt())
                setLineSpacing(4f, 1.2f)
            }
            scrollView.addView(contentText)
            innerLayout.addView(scrollView)

            // Track for voice navigation
            currentScrollView = scrollView
            currentContentText = contentText

            // Close button
            val closeButton = android.widget.Button(context).apply {
                text = "CLOSE (or say 'close')"
                setBackgroundColor(0xFF475569.toInt())
                setTextColor(0xFFFFFFFF.toInt())
                setPadding(32, 24, 32, 24)
                setOnClickListener { hideDataOverlay() }
            }
            innerLayout.addView(closeButton)

            addView(innerLayout)
        }

        rootView.addView(dataOverlay)
        statusText.text = title
        transcriptText.text = "Say 'close' or navigate with 'scroll up/down'"
    }

    /**
     * Show patient data overlay with photo
     * Displays patient photo (or initials) at the top, followed by patient data
     */
    private fun showPatientDataOverlay(patient: JSONObject) {
        val name = patient.optString("name", "Unknown")
        val displayText = patient.optString("display_text", "No data")
        val photoUrl = patient.optString("photo_url", "")

        // Remove existing overlay if any
        dataOverlay?.let { (it.parent as? android.view.ViewGroup)?.removeView(it) }

        val rootView = window.decorView.findViewById<android.view.ViewGroup>(android.R.id.content)

        dataOverlay = android.widget.FrameLayout(this).apply {
            setBackgroundColor(0xEE0A1628.toInt())
            isClickable = true

            val innerLayout = android.widget.LinearLayout(context).apply {
                orientation = android.widget.LinearLayout.VERTICAL
                setPadding(32, 32, 32, 32)
                layoutParams = android.widget.FrameLayout.LayoutParams(
                    android.widget.FrameLayout.LayoutParams.MATCH_PARENT,
                    android.widget.FrameLayout.LayoutParams.MATCH_PARENT
                )
            }

            // Header with photo and name
            val headerLayout = android.widget.LinearLayout(context).apply {
                orientation = android.widget.LinearLayout.HORIZONTAL
                setPadding(0, 0, 0, 16)
                gravity = android.view.Gravity.CENTER_VERTICAL
            }

            // Patient photo or initials placeholder
            val photoSize = 64
            val photoView = android.widget.ImageView(context).apply {
                layoutParams = android.widget.LinearLayout.LayoutParams(photoSize, photoSize).apply {
                    marginEnd = 16
                }
                scaleType = android.widget.ImageView.ScaleType.CENTER_CROP

                // Make it circular with a background
                background = android.graphics.drawable.GradientDrawable().apply {
                    shape = android.graphics.drawable.GradientDrawable.OVAL
                    setColor(0xFF374151.toInt())
                }
                clipToOutline = true
                outlineProvider = object : android.view.ViewOutlineProvider() {
                    override fun getOutline(view: android.view.View, outline: android.graphics.Outline) {
                        outline.setOval(0, 0, view.width, view.height)
                    }
                }
            }

            // Load photo or show initials
            if (photoUrl.isNotEmpty()) {
                loadPatientPhoto(photoView, photoUrl)
            } else {
                // Show initials placeholder
                showInitialsPlaceholder(photoView, name, photoSize)
            }
            headerLayout.addView(photoView)

            // Patient name
            val nameText = TextView(context).apply {
                text = "Patient: $name"
                textSize = getTitleFontSize()
                setTextColor(0xFF10B981.toInt())
            }
            headerLayout.addView(nameText)

            innerLayout.addView(headerLayout)

            // Scrollable content
            val scrollView = android.widget.ScrollView(context).apply {
                layoutParams = android.widget.LinearLayout.LayoutParams(
                    android.widget.LinearLayout.LayoutParams.MATCH_PARENT, 0, 1f
                )
            }

            val contentText = TextView(context).apply {
                text = displayText
                textSize = getContentFontSize()
                setTextColor(0xFFF8FAFC.toInt())
                setLineSpacing(4f, 1.2f)
            }
            scrollView.addView(contentText)
            innerLayout.addView(scrollView)

            // Track for voice navigation
            currentScrollView = scrollView
            currentContentText = contentText

            // Close button
            val closeButton = android.widget.Button(context).apply {
                text = "CLOSE (or say 'close')"
                setBackgroundColor(0xFF475569.toInt())
                setTextColor(0xFFFFFFFF.toInt())
                setPadding(32, 24, 32, 24)
                setOnClickListener { hideDataOverlay() }
            }
            innerLayout.addView(closeButton)

            addView(innerLayout)
        }

        rootView.addView(dataOverlay)
        statusText.text = "Patient: $name"
        transcriptText.text = "Say 'close' or navigate with 'scroll up/down'"
    }

    /**
     * Load patient photo from URL or base64 data URI
     */
    private fun loadPatientPhoto(imageView: android.widget.ImageView, photoUrl: String) {
        try {
            if (photoUrl.startsWith("data:")) {
                // Base64 data URI
                val base64Data = photoUrl.substringAfter("base64,")
                val imageBytes = android.util.Base64.decode(base64Data, android.util.Base64.DEFAULT)
                val bitmap = android.graphics.BitmapFactory.decodeByteArray(imageBytes, 0, imageBytes.size)
                imageView.setImageBitmap(bitmap)
            } else {
                // URL - load asynchronously
                Thread {
                    try {
                        val url = java.net.URL(photoUrl)
                        val connection = url.openConnection() as java.net.HttpURLConnection
                        connection.doInput = true
                        connection.connect()
                        val input = connection.inputStream
                        val bitmap = android.graphics.BitmapFactory.decodeStream(input)
                        runOnUiThread {
                            imageView.setImageBitmap(bitmap)
                        }
                    } catch (e: Exception) {
                        Log.e(TAG, "Failed to load patient photo: ${e.message}")
                    }
                }.start()
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error processing patient photo: ${e.message}")
        }
    }

    /**
     * Show initials placeholder when no photo is available
     */
    private fun showInitialsPlaceholder(imageView: android.widget.ImageView, name: String, size: Int) {
        // Extract initials (first letter of first and last name)
        val parts = name.split(" ", ",").filter { it.isNotBlank() }
        val initials = when {
            parts.size >= 2 -> "${parts[0].first()}${parts[1].first()}"
            parts.isNotEmpty() -> parts[0].take(2)
            else -> "?"
        }.uppercase()

        // Create a bitmap with initials
        val bitmap = android.graphics.Bitmap.createBitmap(size, size, android.graphics.Bitmap.Config.ARGB_8888)
        val canvas = android.graphics.Canvas(bitmap)

        // Draw circle background
        val bgPaint = android.graphics.Paint().apply {
            color = 0xFF6366F1.toInt()  // Indigo color
            isAntiAlias = true
        }
        canvas.drawCircle(size / 2f, size / 2f, size / 2f, bgPaint)

        // Draw initials
        val textPaint = android.graphics.Paint().apply {
            color = 0xFFFFFFFF.toInt()
            textSize = size * 0.4f
            textAlign = android.graphics.Paint.Align.CENTER
            isAntiAlias = true
            typeface = android.graphics.Typeface.DEFAULT_BOLD
        }
        val textY = size / 2f - (textPaint.descent() + textPaint.ascent()) / 2
        canvas.drawText(initials, size / 2f, textY, textPaint)

        imageView.setImageBitmap(bitmap)
    }

    private fun hideDataOverlay() {
        dataOverlay?.let { overlay ->
            (overlay.parent as? android.view.ViewGroup)?.removeView(overlay)
            dataOverlay = null
        }
        // Clear voice navigation tracking
        currentScrollView = null
        currentContentText = null
        statusText.text = "MDx Vision"
        transcriptText.text = "Tap or speak a command"
    }

    private fun startBarcodeScanner() {
        val intent = Intent(this, BarcodeScannerActivity::class.java)
        barcodeLauncher.launch(intent)
    }

    private fun toggleDocumentationMode() {
        isDocumentationMode = !isDocumentationMode

        if (isDocumentationMode) {
            // Start documentation mode
            documentationTranscripts.clear()
            statusText.text = "DOCUMENTING"
            transcriptText.text = "Speak... say 'stop note' to finish"
            startVoiceRecognition()
        } else {
            // End documentation mode - generate note
            if (documentationTranscripts.isNotEmpty()) {
                generateClinicalNote(documentationTranscripts.joinToString(" "))
            } else {
                statusText.text = "MDx Vision"
                transcriptText.text = "No transcript captured"
            }
        }
    }

    /**
     * Toggle real-time transcription via AssemblyAI/Deepgram WebSocket
     * Shows live transcript overlay with streaming text
     */
    private fun toggleLiveTranscription() {
        if (isLiveTranscribing) {
            stopLiveTranscription()
        } else {
            startLiveTranscription()
        }
    }

    private fun startLiveTranscription() {
        // Check permission
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO)
            != PackageManager.PERMISSION_GRANTED
        ) {
            Toast.makeText(this, "Microphone permission required", Toast.LENGTH_SHORT).show()
            return
        }

        liveTranscriptBuffer.clear()

        // Create audio streaming service
        audioStreamingService = AudioStreamingService(this) { result ->
            runOnUiThread {
                // Check for voice command to stop transcription
                val lower = result.text.lowercase()
                if (result.isFinal && (lower.contains("stop transcri") ||
                    lower.contains("close") || lower.contains("stop recording"))) {
                    stopLiveTranscription()
                    hideLiveTranscriptionOverlay()
                    // Show the transcript without the stop command
                    val cleanTranscript = liveTranscriptBuffer.toString()
                        .replace(Regex("(?i)stop transcri\\w*"), "")
                        .replace(Regex("(?i)close"), "")
                        .replace(Regex("(?i)stop recording"), "")
                        .trim()
                    if (cleanTranscript.isNotEmpty()) {
                        showTranscriptionCompleteOverlay(cleanTranscript)
                    }
                    return@runOnUiThread
                }

                if (result.isFinal) {
                    // Final transcript - add to buffer with speaker label if available
                    if (liveTranscriptBuffer.isNotEmpty()) {
                        liveTranscriptBuffer.append("\n")
                    }
                    // Add speaker label if present and different from last
                    val speakerPrefix = if (result.speaker != null) {
                        "[${result.speaker}]: "
                    } else ""
                    liveTranscriptBuffer.append(speakerPrefix).append(result.text)
                    liveTranscriptText?.text = liveTranscriptBuffer.toString()
                } else {
                    // Interim result - show at end with speaker
                    val speakerPrefix = if (result.speaker != null) "[${result.speaker}]: " else ""
                    val display = if (liveTranscriptBuffer.isEmpty()) {
                        speakerPrefix + result.text
                    } else {
                        "${liveTranscriptBuffer}\n$speakerPrefix${result.text}"
                    }
                    liveTranscriptText?.text = display
                }

                // Auto-scroll to bottom if enabled
                if (isAutoScrollEnabled) {
                    liveTranscriptScrollView?.post {
                        liveTranscriptScrollView?.fullScroll(android.view.View.FOCUS_DOWN)
                    }
                }
            }
        }

        audioStreamingService?.onConnected = { sessionId, provider ->
            runOnUiThread {
                statusText.text = "TRANSCRIBING ($provider)"
                Log.d(TAG, "Live transcription started: $sessionId via $provider")
                // Don't speak during transcription - mic picks it up
            }
        }

        audioStreamingService?.onDisconnected = { fullTranscript ->
            runOnUiThread {
                Log.d(TAG, "Transcription ended, ${fullTranscript.length} chars")
                isLiveTranscribing = false
                // Offer to generate note from transcript
                if (fullTranscript.isNotEmpty()) {
                    showTranscriptionCompleteOverlay(fullTranscript)
                }
                // Restart voice recognition for "generate note" command
                if (isContinuousListening) {
                    statusText.text = "Listening..."
                    startVoiceRecognition()
                }
            }
        }

        audioStreamingService?.onError = { message ->
            runOnUiThread {
                Toast.makeText(this, "Transcription error: $message", Toast.LENGTH_SHORT).show()
                statusText.text = "MDx Vision"
                speakFeedback("Transcription error")
            }
        }

        // Show live transcription overlay
        showLiveTranscriptionOverlay()

        // Build speaker context from loaded patient and clinician
        val patientName = currentPatientData?.optString("name")?.takeIf { it.isNotEmpty() }
        val speakerContext = AudioStreamingService.SpeakerContext(
            clinician = clinicianName,
            patient = patientName
        )

        // Start streaming with speaker context
        if (audioStreamingService?.startStreaming(speakerContext = speakerContext) == true) {
            isLiveTranscribing = true
            if (patientName != null) {
                Log.d(TAG, "Speaker context: clinician=$clinicianName, patient=$patientName")
            }
        } else {
            hideLiveTranscriptionOverlay()
            Toast.makeText(this, "Failed to start transcription", Toast.LENGTH_SHORT).show()
        }
    }

    private fun stopLiveTranscription() {
        isLiveTranscribing = false
        audioStreamingService?.stopStreaming()
        statusText.text = "Listening..."
        // Restart voice recognition for commands after transcription
        if (isContinuousListening) {
            startVoiceRecognition()
        }
    }

    private fun showLiveTranscriptionOverlay() {
        dataOverlay?.let { (it.parent as? android.view.ViewGroup)?.removeView(it) }

        val rootView = window.decorView.findViewById<android.view.ViewGroup>(android.R.id.content)

        dataOverlay = android.widget.FrameLayout(this).apply {
            setBackgroundColor(0xEE0A1628.toInt())
            isClickable = true

            val innerLayout = android.widget.LinearLayout(context).apply {
                orientation = android.widget.LinearLayout.VERTICAL
                setPadding(32, 32, 32, 32)
                layoutParams = android.widget.FrameLayout.LayoutParams(
                    android.widget.FrameLayout.LayoutParams.MATCH_PARENT,
                    android.widget.FrameLayout.LayoutParams.MATCH_PARENT
                )
            }

            // Recording indicator
            val recordingIndicator = android.widget.LinearLayout(context).apply {
                orientation = android.widget.LinearLayout.HORIZONTAL
                setPadding(0, 0, 0, 16)

                val dot = TextView(context).apply {
                    text = "🔴"
                    textSize = 20f
                    setPadding(0, 0, 16, 0)
                }
                addView(dot)

                val title = TextView(context).apply {
                    text = "LIVE TRANSCRIPTION"
                    textSize = 20f
                    setTextColor(0xFFE11D48.toInt())
                }
                addView(title)
            }
            innerLayout.addView(recordingIndicator)

            // Scrollable transcript area
            liveTranscriptScrollView = android.widget.ScrollView(context).apply {
                layoutParams = android.widget.LinearLayout.LayoutParams(
                    android.widget.LinearLayout.LayoutParams.MATCH_PARENT, 0, 1f
                )
                setBackgroundColor(0xFF1E293B.toInt())
                setPadding(16, 16, 16, 16)
            }

            liveTranscriptText = TextView(context).apply {
                text = "Listening..."
                textSize = getContentFontSize() + 2f  // Slightly larger for transcription
                setTextColor(0xFFF8FAFC.toInt())
                setLineSpacing(6f, 1.3f)
            }
            liveTranscriptScrollView?.addView(liveTranscriptText)
            innerLayout.addView(liveTranscriptScrollView)

            // Stop button
            val stopButton = android.widget.Button(context).apply {
                text = "⏹ STOP TRANSCRIPTION"
                setBackgroundColor(0xFFE11D48.toInt())
                setTextColor(0xFFFFFFFF.toInt())
                textSize = 16f
                setPadding(32, 24, 32, 24)
                setOnClickListener {
                    stopLiveTranscription()
                    hideLiveTranscriptionOverlay()
                }
            }
            innerLayout.addView(stopButton)

            addView(innerLayout)
        }

        rootView.addView(dataOverlay)
        statusText.text = "Connecting..."
    }

    private fun hideLiveTranscriptionOverlay() {
        dataOverlay?.let { overlay ->
            (overlay.parent as? android.view.ViewGroup)?.removeView(overlay)
        }
        dataOverlay = null
        liveTranscriptText = null
        liveTranscriptScrollView = null
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // AMBIENT CLINICAL INTELLIGENCE (ACI) - Functions
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Toggle Ambient Clinical Intelligence mode
     * In this mode, the app continuously listens and auto-extracts clinical entities
     */
    private fun toggleAmbientMode() {
        if (isAmbientMode) {
            stopAmbientMode()
        } else {
            startAmbientMode()
        }
    }

    /**
     * Start Ambient Clinical Intelligence mode
     * Uses WebSocket transcription on Vuzix, local Android speech otherwise
     */
    private fun startAmbientMode() {
        Log.d(TAG, "ACI: startAmbientMode() called")
        if (currentPatientData == null) {
            Log.w(TAG, "ACI: No patient loaded - ambient mode requires patient")
            speakFeedback("Load a patient first before starting ambient mode")
            Toast.makeText(this, "Load patient first", Toast.LENGTH_SHORT).show()
            return
        }

        isAmbientMode = true
        ambientStartTime = System.currentTimeMillis()
        ambientTranscriptBuffer.clear()
        extractedEntities.clear()
        lastIdentifiedSpeaker = "Clinician"  // Reset speaker tracking

        statusText.text = "🎙️ AMBIENT MODE"
        transcriptText.text = "Listening to encounter..."

        // Show ACI overlay
        showAciOverlay()

        speakFeedback("Ambient mode started. Say stop ambient when finished.")

        // On Vuzix or devices without Google Speech, use WebSocket (AssemblyAI)
        if (useWebSocketForCommands) {
            Log.d(TAG, "ACI: Ambient mode using WebSocket transcription")
            startAmbientWebSocket()
        } else {
            Log.d(TAG, "ACI: Ambient mode using local speech recognition")
            startAmbientVoiceRecognition()
        }
    }

    /**
     * Start WebSocket-based ambient mode (for Vuzix/devices without Google Speech)
     */
    private fun startAmbientWebSocket() {
        // Create dedicated ambient streaming service
        val ambientService = AudioStreamingService(this) { result ->
            runOnUiThread {
                if (result.text.isNotBlank()) {
                    // Add to ambient transcript buffer
                    ambientTranscriptBuffer.append(result.text).append(" ")

                    // Extract clinical entities
                    extractClinicalEntities(result.text)

                    // Update display
                    transcriptText.text = "\"${result.text}\""

                    // Check for stop commands
                    val lower = result.text.lowercase()
                    if (lower.contains("stop ambient") || lower.contains("end ambient") ||
                        lower.contains("finish ambient") || lower.contains("stop listening")) {
                        stopAmbientMode(generateNote = true)
                    }
                }
            }
        }

        if (ambientService.startStreaming() == true) {
            audioStreamingService = ambientService
            Log.d(TAG, "ACI: WebSocket ambient streaming started")
        } else {
            Log.e(TAG, "ACI: Failed to start WebSocket ambient streaming")
            statusText.text = "Ambient mode failed"
            isAmbientMode = false
            hideAciOverlay()
        }
    }

    /**
     * Start voice recognition specifically for ambient mode
     */
    private fun startAmbientVoiceRecognition() {
        if (!isAmbientMode) return

        val intent = android.content.Intent(android.speech.RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {
            putExtra(android.speech.RecognizerIntent.EXTRA_LANGUAGE_MODEL,
                     android.speech.RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)
            putExtra(android.speech.RecognizerIntent.EXTRA_PARTIAL_RESULTS, true)
            putExtra(android.speech.RecognizerIntent.EXTRA_MAX_RESULTS, 1)
            putExtra(android.speech.RecognizerIntent.EXTRA_LANGUAGE, currentLanguage)
            // Longer speech timeout for ambient listening
            putExtra(android.speech.RecognizerIntent.EXTRA_SPEECH_INPUT_COMPLETE_SILENCE_LENGTH_MILLIS, 3000L)
            putExtra(android.speech.RecognizerIntent.EXTRA_SPEECH_INPUT_POSSIBLY_COMPLETE_SILENCE_LENGTH_MILLIS, 2000L)
        }

        try {
            speechRecognizer?.startListening(intent)
        } catch (e: Exception) {
            Log.e(TAG, "ACI: Failed to start ambient recognition: ${e.message}")
        }
    }

    /**
     * Stop Ambient Clinical Intelligence mode and optionally generate note
     */
    private fun stopAmbientMode(generateNote: Boolean = true) {
        if (!isAmbientMode) return

        isAmbientMode = false
        audioStreamingService?.stopStreaming()

        val duration = (System.currentTimeMillis() - ambientStartTime) / 1000 / 60
        val durationSeconds = (System.currentTimeMillis() - ambientStartTime) / 1000
        Log.d(TAG, "ACI: Ambient mode stopped after ${duration}min (${durationSeconds}s)")

        if (generateNote) {
            if (extractedEntities.hasEntities()) {
                // Generate SOAP note from extracted entities
                generateAciNote()
            } else if (ambientTranscriptBuffer.isNotEmpty()) {
                // Generate from raw transcript if we have any
                hideAciOverlay()
                statusText.text = "Generating note from transcript..."
                generateClinicalNote(ambientTranscriptBuffer.toString())
            } else {
                // No transcript captured
                hideAciOverlay()
                statusText.text = "MDx Vision"
                transcriptText.text = "No transcript captured (${durationSeconds}s session)"
                speakFeedback("No transcript captured. Try speaking clearly or check connection.")
                Toast.makeText(this, "No transcript captured - check proxy connection", Toast.LENGTH_LONG).show()
            }
        } else {
            hideAciOverlay()
            statusText.text = "MDx Vision"
            transcriptText.text = "Ambient mode cancelled"
        }

        if (generateNote && (extractedEntities.hasEntities() || ambientTranscriptBuffer.isNotEmpty())) {
            // Suggest DDx if symptoms were detected
            if (extractedEntities.symptoms.isNotEmpty()) {
                speakFeedback("Note generated. Say differential diagnosis for possible diagnoses.")
            } else {
                speakFeedback("Ambient mode ended. Note generated.")
            }
        } else {
            speakFeedback("Ambient mode ended")
        }

        // Restart voice recognition
        if (isContinuousListening) {
            startVoiceRecognition()
        }
    }

    /**
     * Process transcript in ambient mode - extract clinical entities
     */
    private fun processAmbientTranscript(result: AudioStreamingService.TranscriptionResult) {
        if (!isAmbientMode) return

        val text = result.text
        val isFinal = result.isFinal
        val lower = text.lowercase()

        // ═══ CHECK FOR VOICE COMMANDS DURING AMBIENT MODE ═══
        if (isFinal) {
            when {
                lower.contains("stop ambient") || lower.contains("end ambient") ||
                lower.contains("finish ambient") || lower.contains("stop listening") -> {
                    Log.d(TAG, "ACI: Stop command detected: $text")
                    stopAmbientMode(true)
                    return
                }
                lower.contains("cancel ambient") || lower.contains("discard ambient") ||
                lower.contains("never mind") || lower.contains("cancel") -> {
                    Log.d(TAG, "ACI: Cancel command detected: $text")
                    stopAmbientMode(false)
                    hideAciOverlay()
                    return
                }
                lower.contains("generate note") || lower.contains("create note") ||
                lower.contains("make note") || lower.contains("document this") -> {
                    Log.d(TAG, "ACI: Generate note command detected: $text")
                    stopAmbientMode(true)
                    return
                }
                lower.contains("show entities") || lower.contains("what did you detect") ||
                lower.contains("what did you hear") || lower.contains("show summary") -> {
                    Log.d(TAG, "ACI: Show entities command detected: $text")
                    showAciEntities()
                    return
                }
            }
        }

        // Add to buffer (skip if it was a command)
        if (isFinal && text.isNotBlank()) {
            if (ambientTranscriptBuffer.isNotEmpty()) {
                ambientTranscriptBuffer.append(" ")
            }

            // Add speaker prefix if available
            val speaker = identifySpeaker(text)
            val segment = SpeakerSegment(speaker, text, System.currentTimeMillis())
            extractedEntities.speakerSegments.add(segment)

            ambientTranscriptBuffer.append("[$speaker] $text")

            // Extract entities with debouncing
            val now = System.currentTimeMillis()
            if (now - lastEntityUpdateTime > ENTITY_UPDATE_DEBOUNCE_MS) {
                extractClinicalEntities(text)
                lastEntityUpdateTime = now
            }

            // Update display
            updateAciDisplay()
        }

        // Update live transcript
        aciTranscriptText?.text = if (isFinal) {
            ambientTranscriptBuffer.toString().takeLast(500)  // Show last 500 chars
        } else {
            "${ambientTranscriptBuffer.toString().takeLast(400)}\n🎤 $text"
        }
    }

    /**
     * Filter out voice commands from ACI transcript
     * Returns cleaned text with commands removed, or null if entire text was a command
     */
    private fun filterVoiceCommandsFromTranscript(text: String): String? {
        val lower = text.lowercase().trim()

        // Check if entire text is just a voice command
        for (cmd in aciVoiceCommands) {
            if (lower == cmd || lower.startsWith("$cmd ") ||
                lower.endsWith(" $cmd") || lower.contains(" $cmd ")) {
                // Entire segment is a command or contains only commands
                if (lower.length < cmd.length + 10) {
                    Log.d(TAG, "ACI: Filtered voice command: $text")
                    return null
                }
            }
        }

        // Try to remove command phrases from text
        var cleaned = text
        for (cmd in aciVoiceCommands) {
            val pattern = "(?i)\\b${Regex.escape(cmd)}\\b".toRegex()
            cleaned = cleaned.replace(pattern, "").trim()
        }

        // Remove orphaned punctuation and extra spaces
        cleaned = cleaned.replace(Regex("\\s+"), " ")
                         .replace(Regex("^[\\s,\\.]+|[\\s,\\.]+$"), "")
                         .trim()

        // If nothing meaningful left, return null
        if (cleaned.length < 3 || cleaned.split(" ").all { it.length < 2 }) {
            return null
        }

        return cleaned
    }

    /**
     * Identify speaker with improved context-aware detection
     */
    private fun identifySpeaker(text: String): String {
        val lower = text.lowercase()

        // Score based on patterns
        var patientScore = 0
        var clinicianScore = 0

        // Count pattern matches with weights
        for (pattern in patientSpeakerPatterns) {
            if (lower.contains(pattern)) {
                patientScore += if (pattern in listOf("i have", "i feel", "it hurts", "bothering me")) 3 else 1
            }
        }
        for (pattern in clinicianSpeakerPatterns) {
            if (lower.contains(pattern)) {
                clinicianScore += if (pattern in listOf("i recommend", "i'll order", "examination shows", "on exam")) 3 else 1
            }
        }

        // Questions typically come from clinician
        if (lower.contains("?") || lower.startsWith("how") || lower.startsWith("when") ||
            lower.startsWith("what") || lower.startsWith("where") || lower.startsWith("do you") ||
            lower.startsWith("are you") || lower.startsWith("have you")) {
            clinicianScore += 2
        }

        // First-person symptom descriptions are patient
        if (Regex("\\bi (have|had|feel|felt|got|get|been|am|was|can't|cannot)\\b").containsMatchIn(lower)) {
            patientScore += 2
        }

        // Responses that start with "yes" or "no" or "about" are typically patient answering
        if (lower.startsWith("yes") || lower.startsWith("no") || lower.startsWith("about") ||
            lower.startsWith("maybe") || lower.startsWith("sometimes") || lower.startsWith("since")) {
            patientScore += 1
        }

        // Medical jargon = clinician
        val medicalTerms = listOf("diagnosis", "prescribe", "medication", "dosage", "follow up",
            "blood pressure", "heart rate", "examination", "recommend", "order labs")
        if (medicalTerms.any { lower.contains(it) }) {
            clinicianScore += 2
        }

        val identified = when {
            patientScore > clinicianScore -> "Patient"
            clinicianScore > patientScore -> "Clinician"
            // If tied, alternate from last speaker (natural conversation flow)
            lastIdentifiedSpeaker == "Clinician" -> "Patient"
            else -> "Clinician"
        }

        lastIdentifiedSpeaker = identified
        return identified
    }

    /**
     * Extract clinical entities from text
     */
    // Common speech recognition errors for medical terms
    private val medicalTermCorrections = mapOf(
        "beaver" to "fever",
        "beever" to "fever",
        "feaver" to "fever",
        "hedake" to "headache",
        "head ache" to "headache",
        "head egg" to "headache",
        "stomach egg" to "stomach ache",
        "coff" to "cough",
        "coffin" to "coughing",
        "nauseous" to "nausea",
        "dizzy spell" to "dizziness",
        "short of breath" to "shortness of breath",
        "chest pains" to "chest pain",
        "back pains" to "back pain",
        "sore throw" to "sore throat",
        "throw up" to "vomiting",
        "threw up" to "vomited",
        "diabetes" to "diabetes",
        "die of beets" to "diabetes",
        "high pretension" to "hypertension",
        "high blood pressure" to "hypertension"
    )

    /**
     * Correct common speech recognition errors for medical terms
     */
    private fun correctMedicalTerms(text: String): String {
        var corrected = text.lowercase()
        for ((wrong, right) in medicalTermCorrections) {
            corrected = corrected.replace(wrong, right)
        }
        return corrected
    }

    private fun extractClinicalEntities(text: String) {
        // Apply medical term corrections before extraction
        val lower = correctMedicalTerms(text.lowercase())

        // Extract chief complaints
        for (trigger in chiefComplaintTriggers) {
            if (lower.contains(trigger)) {
                val complaint = extractPhraseAfter(lower, trigger)
                if (complaint.isNotBlank() && complaint !in extractedEntities.chiefComplaints) {
                    extractedEntities.chiefComplaints.add(complaint.take(100))
                }
            }
        }

        // Extract symptoms
        for (symptom in symptomPatterns) {
            if (lower.contains(symptom) && symptom !in extractedEntities.symptoms) {
                extractedEntities.symptoms.add(symptom)
            }
        }

        // Extract medications mentioned
        for (med in medicationPatterns) {
            if (lower.contains(med) && med.length > 3) {  // Skip trigger phrases
                val normalized = med.replaceFirstChar { it.uppercase() }
                if (normalized !in extractedEntities.medications) {
                    extractedEntities.medications.add(normalized)
                }
            }
        }

        // Extract allergy mentions
        for (pattern in allergyPatterns) {
            if (lower.contains(pattern)) {
                val allergy = extractPhraseAfter(lower, pattern)
                if (allergy.isNotBlank() && allergy !in extractedEntities.allergiesMentioned) {
                    extractedEntities.allergiesMentioned.add(allergy.take(50))
                }
            }
        }

        // Extract vitals mentioned
        for ((vital, patterns) in vitalPatterns) {
            for (pattern in patterns) {
                if (lower.contains(pattern)) {
                    val value = extractNumberAfter(lower, pattern)
                    if (value.isNotBlank()) {
                        extractedEntities.vitalsMentioned[vital] = value
                    }
                }
            }
        }

        // Extract medical history
        for (trigger in medicalHistoryTriggers) {
            if (lower.contains(trigger)) {
                val history = extractPhraseAfter(lower, trigger)
                if (history.isNotBlank() && history !in extractedEntities.medicalHistory) {
                    extractedEntities.medicalHistory.add(history.take(100))
                }
            }
        }

        // Extract social history
        for (trigger in socialHistoryTriggers) {
            if (lower.contains(trigger)) {
                extractedEntities.socialHistory.add(trigger)
            }
        }

        // Extract family history
        for (trigger in familyHistoryTriggers) {
            if (lower.contains(trigger)) {
                val history = extractPhraseAfter(lower, trigger)
                if (history.isNotBlank() && history !in extractedEntities.familyHistory) {
                    extractedEntities.familyHistory.add(history.take(100))
                }
            }
        }

        // Categorize into review of systems
        for ((category, keywords) in rosCategories) {
            for (keyword in keywords) {
                if (lower.contains(keyword)) {
                    val rosList = extractedEntities.reviewOfSystems.getOrPut(category) { mutableListOf() }
                    if (keyword !in rosList) {
                        rosList.add(keyword)
                    }
                }
            }
        }

        // Extract physical exam findings
        for (trigger in physicalExamTriggers) {
            if (lower.contains(trigger)) {
                val finding = extractPhraseAfter(lower, trigger)
                if (finding.isNotBlank() && finding !in extractedEntities.physicalExamFindings) {
                    extractedEntities.physicalExamFindings.add(finding.take(100))
                }
            }
        }

        // Extract assessments
        for (trigger in assessmentTriggers) {
            if (lower.contains(trigger)) {
                val assessment = extractPhraseAfter(lower, trigger)
                if (assessment.isNotBlank() && assessment !in extractedEntities.assessments) {
                    extractedEntities.assessments.add(assessment.take(100))
                }
            }
        }

        // Extract plans
        for (trigger in planTriggers) {
            if (lower.contains(trigger)) {
                val plan = extractPhraseAfter(lower, trigger)
                if (plan.isNotBlank() && plan !in extractedEntities.plans) {
                    extractedEntities.plans.add(plan.take(100))
                }
            }
        }
    }

    /**
     * Extract phrase after a trigger word
     */
    private fun extractPhraseAfter(text: String, trigger: String): String {
        val idx = text.indexOf(trigger)
        if (idx < 0) return ""
        val after = text.substring(idx + trigger.length).trim()
        // Take up to first sentence end or 50 words
        val endIdx = after.indexOfAny(charArrayOf('.', '?', '!', ','))
        return if (endIdx > 0) {
            after.substring(0, endIdx).trim()
        } else {
            after.split(" ").take(10).joinToString(" ")
        }
    }

    /**
     * Extract number after a pattern (for vitals)
     */
    private fun extractNumberAfter(text: String, pattern: String): String {
        val idx = text.indexOf(pattern)
        if (idx < 0) return ""
        val after = text.substring(idx + pattern.length).trim()
        val match = Regex("\\d+[./]?\\d*").find(after)
        return match?.value ?: ""
    }

    /**
     * Show ACI overlay with real-time entities
     */
    private fun showAciOverlay() {
        aciOverlay?.let { (it.parent as? android.view.ViewGroup)?.removeView(it) }

        val rootView = window.decorView.findViewById<android.view.ViewGroup>(android.R.id.content)

        aciOverlay = android.widget.FrameLayout(this).apply {
            setBackgroundColor(0xEE0A1628.toInt())
            isClickable = true

            val innerLayout = android.widget.LinearLayout(context).apply {
                orientation = android.widget.LinearLayout.VERTICAL
                setPadding(24, 24, 24, 24)
                layoutParams = android.widget.FrameLayout.LayoutParams(
                    android.widget.FrameLayout.LayoutParams.MATCH_PARENT,
                    android.widget.FrameLayout.LayoutParams.MATCH_PARENT
                )
            }

            // Header with recording indicator
            val header = android.widget.LinearLayout(context).apply {
                orientation = android.widget.LinearLayout.HORIZONTAL
                setPadding(0, 0, 0, 12)

                val dot = TextView(context).apply {
                    text = "🟢"
                    textSize = 18f
                    setPadding(0, 0, 12, 0)
                }
                addView(dot)

                val title = TextView(context).apply {
                    text = "AMBIENT CLINICAL INTELLIGENCE"
                    textSize = 16f
                    setTextColor(0xFF10B981.toInt())
                    layoutParams = android.widget.LinearLayout.LayoutParams(0, android.widget.LinearLayout.LayoutParams.WRAP_CONTENT, 1f)
                }
                addView(title)

                val stopBtn = android.widget.Button(context).apply {
                    text = "STOP & GENERATE"
                    textSize = 12f
                    setBackgroundColor(0xFFEF4444.toInt())
                    setTextColor(0xFFFFFFFF.toInt())
                    setOnClickListener { stopAmbientMode(true) }
                }
                addView(stopBtn)
            }
            innerLayout.addView(header)

            // Entities section (scrollable)
            val entitiesScroll = android.widget.ScrollView(context).apply {
                layoutParams = android.widget.LinearLayout.LayoutParams(
                    android.widget.LinearLayout.LayoutParams.MATCH_PARENT, 0, 0.5f
                )
            }

            aciEntitiesText = TextView(context).apply {
                text = "Listening for clinical information..."
                textSize = 14f
                setTextColor(0xFFE2E8F0.toInt())
                setPadding(0, 8, 0, 8)
            }
            entitiesScroll.addView(aciEntitiesText)
            innerLayout.addView(entitiesScroll)

            // Divider
            val divider = android.view.View(context).apply {
                setBackgroundColor(0xFF475569.toInt())
                layoutParams = android.widget.LinearLayout.LayoutParams(
                    android.widget.LinearLayout.LayoutParams.MATCH_PARENT, 2
                ).apply { setMargins(0, 8, 0, 8) }
            }
            innerLayout.addView(divider)

            // Transcript section
            val transcriptLabel = TextView(context).apply {
                text = "📝 Live Transcript"
                textSize = 14f
                setTextColor(0xFF94A3B8.toInt())
                setPadding(0, 0, 0, 4)
            }
            innerLayout.addView(transcriptLabel)

            val transcriptScroll = android.widget.ScrollView(context).apply {
                layoutParams = android.widget.LinearLayout.LayoutParams(
                    android.widget.LinearLayout.LayoutParams.MATCH_PARENT, 0, 0.5f
                )
            }

            aciTranscriptText = TextView(context).apply {
                text = "🎤 Listening..."
                textSize = 12f
                setTextColor(0xFFCBD5E1.toInt())
            }
            transcriptScroll.addView(aciTranscriptText)
            innerLayout.addView(transcriptScroll)

            // Control buttons
            val controlRow = android.widget.LinearLayout(context).apply {
                orientation = android.widget.LinearLayout.HORIZONTAL
                setPadding(0, 12, 0, 0)

                val cancelBtn = android.widget.Button(context).apply {
                    text = "CANCEL"
                    textSize = 14f
                    setBackgroundColor(0xFF64748B.toInt())
                    setTextColor(0xFFFFFFFF.toInt())
                    layoutParams = android.widget.LinearLayout.LayoutParams(0, android.widget.LinearLayout.LayoutParams.WRAP_CONTENT, 1f).apply {
                        setMargins(0, 0, 8, 0)
                    }
                    setOnClickListener { stopAmbientMode(false); hideAciOverlay() }
                }
                addView(cancelBtn)

                val pauseBtn = android.widget.Button(context).apply {
                    text = "PAUSE"
                    textSize = 14f
                    setBackgroundColor(0xFFF59E0B.toInt())
                    setTextColor(0xFFFFFFFF.toInt())
                    layoutParams = android.widget.LinearLayout.LayoutParams(0, android.widget.LinearLayout.LayoutParams.WRAP_CONTENT, 1f)
                    setOnClickListener {
                        // Toggle pause (could be implemented)
                        Toast.makeText(context, "Pause not implemented yet", Toast.LENGTH_SHORT).show()
                    }
                }
                addView(pauseBtn)
            }
            innerLayout.addView(controlRow)

            addView(innerLayout)
        }

        rootView.addView(aciOverlay)
    }

    /**
     * Update the ACI display with extracted entities
     */
    private fun updateAciDisplay() {
        val sb = StringBuilder()

        if (extractedEntities.chiefComplaints.isNotEmpty()) {
            sb.append("🎯 CHIEF COMPLAINT\n")
            extractedEntities.chiefComplaints.forEach { sb.append("  • $it\n") }
            sb.append("\n")
        }

        if (extractedEntities.symptoms.isNotEmpty()) {
            sb.append("🤒 SYMPTOMS (${extractedEntities.symptoms.size})\n")
            sb.append("  ${extractedEntities.symptoms.take(10).joinToString(", ")}\n\n")
        }

        if (extractedEntities.vitalsMentioned.isNotEmpty()) {
            sb.append("📊 VITALS MENTIONED\n")
            extractedEntities.vitalsMentioned.forEach { (k, v) -> sb.append("  • $k: $v\n") }
            sb.append("\n")
        }

        if (extractedEntities.medications.isNotEmpty()) {
            sb.append("💊 MEDICATIONS (${extractedEntities.medications.size})\n")
            sb.append("  ${extractedEntities.medications.take(8).joinToString(", ")}\n\n")
        }

        if (extractedEntities.allergiesMentioned.isNotEmpty()) {
            sb.append("⚠️ ALLERGIES MENTIONED\n")
            extractedEntities.allergiesMentioned.forEach { sb.append("  • $it\n") }
            sb.append("\n")
        }

        if (extractedEntities.medicalHistory.isNotEmpty()) {
            sb.append("📋 MEDICAL HISTORY\n")
            extractedEntities.medicalHistory.take(5).forEach { sb.append("  • $it\n") }
            sb.append("\n")
        }

        if (extractedEntities.assessments.isNotEmpty()) {
            sb.append("🔍 ASSESSMENTS\n")
            extractedEntities.assessments.forEach { sb.append("  • $it\n") }
            sb.append("\n")
        }

        if (extractedEntities.plans.isNotEmpty()) {
            sb.append("📝 PLAN ITEMS\n")
            extractedEntities.plans.forEach { sb.append("  • $it\n") }
            sb.append("\n")
        }

        if (sb.isEmpty()) {
            sb.append("Listening for clinical information...\n\n")
            sb.append("Detected entities will appear here as you speak.")
        }

        aciEntitiesText?.text = sb.toString()
    }

    /**
     * Hide ACI overlay
     */
    private fun hideAciOverlay() {
        aciOverlay?.let { overlay ->
            (overlay.parent as? android.view.ViewGroup)?.removeView(overlay)
        }
        aciOverlay = null
        aciEntitiesText = null
        aciTranscriptText = null
    }

    /**
     * Generate SOAP note from ACI extracted entities
     */
    private fun generateAciNote() {
        hideAciOverlay()
        statusText.text = "Generating clinical note..."
        transcriptText.text = "AI is extracting relevant information..."

        val duration = (System.currentTimeMillis() - ambientStartTime) / 1000 / 60
        val fullTranscript = ambientTranscriptBuffer.toString()

        // Store full transcript for audit/records (never goes to EHR)
        lastNoteTranscript = fullTranscript
        aciFullTranscriptRecord = fullTranscript  // Keep separate copy for records

        // Build entity context to help AI focus on relevant info
        val entityContext = buildEntityContextForAI()

        // Determine chief complaint with proper fallbacks
        val chiefComplaint = when {
            extractedEntities.chiefComplaints.isNotEmpty() -> extractedEntities.chiefComplaints.first()
            extractedEntities.symptoms.isNotEmpty() -> extractedEntities.symptoms.first()
            else -> {
                // Use first patient statement (strip any speaker labels)
                val patientText = extractedEntities.speakerSegments
                    .filter { it.speaker == "Patient" }
                    .firstOrNull()?.text
                    ?.replace(Regex("^\\s*\\[\\w+\\]\\s*"), "")
                    ?.trim()
                    ?.take(80)
                patientText ?: fullTranscript.replace(Regex("\\[\\w+\\]\\s*"), "").take(80)
            }
        }

        // Clean transcript for AI (strip speaker labels, keep content)
        val cleanTranscriptForAI = fullTranscript
            .replace(Regex("\\[Patient\\]\\s*"), "Patient: ")
            .replace(Regex("\\[Clinician\\]\\s*"), "Clinician: ")
            .replace(Regex("\\[Unknown\\]\\s*"), "")

        // Call AI service to generate focused clinical note
        Thread {
            try {
                val json = JSONObject().apply {
                    put("transcript", cleanTranscriptForAI)
                    put("chief_complaint", chiefComplaint)
                    put("note_type", "SOAP")
                    put("ambient_mode", true)
                    put("duration_minutes", duration)
                    // Include extracted entities as hints for AI
                    put("detected_entities", entityContext)
                    // Patient context
                    currentPatientData?.let { patient ->
                        put("patient_name", patient.optString("name"))
                        put("patient_age", patient.optString("age"))
                        put("patient_gender", patient.optString("gender"))
                    }
                }

                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/notes/quick")
                    .post(json.toString().toRequestBody("application/json".toMediaType()))
                    .build()

                httpClient.newCall(request).enqueue(object : Callback {
                    override fun onFailure(call: Call, e: IOException) {
                        Log.e(TAG, "ACI note generation error: ${e.message}")
                        runOnUiThread {
                            // Fallback to local entity-based note
                            generateLocalAciNote(duration)
                        }
                    }

                    override fun onResponse(call: Call, response: Response) {
                        val body = response.body?.string()
                        Log.d(TAG, "ACI AI note: $body")

                        runOnUiThread {
                            try {
                                val result = JSONObject(body ?: "{}")
                                lastGeneratedNote = result

                                val displayText = result.optString("display_text", "")
                                if (displayText.isNotBlank()) {
                                    editableNoteContent = displayText
                                    showNoteWithSaveOption("ACI Clinical Note", displayText)
                                    speakFeedback("Clinical note ready. ${duration} minute encounter.")
                                } else {
                                    generateLocalAciNote(duration)
                                }
                            } catch (e: Exception) {
                                generateLocalAciNote(duration)
                            }
                        }
                    }
                })
            } catch (e: Exception) {
                Log.e(TAG, "ACI note failed: ${e.message}")
                runOnUiThread {
                    generateLocalAciNote(duration)
                }
            }
        }.start()
    }

    // Store full transcript separately for audit (not sent to EHR)
    private var aciFullTranscriptRecord: String = ""

    /**
     * Build entity context JSON for AI to focus extraction
     */
    private fun buildEntityContextForAI(): String {
        val entities = JSONObject().apply {
            if (extractedEntities.chiefComplaints.isNotEmpty())
                put("chief_complaints", org.json.JSONArray(extractedEntities.chiefComplaints))
            if (extractedEntities.symptoms.isNotEmpty())
                put("symptoms", org.json.JSONArray(extractedEntities.symptoms))
            if (extractedEntities.medications.isNotEmpty())
                put("medications", org.json.JSONArray(extractedEntities.medications))
            if (extractedEntities.allergiesMentioned.isNotEmpty())
                put("allergies_mentioned", org.json.JSONArray(extractedEntities.allergiesMentioned))
            if (extractedEntities.vitalsMentioned.isNotEmpty())
                put("vitals", JSONObject(extractedEntities.vitalsMentioned.toMap()))
            if (extractedEntities.medicalHistory.isNotEmpty())
                put("medical_history", org.json.JSONArray(extractedEntities.medicalHistory))
            if (extractedEntities.assessments.isNotEmpty())
                put("assessments", org.json.JSONArray(extractedEntities.assessments))
            if (extractedEntities.plans.isNotEmpty())
                put("plans", org.json.JSONArray(extractedEntities.plans))
            if (extractedEntities.physicalExamFindings.isNotEmpty())
                put("exam_findings", org.json.JSONArray(extractedEntities.physicalExamFindings))
        }
        return entities.toString()
    }

    /**
     * Fallback: Generate note locally from extracted entities only (no raw transcript)
     * Enhanced to generate fuller SOAP notes even with limited data
     */
    private fun generateLocalAciNote(duration: Long) {
        val patientName = currentPatientData?.optString("name", "Patient") ?: "Patient"
        val patientAge = currentPatientData?.optString("age", "") ?: ""
        val patientGender = currentPatientData?.optString("gender", "") ?: ""
        val today = java.text.SimpleDateFormat("MM/dd/yyyy", java.util.Locale.US).format(java.util.Date())

        val noteBuilder = StringBuilder()
        noteBuilder.append("═══════════════════════════════════\n")
        noteBuilder.append("    CLINICAL ENCOUNTER NOTE\n")
        noteBuilder.append("═══════════════════════════════════\n\n")

        // Header with patient context
        noteBuilder.append("Date: $today\n")
        noteBuilder.append("Patient: $patientName")
        if (patientAge.isNotBlank()) noteBuilder.append(" | Age: $patientAge")
        if (patientGender.isNotBlank()) noteBuilder.append(" | $patientGender")
        noteBuilder.append("\n")
        noteBuilder.append("Encounter Duration: ${duration} minutes\n")
        noteBuilder.append("Documentation: Ambient AI-Assisted\n")
        noteBuilder.append("─".repeat(35) + "\n\n")

        // ═══ SUBJECTIVE ═══
        noteBuilder.append("SUBJECTIVE:\n")

        // Chief Complaint - use extracted entities, or first patient statement, or transcript summary
        noteBuilder.append("Chief Complaint: ")
        if (extractedEntities.chiefComplaints.isNotEmpty()) {
            noteBuilder.append(extractedEntities.chiefComplaints.first().replaceFirstChar { it.uppercase() })
        } else if (extractedEntities.symptoms.isNotEmpty()) {
            noteBuilder.append(extractedEntities.symptoms.first().replaceFirstChar { it.uppercase() })
        } else {
            // Fallback: use first patient statement from transcript
            val firstPatientStatement = extractedEntities.speakerSegments
                .filter { it.speaker == "Patient" }
                .firstOrNull()?.text
                ?.replace(Regex("^\\s*\\[\\w+\\]\\s*"), "")  // Strip speaker label
                ?.trim()
                ?.take(80)

            if (!firstPatientStatement.isNullOrBlank()) {
                noteBuilder.append(firstPatientStatement.replaceFirstChar { it.uppercase() })
            } else if (ambientTranscriptBuffer.isNotBlank()) {
                // Last resort: first part of transcript
                val firstSegment = ambientTranscriptBuffer.toString()
                    .replace(Regex("\\[\\w+\\]\\s*"), "")  // Remove speaker labels
                    .take(80)
                    .trim()
                if (firstSegment.isNotBlank()) {
                    noteBuilder.append(firstSegment.replaceFirstChar { it.uppercase() })
                } else {
                    noteBuilder.append("[Per encounter]")
                }
            } else {
                noteBuilder.append("[Per encounter]")
            }
        }
        noteBuilder.append("\n\n")

        // History of Present Illness
        noteBuilder.append("HPI: ")
        if (extractedEntities.symptoms.isNotEmpty()) {
            val symptomList = extractedEntities.symptoms.take(5)
            val durationMentioned = extractedEntities.speakerSegments
                .filter { it.speaker == "Patient" }
                .map { it.text.lowercase() }
                .firstOrNull { it.contains("day") || it.contains("week") || it.contains("month") }

            noteBuilder.append("$patientName presents with ${symptomList.joinToString(", ")}. ")
            if (durationMentioned != null) {
                noteBuilder.append("Patient reports symptoms ${extractDurationPhrase(durationMentioned)}. ")
            }

            // Build narrative from patient segments
            val patientStatements = extractedEntities.speakerSegments
                .filter { it.speaker == "Patient" }
                .take(3)
                .map { it.text }

            if (patientStatements.isNotEmpty() && patientStatements.any { it.length > 10 }) {
                // Strip any speaker labels from the quote
                val cleanQuote = patientStatements.first()
                    .replace(Regex("^\\s*\\[\\w+\\]\\s*"), "")  // Remove leading [Speaker]
                    .trim()
                if (cleanQuote.isNotBlank()) {
                    noteBuilder.append("Patient states: \"$cleanQuote\"")
                }
            }
        } else {
            noteBuilder.append("Patient presented for evaluation. Details per encounter discussion.")
        }
        noteBuilder.append("\n\n")

        // Past Medical History
        noteBuilder.append("PMH: ")
        if (extractedEntities.medicalHistory.isNotEmpty()) {
            noteBuilder.append(extractedEntities.medicalHistory.joinToString(", ") { it.replaceFirstChar { c -> c.uppercase() } })
        } else {
            // Pull from chart if available
            val conditions = currentPatientData?.optJSONArray("conditions")
            if (conditions != null && conditions.length() > 0) {
                val condList = mutableListOf<String>()
                for (i in 0 until minOf(conditions.length(), 5)) {
                    // Conditions can be JSONObjects or strings
                    val condName = try {
                        val condObj = conditions.getJSONObject(i)
                        condObj.optString("name", "")
                    } catch (e: Exception) {
                        conditions.optString(i, "")
                    }
                    if (condName.isNotBlank()) condList.add(condName)
                }
                if (condList.isNotEmpty()) {
                    noteBuilder.append("Per chart: ${condList.joinToString(", ")}")
                } else {
                    noteBuilder.append("See chart for complete history")
                }
            } else {
                noteBuilder.append("See chart for complete history")
            }
        }
        noteBuilder.append("\n")

        // Medications
        noteBuilder.append("Current Medications: ")
        if (extractedEntities.medications.isNotEmpty()) {
            noteBuilder.append(extractedEntities.medications.joinToString(", ") { it.replaceFirstChar { c -> c.uppercase() } })
        } else {
            noteBuilder.append("Per medication list in chart")
        }
        noteBuilder.append("\n")

        // Allergies from chart
        noteBuilder.append("Allergies: ")
        val allergies = currentPatientData?.optJSONArray("allergies")
        if (allergies != null && allergies.length() > 0) {
            val allergyList = mutableListOf<String>()
            for (i in 0 until allergies.length()) {
                // Allergies can be JSONObjects or strings
                val allergyName = try {
                    val allergyObj = allergies.getJSONObject(i)
                    allergyObj.optString("name", allergyObj.optString("substance", ""))
                } catch (e: Exception) {
                    allergies.optString(i, "")
                }
                if (allergyName.isNotBlank()) allergyList.add(allergyName)
            }
            if (allergyList.isNotEmpty()) {
                noteBuilder.append(allergyList.joinToString(", "))
            } else {
                noteBuilder.append("NKDA")
            }
        } else {
            noteBuilder.append("NKDA")
        }
        noteBuilder.append("\n")

        // Social History
        if (extractedEntities.socialHistory.isNotEmpty()) {
            noteBuilder.append("Social History: ${extractedEntities.socialHistory.joinToString("; ")}\n")
        }

        // Family History
        if (extractedEntities.familyHistory.isNotEmpty()) {
            noteBuilder.append("Family History: ${extractedEntities.familyHistory.joinToString("; ")}\n")
        }

        // Review of Systems
        noteBuilder.append("\nReview of Systems:\n")
        if (extractedEntities.reviewOfSystems.isNotEmpty()) {
            extractedEntities.reviewOfSystems.forEach { (system, findings) ->
                noteBuilder.append("  • ${system.replaceFirstChar { it.uppercase() }}: ${findings.joinToString(", ")}\n")
            }
        } else if (extractedEntities.symptoms.isNotEmpty()) {
            // Infer ROS from symptoms
            noteBuilder.append("  • Constitutional: Denies fever, chills, weight changes\n")
            noteBuilder.append("  • See HPI for pertinent positives\n")
        } else {
            noteBuilder.append("  • Reviewed and negative except as noted in HPI\n")
        }
        noteBuilder.append("\n")

        // ═══ OBJECTIVE ═══
        noteBuilder.append("OBJECTIVE:\n")

        // Vitals
        noteBuilder.append("Vital Signs: ")
        if (extractedEntities.vitalsMentioned.isNotEmpty()) {
            val vitalsList = extractedEntities.vitalsMentioned.map { (k, v) -> "$k: $v" }
            noteBuilder.append(vitalsList.joinToString(", "))
        } else {
            noteBuilder.append("See vital signs flowsheet")
        }
        noteBuilder.append("\n\n")

        // Physical Exam
        noteBuilder.append("Physical Examination:\n")
        if (extractedEntities.physicalExamFindings.isNotEmpty()) {
            extractedEntities.physicalExamFindings.forEach { finding ->
                noteBuilder.append("  • ${finding.replaceFirstChar { it.uppercase() }}\n")
            }
        } else {
            // Default exam based on symptoms
            noteBuilder.append("  • General: Alert, oriented, no acute distress\n")
            noteBuilder.append("  • Pertinent exam findings per encounter discussion\n")
        }
        noteBuilder.append("\n")

        // ═══ ASSESSMENT ═══
        noteBuilder.append("ASSESSMENT:\n")
        var diagnosisCount = 0
        if (extractedEntities.assessments.isNotEmpty()) {
            extractedEntities.assessments.forEachIndexed { idx, assessment ->
                diagnosisCount = idx + 1
                val icdCode = suggestIcdCode(assessment)
                noteBuilder.append("${idx + 1}. ${assessment.replaceFirstChar { it.uppercase() }}")
                if (icdCode != null) noteBuilder.append(" ($icdCode)")
                noteBuilder.append("\n")
            }
        } else if (extractedEntities.symptoms.isNotEmpty()) {
            // Create assessment from symptoms
            extractedEntities.symptoms.take(3).forEachIndexed { idx, symptom ->
                diagnosisCount = idx + 1
                val icdCode = suggestIcdCode(symptom)
                noteBuilder.append("${idx + 1}. ${symptom.replaceFirstChar { it.uppercase() }}")
                if (icdCode != null) noteBuilder.append(" ($icdCode)")
                noteBuilder.append("\n")
            }
        } else {
            noteBuilder.append("1. [Primary diagnosis per encounter]\n")
        }
        noteBuilder.append("\n")

        // ═══ PLAN ═══
        noteBuilder.append("PLAN:\n")
        if (extractedEntities.plans.isNotEmpty()) {
            extractedEntities.plans.forEachIndexed { idx, plan ->
                noteBuilder.append("${idx + 1}. ${plan.replaceFirstChar { it.uppercase() }}\n")
            }
        } else {
            // Generate plan items based on assessment
            noteBuilder.append("1. ")
            if (extractedEntities.medications.isNotEmpty()) {
                noteBuilder.append("Continue/adjust medications as discussed\n")
            } else {
                noteBuilder.append("Treatment plan discussed with patient\n")
            }
            noteBuilder.append("2. Follow up as needed\n")
            noteBuilder.append("3. Patient education provided\n")
        }

        if (extractedEntities.medications.isNotEmpty()) {
            noteBuilder.append("\nMedications Discussed: ${extractedEntities.medications.joinToString(", ")}\n")
        }

        // Footer
        noteBuilder.append("\n─".repeat(35))
        noteBuilder.append("\nDocumented via ambient capture. Review for accuracy.\n")
        noteBuilder.append("Entities extracted: ${countExtractedEntities()} | Segments: ${extractedEntities.speakerSegments.size}\n")

        editableNoteContent = noteBuilder.toString()
        showNoteWithSaveOption("ACI Clinical Note", noteBuilder.toString())
        statusText.text = "Note generated"
        transcriptText.text = "Say 'save note' or 'view transcript' for full record"
        speakFeedback("Clinical note ready for review")
    }

    /**
     * Extract duration phrase from text (e.g., "for 3 days", "since last week")
     */
    private fun extractDurationPhrase(text: String): String {
        val patterns = listOf(
            Regex("for (\\d+\\s*(?:day|week|month|hour|year)s?)"),
            Regex("since (yesterday|last \\w+|\\d+ \\w+ ago)"),
            Regex("(\\d+\\s*(?:day|week|month)s?) ago"),
            Regex("started (\\w+|\\d+ \\w+ ago)")
        )

        for (pattern in patterns) {
            val match = pattern.find(text)
            if (match != null) {
                return match.value
            }
        }
        return ""
    }

    /**
     * Suggest ICD-10 code for a diagnosis/symptom
     */
    private fun suggestIcdCode(text: String): String? {
        val lower = text.lowercase()
        return when {
            lower.contains("fever") -> "R50.9"
            lower.contains("headache") -> "R51.9"
            lower.contains("cough") -> "R05.9"
            lower.contains("chest pain") -> "R07.9"
            lower.contains("abdominal pain") || lower.contains("stomach") -> "R10.9"
            lower.contains("nausea") -> "R11.0"
            lower.contains("fatigue") || lower.contains("tired") -> "R53.83"
            lower.contains("hypertension") || lower.contains("high blood pressure") -> "I10"
            lower.contains("diabetes") -> "E11.9"
            lower.contains("anxiety") -> "F41.9"
            lower.contains("depression") -> "F32.9"
            lower.contains("back pain") -> "M54.5"
            lower.contains("sore throat") || lower.contains("pharyngitis") -> "J02.9"
            lower.contains("upper respiratory") || lower.contains("cold") || lower.contains("uri") -> "J06.9"
            lower.contains("shortness of breath") || lower.contains("dyspnea") -> "R06.0"
            lower.contains("dizziness") -> "R42"
            lower.contains("pain") -> "R52"
            else -> null
        }
    }

    /**
     * Count total extracted entities for summary
     */
    private fun countExtractedEntities(): Int {
        return extractedEntities.chiefComplaints.size +
               extractedEntities.symptoms.size +
               extractedEntities.medications.size +
               extractedEntities.assessments.size +
               extractedEntities.plans.size +
               extractedEntities.vitalsMentioned.size +
               extractedEntities.physicalExamFindings.size
    }

    /**
     * Extract chief complaint from raw transcript text
     */
    private fun extractChiefComplaintFromText(transcript: String): String {
        val corrected = correctMedicalTerms(transcript.lowercase())

        // Check for chief complaint triggers
        for (trigger in chiefComplaintTriggers) {
            if (corrected.contains(trigger)) {
                val complaint = extractPhraseAfter(corrected, trigger)
                if (complaint.isNotBlank()) {
                    return complaint.take(80).replaceFirstChar { it.uppercase() }
                }
            }
        }

        // Check for symptoms
        for (symptom in symptomPatterns) {
            if (corrected.contains(symptom)) {
                return symptom.replaceFirstChar { it.uppercase() }
            }
        }

        // Fallback: use first meaningful part of transcript
        val cleanedTranscript = transcript
            .replace(Regex("\\[\\w+\\]\\s*"), "")  // Remove speaker labels
            .trim()
            .take(80)

        return if (cleanedTranscript.isNotBlank()) {
            cleanedTranscript.replaceFirstChar { it.uppercase() }
        } else {
            "Per patient encounter"
        }
    }

    /**
     * View full transcript for records (not sent to EHR)
     */
    private fun viewFullTranscript() {
        val transcript = if (aciFullTranscriptRecord.isNotBlank()) {
            aciFullTranscriptRecord
        } else if (!lastNoteTranscript.isNullOrBlank()) {
            lastNoteTranscript!!
        } else {
            "No transcript available"
        }

        val duration = extractedEntities.speakerSegments.size
        val header = "═══ FULL ENCOUNTER TRANSCRIPT ═══\n" +
                     "For records only - NOT sent to EHR\n" +
                     "Segments: $duration\n" +
                     "─".repeat(35) + "\n\n"

        showDataOverlay("📝 Full Transcript", header + transcript)
        speakFeedback("Showing full transcript for records")
    }

    /**
     * Show ACI entities summary (without generating note)
     */
    private fun showAciEntities() {
        if (!extractedEntities.hasEntities()) {
            Toast.makeText(this, "No entities detected yet", Toast.LENGTH_SHORT).show()
            return
        }

        val sb = StringBuilder()
        sb.append("═══ DETECTED CLINICAL ENTITIES ═══\n\n")

        sb.append("Chief Complaints: ${extractedEntities.chiefComplaints.size}\n")
        sb.append("Symptoms: ${extractedEntities.symptoms.size}\n")
        sb.append("Medications: ${extractedEntities.medications.size}\n")
        sb.append("Vitals: ${extractedEntities.vitalsMentioned.size}\n")
        sb.append("Allergies: ${extractedEntities.allergiesMentioned.size}\n")
        sb.append("Medical History: ${extractedEntities.medicalHistory.size}\n")
        sb.append("Assessments: ${extractedEntities.assessments.size}\n")
        sb.append("Plan Items: ${extractedEntities.plans.size}\n\n")

        sb.append("Say 'generate note' to create documentation\n")
        sb.append("Say 'stop ambient' to end listening")

        showDataOverlay("ACI Summary", sb.toString())
    }

    private fun showTranscriptionCompleteOverlay(transcript: String) {
        hideLiveTranscriptionOverlay()

        // Store for voice command access
        pendingTranscript = transcript

        // Analyze the transcript for preview
        val analysis = analyzeTranscript(transcript)

        val rootView = window.decorView.findViewById<android.view.ViewGroup>(android.R.id.content)

        dataOverlay = android.widget.FrameLayout(this).apply {
            setBackgroundColor(0xEE0A1628.toInt())
            isClickable = true

            val innerLayout = android.widget.LinearLayout(context).apply {
                orientation = android.widget.LinearLayout.VERTICAL
                setPadding(32, 32, 32, 32)
                layoutParams = android.widget.FrameLayout.LayoutParams(
                    android.widget.FrameLayout.LayoutParams.MATCH_PARENT,
                    android.widget.FrameLayout.LayoutParams.MATCH_PARENT
                )
            }

            // Title
            val title = TextView(context).apply {
                text = "📋 TRANSCRIPT PREVIEW"
                textSize = getTitleFontSize()
                setTextColor(0xFF10B981.toInt())
                setPadding(0, 0, 0, 8)
            }
            innerLayout.addView(title)

            // Stats row
            val statsText = TextView(context).apply {
                text = "📊 ${analysis.wordCount} words • ~${analysis.estimatedMinutes} min • ${getNoteTypeDisplayName()}"
                textSize = getContentFontSize() - 2f
                setTextColor(0xFF94A3B8.toInt())
                setPadding(0, 0, 0, 12)
            }
            innerLayout.addView(statsText)

            // Detected topics (if any)
            if (analysis.detectedTopics.isNotEmpty()) {
                val topicsLayout = android.widget.LinearLayout(context).apply {
                    orientation = android.widget.LinearLayout.VERTICAL
                    setBackgroundColor(0xFF1E293B.toInt())
                    setPadding(16, 12, 16, 12)
                    val params = android.widget.LinearLayout.LayoutParams(
                        android.widget.LinearLayout.LayoutParams.MATCH_PARENT,
                        android.widget.LinearLayout.LayoutParams.WRAP_CONTENT
                    )
                    params.bottomMargin = 12
                    layoutParams = params
                }

                val topicsTitle = TextView(context).apply {
                    text = "🔍 Key Topics Detected:"
                    textSize = getContentFontSize() - 1f
                    setTextColor(0xFF60A5FA.toInt())
                    setPadding(0, 0, 0, 4)
                }
                topicsLayout.addView(topicsTitle)

                val topicsList = TextView(context).apply {
                    text = analysis.detectedTopics.joinToString(" • ")
                    textSize = getContentFontSize() - 2f
                    setTextColor(0xFFE2E8F0.toInt())
                }
                topicsLayout.addView(topicsList)

                innerLayout.addView(topicsLayout)
            }

            // Transcript preview label
            val previewLabel = TextView(context).apply {
                text = "📝 Transcript:"
                textSize = getContentFontSize() - 1f
                setTextColor(0xFF94A3B8.toInt())
                setPadding(0, 0, 0, 4)
            }
            innerLayout.addView(previewLabel)

            // Scrollable transcript
            val scrollView = android.widget.ScrollView(context).apply {
                layoutParams = android.widget.LinearLayout.LayoutParams(
                    android.widget.LinearLayout.LayoutParams.MATCH_PARENT, 0, 1f
                )
                setBackgroundColor(0xFF1E293B.toInt())
                setPadding(12, 12, 12, 12)
            }

            val contentText = TextView(context).apply {
                text = transcript
                textSize = getContentFontSize()
                setTextColor(0xFFF8FAFC.toInt())
                setLineSpacing(4f, 1.2f)
            }
            scrollView.addView(contentText)
            innerLayout.addView(scrollView)

            // Hint text
            val hintText = TextView(context).apply {
                text = "💡 Say \"generate note\", \"re-record\", or \"close\""
                textSize = getContentFontSize() - 3f
                setTextColor(0xFF64748B.toInt())
                setPadding(0, 8, 0, 8)
                gravity = android.view.Gravity.CENTER
            }
            innerLayout.addView(hintText)

            // Button row
            val buttonRow = android.widget.LinearLayout(context).apply {
                orientation = android.widget.LinearLayout.HORIZONTAL
                setPadding(0, 8, 0, 0)
            }

            val generateNoteBtn = android.widget.Button(context).apply {
                text = "✓ GENERATE"
                setBackgroundColor(0xFF10B981.toInt())
                setTextColor(0xFFFFFFFF.toInt())
                textSize = 14f
                layoutParams = android.widget.LinearLayout.LayoutParams(0, android.widget.LinearLayout.LayoutParams.WRAP_CONTENT, 1f).apply {
                    marginEnd = 4
                }
                setOnClickListener {
                    hideDataOverlay()
                    generateClinicalNote(transcript)
                }
            }
            buttonRow.addView(generateNoteBtn)

            val reRecordBtn = android.widget.Button(context).apply {
                text = "🔄 RE-RECORD"
                setBackgroundColor(0xFFF59E0B.toInt())
                setTextColor(0xFFFFFFFF.toInt())
                textSize = 14f
                layoutParams = android.widget.LinearLayout.LayoutParams(0, android.widget.LinearLayout.LayoutParams.WRAP_CONTENT, 1f).apply {
                    marginStart = 4
                    marginEnd = 4
                }
                setOnClickListener {
                    hideDataOverlay()
                    toggleLiveTranscription() // Start new transcription
                }
            }
            buttonRow.addView(reRecordBtn)

            val closeBtn = android.widget.Button(context).apply {
                text = "✕ CLOSE"
                setBackgroundColor(0xFF475569.toInt())
                setTextColor(0xFFFFFFFF.toInt())
                textSize = 14f
                layoutParams = android.widget.LinearLayout.LayoutParams(0, android.widget.LinearLayout.LayoutParams.WRAP_CONTENT, 1f).apply {
                    marginStart = 4
                }
                setOnClickListener { hideDataOverlay() }
            }
            buttonRow.addView(closeBtn)

            innerLayout.addView(buttonRow)
            addView(innerLayout)
        }

        rootView.addView(dataOverlay)
        statusText.text = "Review Transcript"
        transcriptText.text = "${analysis.wordCount} words captured"
    }

    /**
     * Analyze transcript to extract useful preview information
     */
    private data class TranscriptAnalysis(
        val wordCount: Int,
        val estimatedMinutes: Int,
        val detectedTopics: List<String>
    )

    private fun analyzeTranscript(transcript: String): TranscriptAnalysis {
        val words = transcript.split(Regex("\\s+")).filter { it.isNotBlank() }
        val wordCount = words.size
        // Average speaking rate is ~150 words per minute
        val estimatedMinutes = maxOf(1, (wordCount / 150.0).toInt())

        // Detect medical topics from transcript
        val topics = mutableListOf<String>()
        val lower = transcript.lowercase()

        // Symptoms & complaints
        if (lower.contains("pain") || lower.contains("hurt") || lower.contains("ache")) topics.add("Pain")
        if (lower.contains("headache") || lower.contains("migraine")) topics.add("Headache")
        if (lower.contains("fever") || lower.contains("temperature")) topics.add("Fever")
        if (lower.contains("cough") || lower.contains("cold") || lower.contains("congestion")) topics.add("Respiratory")
        if (lower.contains("nausea") || lower.contains("vomit") || lower.contains("diarrhea")) topics.add("GI symptoms")
        if (lower.contains("dizzy") || lower.contains("vertigo") || lower.contains("lightheaded")) topics.add("Dizziness")
        if (lower.contains("fatigue") || lower.contains("tired") || lower.contains("weak")) topics.add("Fatigue")
        if (lower.contains("rash") || lower.contains("itch") || lower.contains("skin")) topics.add("Skin")
        if (lower.contains("chest pain") || lower.contains("palpitation") || lower.contains("shortness of breath")) topics.add("Cardiac")
        if (lower.contains("anxiety") || lower.contains("depress") || lower.contains("stress")) topics.add("Mental health")

        // Conditions
        if (lower.contains("diabetes") || lower.contains("blood sugar") || lower.contains("glucose")) topics.add("Diabetes")
        if (lower.contains("hypertension") || lower.contains("blood pressure") || lower.contains("bp")) topics.add("Hypertension")
        if (lower.contains("asthma") || lower.contains("inhaler") || lower.contains("wheez")) topics.add("Asthma")

        // Procedures/actions
        if (lower.contains("exam") || lower.contains("physical")) topics.add("Physical exam")
        if (lower.contains("lab") || lower.contains("blood test") || lower.contains("bloodwork")) topics.add("Lab work")
        if (lower.contains("x-ray") || lower.contains("ct scan") || lower.contains("mri") || lower.contains("imaging")) topics.add("Imaging")
        if (lower.contains("prescri") || lower.contains("medication") || lower.contains("refill")) topics.add("Prescription")
        if (lower.contains("follow up") || lower.contains("follow-up") || lower.contains("return visit")) topics.add("Follow-up")

        return TranscriptAnalysis(
            wordCount = wordCount,
            estimatedMinutes = estimatedMinutes,
            detectedTopics = topics.take(5) // Limit to top 5 topics
        )
    }

    private fun generateClinicalNote(transcript: String) {
        val noteTypeDisplay = getNoteTypeDisplayName()
        statusText.text = "Generating $noteTypeDisplay..."
        transcriptText.text = "Processing transcript"

        // Extract chief complaint from transcript
        val chiefComplaint = extractChiefComplaintFromText(transcript)

        Thread {
            try {
                val json = JSONObject().apply {
                    put("transcript", transcript)
                    put("chief_complaint", chiefComplaint)
                    put("note_type", currentNoteType)
                }

                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/notes/quick")
                    .post(json.toString().toRequestBody("application/json".toMediaType()))
                    .build()

                httpClient.newCall(request).enqueue(object : Callback {
                    override fun onFailure(call: Call, e: IOException) {
                        Log.e(TAG, "Note generation error: ${e.message}")
                        runOnUiThread {
                            showDataOverlay("Note Generation Failed", "Error: ${e.message}")
                        }
                    }

                    override fun onResponse(call: Call, response: Response) {
                        val body = response.body?.string()
                        Log.d(TAG, "Generated note: $body")

                        runOnUiThread {
                            try {
                                val result = JSONObject(body ?: "{}")
                                // Store for later saving
                                lastGeneratedNote = result
                                lastNoteTranscript = transcript

                                var displayText = result.optString("display_text", "No note generated")

                                // Check if note type was auto-detected
                                if (result.optBoolean("auto_detected", false)) {
                                    val detectedType = result.optString("note_type", "SOAP")
                                    val confidence = result.optInt("detection_confidence", 0)
                                    val reason = result.optString("detection_reason", "")
                                    val detectedName = getDisplayNameForType(detectedType)

                                    // Prepend auto-detection info
                                    displayText = "🤖 Auto-detected: $detectedName ($confidence% confidence)\n" +
                                            "Reason: $reason\n" +
                                            "─".repeat(25) + "\n\n" +
                                            displayText

                                    showNoteWithSaveOption("$detectedName (Auto)", displayText)
                                    speakFeedback("$detectedName generated")
                                } else {
                                    showNoteWithSaveOption(noteTypeDisplay, displayText)
                                    speakFeedback("$noteTypeDisplay generated")
                                }
                            } catch (e: Exception) {
                                showDataOverlay(noteTypeDisplay, body ?: "No response")
                                speakFeedback("Error generating note")
                            }
                        }
                    }
                })
            } catch (e: Exception) {
                Log.e(TAG, "Failed to generate note: ${e.message}")
                runOnUiThread {
                    showDataOverlay("Error", "Failed: ${e.message}")
                }
            }
        }.start()
    }

    private fun getNoteTypeDisplayName(): String {
        return when (currentNoteType.uppercase()) {
            "SOAP" -> "SOAP Note"
            "PROGRESS" -> "Progress Note"
            "HP" -> "H&P Note"
            "CONSULT" -> "Consult Note"
            "AUTO" -> "Auto-Detect Note"
            else -> "Clinical Note"
        }
    }

    private fun getDisplayNameForType(noteType: String): String {
        return when (noteType.uppercase()) {
            "SOAP" -> "SOAP Note"
            "PROGRESS" -> "Progress Note"
            "HP" -> "H&P Note"
            "CONSULT" -> "Consult Note"
            else -> "Clinical Note"
        }
    }

    private fun setNoteType(noteType: String) {
        currentNoteType = noteType.uppercase()
        val displayName = getNoteTypeDisplayName()
        Toast.makeText(this, "Note type: $displayName", Toast.LENGTH_SHORT).show()
        transcriptText.text = "Note type: $displayName"
        Log.d(TAG, "Note type set to $currentNoteType")
    }

    private fun showNoteWithSaveOption(title: String, content: String) {
        // Remove existing overlay if any
        dataOverlay?.let { (it.parent as? android.view.ViewGroup)?.removeView(it) }

        // Store original content for editing
        editableNoteContent = content
        isNoteEditing = false

        val rootView = window.decorView.findViewById<android.view.ViewGroup>(android.R.id.content)

        dataOverlay = android.widget.FrameLayout(this).apply {
            // Light background for AR glasses visibility
            setBackgroundColor(0xFFF8FAFC.toInt())
            isClickable = true

            val innerLayout = android.widget.LinearLayout(context).apply {
                orientation = android.widget.LinearLayout.VERTICAL
                setPadding(32, 32, 32, 32)
                layoutParams = android.widget.FrameLayout.LayoutParams(
                    android.widget.FrameLayout.LayoutParams.MATCH_PARENT,
                    android.widget.FrameLayout.LayoutParams.MATCH_PARENT
                )
            }

            // Title row with edit indicator
            val titleRow = android.widget.LinearLayout(context).apply {
                orientation = android.widget.LinearLayout.HORIZONTAL
                setPadding(0, 0, 0, 16)
            }

            val titleText = TextView(context).apply {
                text = title
                textSize = getTitleFontSize()
                // Dark green title for light background
                setTextColor(0xFF059669.toInt())
                layoutParams = android.widget.LinearLayout.LayoutParams(0, android.widget.LinearLayout.LayoutParams.WRAP_CONTENT, 1f)
            }
            titleRow.addView(titleText)

            // Edit mode indicator
            val editIndicator = TextView(context).apply {
                text = "📝 EDITABLE"
                textSize = 14f
                // Dark blue for light background
                setTextColor(0xFF1D4ED8.toInt())
            }
            titleRow.addView(editIndicator)
            innerLayout.addView(titleRow)

            // Hint text for editing
            val hintText = TextView(context).apply {
                text = "Tap note to edit before saving"
                textSize = 12f
                // Dark hint text for light background
                setTextColor(0xFF475569.toInt())
                setPadding(0, 0, 0, 8)
            }
            innerLayout.addView(hintText)

            // Scrollable editable content
            val scrollView = android.widget.ScrollView(context).apply {
                layoutParams = android.widget.LinearLayout.LayoutParams(
                    android.widget.LinearLayout.LayoutParams.MATCH_PARENT, 0, 1f
                )
                // White background for AR glasses visibility
                setBackgroundColor(0xFFFFFFFF.toInt())
            }

            // EditText for editable note content
            noteEditText = android.widget.EditText(context).apply {
                setText(content)
                textSize = getContentFontSize()
                // Dark text on light background for AR visibility
                setTextColor(0xFF0F172A.toInt())
                setHintTextColor(0xFF64748B.toInt())
                setLineSpacing(4f, 1.2f)
                setBackgroundColor(0x00000000) // Transparent background
                setPadding(16, 16, 16, 16)
                gravity = android.view.Gravity.TOP or android.view.Gravity.START
                inputType = android.text.InputType.TYPE_CLASS_TEXT or
                        android.text.InputType.TYPE_TEXT_FLAG_MULTI_LINE or
                        android.text.InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS
                isSingleLine = false
                minLines = 10

                // Track when user edits
                addTextChangedListener(object : android.text.TextWatcher {
                    override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
                    override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
                        isNoteEditing = true
                        editableNoteContent = s?.toString()
                    }
                    override fun afterTextChanged(s: android.text.Editable?) {}
                })
            }
            scrollView.addView(noteEditText)
            innerLayout.addView(scrollView)

            // Track for voice navigation
            currentScrollView = scrollView

            // Button row with Edit actions, Save, and Close
            val buttonRow = android.widget.LinearLayout(context).apply {
                orientation = android.widget.LinearLayout.HORIZONTAL
                setPadding(0, 16, 0, 0)
            }

            // Reset button (restore original)
            val resetButton = android.widget.Button(context).apply {
                text = "↩ RESET"
                setBackgroundColor(0xFF6366F1.toInt())
                setTextColor(0xFFFFFFFF.toInt())
                textSize = 14f
                layoutParams = android.widget.LinearLayout.LayoutParams(0, android.widget.LinearLayout.LayoutParams.WRAP_CONTENT, 0.8f).apply {
                    marginEnd = 4
                }
                setOnClickListener {
                    noteEditText?.setText(content)
                    editableNoteContent = content
                    isNoteEditing = false
                    Toast.makeText(context, "Note reset to original", Toast.LENGTH_SHORT).show()
                }
            }
            buttonRow.addView(resetButton)

            val saveButton = android.widget.Button(context).apply {
                text = "💾 SAVE"
                setBackgroundColor(0xFF22C55E.toInt())
                setTextColor(0xFFFFFFFF.toInt())
                textSize = 14f
                layoutParams = android.widget.LinearLayout.LayoutParams(0, android.widget.LinearLayout.LayoutParams.WRAP_CONTENT, 1f).apply {
                    marginStart = 4
                    marginEnd = 4
                }
                setOnClickListener { saveCurrentNote() }
            }
            buttonRow.addView(saveButton)

            val closeButton = android.widget.Button(context).apply {
                text = "CLOSE"
                setBackgroundColor(0xFF475569.toInt())
                setTextColor(0xFFFFFFFF.toInt())
                textSize = 14f
                layoutParams = android.widget.LinearLayout.LayoutParams(0, android.widget.LinearLayout.LayoutParams.WRAP_CONTENT, 0.8f).apply {
                    marginStart = 4
                }
                setOnClickListener {
                    // Warn if there are unsaved edits
                    if (isNoteEditing) {
                        confirmDiscardEdits()
                    } else {
                        hideDataOverlay()
                    }
                }
            }
            buttonRow.addView(closeButton)

            innerLayout.addView(buttonRow)
            addView(innerLayout)
        }

        rootView.addView(dataOverlay)
        statusText.text = title
        transcriptText.text = "Edit note, then 'save note' or 'close'"
    }

    private fun confirmDiscardEdits() {
        android.app.AlertDialog.Builder(this)
            .setTitle("Unsaved Changes")
            .setMessage("You have unsaved edits. Discard changes?")
            .setPositiveButton("Discard") { _, _ ->
                isNoteEditing = false
                editableNoteContent = null
                noteEditText = null
                hideDataOverlay()
            }
            .setNegativeButton("Keep Editing", null)
            .show()
    }

    private fun resetNoteEdits() {
        val note = lastGeneratedNote
        if (note == null || noteEditText == null) {
            Toast.makeText(this, "No note to reset", Toast.LENGTH_SHORT).show()
            return
        }

        val originalContent = note.optString("display_text", "")
        noteEditText?.setText(originalContent)
        editableNoteContent = originalContent
        isNoteEditing = false
        Toast.makeText(this, "Note reset to original", Toast.LENGTH_SHORT).show()
        transcriptText.text = "Note restored"
        Log.d(TAG, "Note edits reset to original")
    }

    private fun focusNoteEdit() {
        if (noteEditText == null) {
            Toast.makeText(this, "No note open for editing", Toast.LENGTH_SHORT).show()
            return
        }

        // Focus on EditText and show keyboard
        noteEditText?.requestFocus()
        val imm = getSystemService(Context.INPUT_METHOD_SERVICE) as android.view.inputmethod.InputMethodManager
        imm.showSoftInput(noteEditText, android.view.inputmethod.InputMethodManager.SHOW_IMPLICIT)
        Toast.makeText(this, "Editing note...", Toast.LENGTH_SHORT).show()
        transcriptText.text = "Tap to edit note text"
        Log.d(TAG, "Note edit focused")
    }

    // ============ Voice Note Editing Functions ============

    /**
     * Push current state to edit history for undo functionality.
     */
    private fun pushEditHistory() {
        editableNoteContent?.let {
            editHistory.add(it)
            if (editHistory.size > MAX_EDIT_HISTORY) {
                editHistory.removeAt(0)
            }
            Log.d(TAG, "Pushed to edit history (${editHistory.size} states)")
        }
    }

    /**
     * Undo the last edit by restoring previous state.
     */
    private fun undoLastEdit(): Boolean {
        if (editHistory.isEmpty()) {
            Toast.makeText(this, "Nothing to undo", Toast.LENGTH_SHORT).show()
            speakFeedback("Nothing to undo")
            return false
        }

        val previous = editHistory.removeLast()
        noteEditText?.setText(previous)
        editableNoteContent = previous
        isNoteEditing = editHistory.isNotEmpty()
        Toast.makeText(this, "Change undone", Toast.LENGTH_SHORT).show()
        speakFeedback("Change undone")
        Log.d(TAG, "Undid last edit (${editHistory.size} states remaining)")
        return true
    }

    /**
     * Resolve spoken section name to canonical section name.
     */
    private fun resolveSection(spoken: String): String? {
        val lower = spoken.lowercase()
        for ((canonical, aliases) in sectionAliases) {
            if (aliases.any { lower.contains(it) }) {
                return canonical
            }
        }
        return null
    }

    /**
     * Get the regex pattern for a SOAP section.
     */
    private fun getSectionPattern(section: String): Regex {
        return when (section) {
            "subjective" -> Regex("(▸ S(?:UBJECTIVE)?:?)([\\s\\S]*?)(?=\\n▸ [OAP]|\\n▸ ICD|$)", RegexOption.IGNORE_CASE)
            "objective" -> Regex("(▸ O(?:BJECTIVE)?:?)([\\s\\S]*?)(?=\\n▸ [AP]|\\n▸ ICD|$)", RegexOption.IGNORE_CASE)
            "assessment" -> Regex("(▸ A(?:SSESSMENT)?:?)([\\s\\S]*?)(?=\\n▸ P|\\n▸ ICD|$)", RegexOption.IGNORE_CASE)
            "plan" -> Regex("(▸ P(?:LAN)?:?)([\\s\\S]*?)(?=\\n▸ ICD|\\n▸ CPT|\\n═|$)", RegexOption.IGNORE_CASE)
            else -> Regex("($section:?)([\\s\\S]*?)(?=\\n▸|\\n═|$)", RegexOption.IGNORE_CASE)
        }
    }

    /**
     * Update a note section with new content (replace).
     */
    private fun updateNoteSection(section: String, newContent: String) {
        if (noteEditText == null || editableNoteContent == null) {
            Toast.makeText(this, "No note open. Generate a note first.", Toast.LENGTH_SHORT).show()
            speakFeedback("No note open")
            return
        }

        val canonicalSection = resolveSection(section)
        if (canonicalSection == null) {
            Toast.makeText(this, "Unknown section: $section", Toast.LENGTH_SHORT).show()
            speakFeedback("Unknown section")
            return
        }

        // Push to history before making changes
        pushEditHistory()

        val current = editableNoteContent ?: ""
        val pattern = getSectionPattern(canonicalSection)
        val sectionLabel = when (canonicalSection) {
            "subjective" -> "▸ S:"
            "objective" -> "▸ O:"
            "assessment" -> "▸ A:"
            "plan" -> "▸ P:"
            else -> "▸ ${canonicalSection.uppercase()}:"
        }

        val updated = if (pattern.containsMatchIn(current)) {
            current.replace(pattern) { matchResult ->
                "${matchResult.groupValues[1]}\n$newContent\n"
            }
        } else {
            // Section not found, append at end
            "$current\n$sectionLabel\n$newContent\n"
        }

        noteEditText?.setText(updated)
        editableNoteContent = updated
        isNoteEditing = true

        val sectionName = canonicalSection.replaceFirstChar { it.uppercase() }
        Toast.makeText(this, "$sectionName updated", Toast.LENGTH_SHORT).show()
        speakFeedback("$sectionName updated")
        transcriptText.text = "Changed $sectionName"
        Log.d(TAG, "Updated section $canonicalSection")
    }

    /**
     * Append content to a note section.
     */
    private fun appendToNoteSection(section: String, content: String) {
        if (noteEditText == null || editableNoteContent == null) {
            Toast.makeText(this, "No note open. Generate a note first.", Toast.LENGTH_SHORT).show()
            speakFeedback("No note open")
            return
        }

        val canonicalSection = resolveSection(section)
        if (canonicalSection == null) {
            Toast.makeText(this, "Unknown section: $section", Toast.LENGTH_SHORT).show()
            speakFeedback("Unknown section")
            return
        }

        // Push to history before making changes
        pushEditHistory()

        val current = editableNoteContent ?: ""
        val pattern = getSectionPattern(canonicalSection)

        val updated = if (pattern.containsMatchIn(current)) {
            current.replace(pattern) { matchResult ->
                val existingContent = matchResult.groupValues[2].trimEnd()
                "${matchResult.groupValues[1]}$existingContent\n$content\n"
            }
        } else {
            // Section not found, create it
            val sectionLabel = when (canonicalSection) {
                "subjective" -> "▸ S:"
                "objective" -> "▸ O:"
                "assessment" -> "▸ A:"
                "plan" -> "▸ P:"
                else -> "▸ ${canonicalSection.uppercase()}:"
            }
            "$current\n$sectionLabel\n$content\n"
        }

        noteEditText?.setText(updated)
        editableNoteContent = updated
        isNoteEditing = true

        val sectionName = canonicalSection.replaceFirstChar { it.uppercase() }
        Toast.makeText(this, "Added to $sectionName", Toast.LENGTH_SHORT).show()
        speakFeedback("Added to $sectionName")
        transcriptText.text = "Added to $sectionName"
        Log.d(TAG, "Appended to section $canonicalSection: $content")
    }

    /**
     * Delete the last sentence from the note.
     */
    private fun deleteLastSentence() {
        if (noteEditText == null || editableNoteContent == null) {
            Toast.makeText(this, "No note open", Toast.LENGTH_SHORT).show()
            return
        }

        // Push to history before making changes
        pushEditHistory()

        val current = editableNoteContent ?: ""
        // Find last sentence (ends with . ! or ?)
        val sentencePattern = Regex("[^.!?]*[.!?]\\s*$")
        val updated = current.replace(sentencePattern, "").trimEnd()

        if (updated == current) {
            // Try removing last line instead
            val lines = current.lines().dropLast(1)
            val updatedLines = lines.joinToString("\n")
            noteEditText?.setText(updatedLines)
            editableNoteContent = updatedLines
        } else {
            noteEditText?.setText(updated)
            editableNoteContent = updated
        }

        isNoteEditing = true
        Toast.makeText(this, "Last sentence deleted", Toast.LENGTH_SHORT).show()
        speakFeedback("Deleted")
        transcriptText.text = "Deleted last sentence"
        Log.d(TAG, "Deleted last sentence")
    }

    /**
     * Delete the last line from the note.
     */
    private fun deleteLastLine() {
        if (noteEditText == null || editableNoteContent == null) {
            Toast.makeText(this, "No note open", Toast.LENGTH_SHORT).show()
            return
        }

        // Push to history before making changes
        pushEditHistory()

        val current = editableNoteContent ?: ""
        val lines = current.lines().dropLast(1)
        val updated = lines.joinToString("\n")

        noteEditText?.setText(updated)
        editableNoteContent = updated
        isNoteEditing = true

        Toast.makeText(this, "Last line deleted", Toast.LENGTH_SHORT).show()
        speakFeedback("Line deleted")
        transcriptText.text = "Deleted last line"
        Log.d(TAG, "Deleted last line")
    }

    /**
     * Delete a specific item from a section (e.g., "delete plan item 2").
     */
    private fun deleteSectionItem(section: String, itemNumber: Int) {
        if (noteEditText == null || editableNoteContent == null) {
            Toast.makeText(this, "No note open", Toast.LENGTH_SHORT).show()
            return
        }

        val canonicalSection = resolveSection(section)
        if (canonicalSection == null) {
            Toast.makeText(this, "Unknown section: $section", Toast.LENGTH_SHORT).show()
            return
        }

        // Push to history before making changes
        pushEditHistory()

        val current = editableNoteContent ?: ""
        val pattern = getSectionPattern(canonicalSection)
        val match = pattern.find(current)

        if (match != null) {
            val sectionContent = match.groupValues[2]
            val lines = sectionContent.lines().filter { it.isNotBlank() }

            if (itemNumber in 1..lines.size) {
                val newLines = lines.toMutableList()
                newLines.removeAt(itemNumber - 1)
                val newContent = "\n" + newLines.joinToString("\n") + "\n"

                val updated = current.replace(pattern) { m ->
                    "${m.groupValues[1]}$newContent"
                }

                noteEditText?.setText(updated)
                editableNoteContent = updated
                isNoteEditing = true

                Toast.makeText(this, "Item $itemNumber deleted", Toast.LENGTH_SHORT).show()
                speakFeedback("Item $itemNumber deleted")
                transcriptText.text = "Deleted ${canonicalSection} item $itemNumber"
                Log.d(TAG, "Deleted item $itemNumber from $canonicalSection")
            } else {
                Toast.makeText(this, "Item $itemNumber not found", Toast.LENGTH_SHORT).show()
                speakFeedback("Item not found")
            }
        }
    }

    /**
     * Clear an entire section.
     */
    private fun clearSection(section: String) {
        if (noteEditText == null || editableNoteContent == null) {
            Toast.makeText(this, "No note open", Toast.LENGTH_SHORT).show()
            return
        }

        val canonicalSection = resolveSection(section)
        if (canonicalSection == null) {
            Toast.makeText(this, "Unknown section: $section", Toast.LENGTH_SHORT).show()
            return
        }

        // Push to history before making changes
        pushEditHistory()

        val current = editableNoteContent ?: ""
        val pattern = getSectionPattern(canonicalSection)

        val updated = current.replace(pattern) { matchResult ->
            "${matchResult.groupValues[1]}\n[Section cleared]\n"
        }

        noteEditText?.setText(updated)
        editableNoteContent = updated
        isNoteEditing = true

        val sectionName = canonicalSection.replaceFirstChar { it.uppercase() }
        Toast.makeText(this, "$sectionName cleared", Toast.LENGTH_SHORT).show()
        speakFeedback("$sectionName cleared")
        transcriptText.text = "Cleared $sectionName"
        Log.d(TAG, "Cleared section $canonicalSection")
    }

    /**
     * Insert a macro template into the note.
     */
    private fun insertMacro(macroName: String) {
        if (noteEditText == null || editableNoteContent == null) {
            Toast.makeText(this, "No note open", Toast.LENGTH_SHORT).show()
            return
        }

        val template = macroTemplates[macroName]
        if (template == null) {
            Toast.makeText(this, "Unknown macro: $macroName", Toast.LENGTH_SHORT).show()
            return
        }

        // Push to history before making changes
        pushEditHistory()

        // Determine which section to insert into based on macro type
        val targetSection = when (macroName) {
            "normal_exam", "normal_vitals" -> "objective"
            "negative_ros" -> "subjective"
            "follow_up", "diabetes_followup", "hypertension_followup" -> "plan"
            else -> "plan"
        }

        appendToNoteSection(targetSection, template)

        val macroLabel = macroName.replace("_", " ").replaceFirstChar { it.uppercase() }
        transcriptText.text = "Inserted $macroLabel"
        Log.d(TAG, "Inserted macro $macroName into $targetSection")
    }

    /**
     * Extract content after a keyword (e.g., "change assessment TO headache" -> "headache").
     */
    private fun extractContentAfter(text: String, keyword: String): String {
        val lower = text.lowercase()
        val keywordLower = keyword.lowercase()
        val index = lower.lastIndexOf(keywordLower)
        return if (index >= 0 && index + keyword.length < text.length) {
            text.substring(index + keyword.length).trim()
        } else {
            ""
        }
    }

    /**
     * Extract section name from voice command.
     */
    private fun extractSectionFromCommand(text: String): String? {
        val lower = text.lowercase()
        // Check for section keywords
        for ((canonical, aliases) in sectionAliases) {
            for (alias in aliases) {
                if (lower.contains(alias)) {
                    return canonical
                }
            }
        }
        return null
    }

    // ============ Voice Navigation Functions ============

    /**
     * Scroll the current view down by a page.
     */
    private fun scrollDown() {
        val scrollView = currentScrollView ?: liveTranscriptScrollView
        if (scrollView == null) {
            Toast.makeText(this, "Nothing to scroll", Toast.LENGTH_SHORT).show()
            return
        }

        scrollView.post {
            val scrollAmount = scrollView.height * 3 / 4  // Scroll 75% of visible height
            scrollView.smoothScrollBy(0, scrollAmount)
        }
        speakFeedback("Scrolling down")
        Log.d(TAG, "Voice navigation: scroll down")
    }

    /**
     * Scroll the current view up by a page.
     */
    private fun scrollUp() {
        val scrollView = currentScrollView ?: liveTranscriptScrollView
        if (scrollView == null) {
            Toast.makeText(this, "Nothing to scroll", Toast.LENGTH_SHORT).show()
            return
        }

        scrollView.post {
            val scrollAmount = scrollView.height * 3 / 4  // Scroll 75% of visible height
            scrollView.smoothScrollBy(0, -scrollAmount)
        }
        speakFeedback("Scrolling up")
        Log.d(TAG, "Voice navigation: scroll up")
    }

    /**
     * Scroll to the top of the current view.
     */
    private fun scrollToTop() {
        val scrollView = currentScrollView ?: liveTranscriptScrollView
        if (scrollView == null) {
            Toast.makeText(this, "Nothing to scroll", Toast.LENGTH_SHORT).show()
            return
        }

        scrollView.post {
            scrollView.smoothScrollTo(0, 0)
        }
        speakFeedback("Top of page")
        transcriptText.text = "Scrolled to top"
        Log.d(TAG, "Voice navigation: scroll to top")
    }

    /**
     * Scroll to the bottom of the current view.
     */
    private fun scrollToBottom() {
        val scrollView = currentScrollView ?: liveTranscriptScrollView
        if (scrollView == null) {
            Toast.makeText(this, "Nothing to scroll", Toast.LENGTH_SHORT).show()
            return
        }

        scrollView.post {
            scrollView.fullScroll(android.view.View.FOCUS_DOWN)
        }
        speakFeedback("Bottom of page")
        transcriptText.text = "Scrolled to bottom"
        Log.d(TAG, "Voice navigation: scroll to bottom")
    }

    /**
     * Navigate to a specific section in the note (scroll to section header).
     */
    private fun goToSection(section: String) {
        val content = editableNoteContent ?: currentContentText?.text?.toString()
        if (content == null) {
            Toast.makeText(this, "No content to navigate", Toast.LENGTH_SHORT).show()
            return
        }

        val scrollView = currentScrollView ?: liveTranscriptScrollView
        val textView = noteEditText ?: currentContentText
        if (scrollView == null || textView == null) {
            Toast.makeText(this, "Cannot navigate", Toast.LENGTH_SHORT).show()
            return
        }

        // Find section header in content
        val sectionPattern = when (section) {
            "subjective" -> Regex("(?:▸ S:|S:|SUBJECTIVE:)", RegexOption.IGNORE_CASE)
            "objective" -> Regex("(?:▸ O:|O:|OBJECTIVE:)", RegexOption.IGNORE_CASE)
            "assessment" -> Regex("(?:▸ A:|A:|ASSESSMENT:)", RegexOption.IGNORE_CASE)
            "plan" -> Regex("(?:▸ P:|P:|PLAN:)", RegexOption.IGNORE_CASE)
            else -> {
                Toast.makeText(this, "Unknown section: $section", Toast.LENGTH_SHORT).show()
                return
            }
        }

        val match = sectionPattern.find(content)
        if (match == null) {
            Toast.makeText(this, "Section not found: $section", Toast.LENGTH_SHORT).show()
            speakFeedback("Section not found")
            return
        }

        // Calculate scroll position based on character offset
        val charOffset = match.range.first
        val layout = textView.layout

        if (layout != null) {
            val line = layout.getLineForOffset(charOffset)
            val yPosition = layout.getLineTop(line)

            scrollView.post {
                scrollView.smoothScrollTo(0, yPosition)
            }

            val sectionName = section.replaceFirstChar { it.uppercase() }
            speakFeedback("$sectionName section")
            transcriptText.text = "Navigated to $sectionName"
            Log.d(TAG, "Voice navigation: go to $section at line $line")
        } else {
            // Fallback: just scroll to approximate position
            val approximatePosition = (charOffset.toFloat() / content.length * scrollView.getChildAt(0).height).toInt()
            scrollView.post {
                scrollView.smoothScrollTo(0, approximatePosition)
            }
            speakFeedback("$section section")
            Log.d(TAG, "Voice navigation: go to $section (approximate)")
        }
    }

    /**
     * Read back a specific section of the note using TTS.
     */
    private fun readSection(section: String) {
        val content = editableNoteContent ?: currentContentText?.text?.toString()
        if (content == null) {
            Toast.makeText(this, "No content to read", Toast.LENGTH_SHORT).show()
            return
        }

        // Extract section content
        val sectionContent = extractSectionContent(content, section)
        if (sectionContent.isNullOrEmpty()) {
            Toast.makeText(this, "Section not found: $section", Toast.LENGTH_SHORT).show()
            speakFeedback("Section not found")
            return
        }

        val sectionName = section.replaceFirstChar { it.uppercase() }
        transcriptText.text = "Reading $sectionName..."

        // Speak the section content
        textToSpeech?.speak("$sectionName. $sectionContent", TextToSpeech.QUEUE_FLUSH, null, "read_section")
        Log.d(TAG, "Voice navigation: reading $section section")
    }

    /**
     * Extract the content of a specific section from the note.
     */
    private fun extractSectionContent(content: String, section: String): String? {
        // Define patterns for section boundaries
        val sectionPatterns = mapOf(
            "subjective" to Regex("(?:▸ S:|S:|SUBJECTIVE:?)\\s*(.+?)(?=(?:\\n▸ [OAP]:|\\n[OAP]:|\\nOBJECTIVE:|\\nASSESSMENT:|\\nPLAN:|$))", setOf(RegexOption.DOT_MATCHES_ALL, RegexOption.IGNORE_CASE)),
            "objective" to Regex("(?:▸ O:|O:|OBJECTIVE:?)\\s*(.+?)(?=(?:\\n▸ [AP]:|\\n[AP]:|\\nASSESSMENT:|\\nPLAN:|$))", setOf(RegexOption.DOT_MATCHES_ALL, RegexOption.IGNORE_CASE)),
            "assessment" to Regex("(?:▸ A:|A:|ASSESSMENT:?)\\s*(.+?)(?=(?:\\n▸ P:|\\nP:|\\nPLAN:|$))", setOf(RegexOption.DOT_MATCHES_ALL, RegexOption.IGNORE_CASE)),
            "plan" to Regex("(?:▸ P:|P:|PLAN:?)\\s*(.+?)(?=(?:\\n▸|\\n═|$))", setOf(RegexOption.DOT_MATCHES_ALL, RegexOption.IGNORE_CASE))
        )

        val pattern = sectionPatterns[section] ?: return null
        val match = pattern.find(content)
        return match?.groupValues?.getOrNull(1)?.trim()
    }

    /**
     * Read the entire note using TTS.
     */
    private fun readEntireNote() {
        val content = editableNoteContent ?: currentContentText?.text?.toString()
        if (content == null) {
            Toast.makeText(this, "No content to read", Toast.LENGTH_SHORT).show()
            return
        }

        transcriptText.text = "Reading note..."

        // Clean up the content for speech (remove decorative characters)
        val cleanContent = content
            .replace("▸", "")
            .replace("═", "")
            .replace(Regex("─+"), "")
            .replace(Regex("\\s+"), " ")
            .trim()

        textToSpeech?.speak(cleanContent, TextToSpeech.QUEUE_FLUSH, null, "read_note")
        Log.d(TAG, "Voice navigation: reading entire note")
    }

    /**
     * Show only a specific section of the note (hide others).
     */
    private fun showSectionOnly(section: String) {
        val content = editableNoteContent ?: return

        val sectionContent = extractSectionContent(content, section)
        if (sectionContent.isNullOrEmpty()) {
            Toast.makeText(this, "Section not found: $section", Toast.LENGTH_SHORT).show()
            return
        }

        val sectionName = section.replaceFirstChar { it.uppercase() }
        val displayContent = "▸ ${sectionName.first()}:\n$sectionContent"

        showDataOverlay("$sectionName Section", displayContent)
        speakFeedback("$sectionName only")
        Log.d(TAG, "Voice navigation: showing $section only")
    }

    // ============ Voice Dictation Mode Functions ============

    /**
     * Start dictation mode for a specific note section.
     * All subsequent speech will be accumulated and inserted into the target section.
     */
    private fun startDictation(section: String) {
        if (noteEditText == null || editableNoteContent == null) {
            Toast.makeText(this, "Open a note first to dictate", Toast.LENGTH_SHORT).show()
            speakFeedback("Open a note first")
            return
        }

        // Validate section exists
        val resolvedSection = resolveSection(section)
        if (resolvedSection == null) {
            Toast.makeText(this, "Unknown section: $section", Toast.LENGTH_SHORT).show()
            speakFeedback("Unknown section")
            return
        }

        isDictationMode = true
        dictationTargetSection = resolvedSection
        dictationBuffer.clear()

        val sectionName = resolvedSection.replaceFirstChar { it.uppercase() }
        transcriptText.text = "🎙️ Dictating to $sectionName... Say 'stop dictating' when done"
        statusText.text = "DICTATION MODE: $sectionName"

        speakFeedback("Dictating to $sectionName. Speak now.")
        Toast.makeText(this, "Dictation started for $sectionName", Toast.LENGTH_SHORT).show()
        Log.d(TAG, "Dictation mode started for section: $resolvedSection")

        // Show visual indicator
        showDictationIndicator(sectionName)
    }

    /**
     * Stop dictation mode and insert accumulated text into the target section.
     */
    private fun stopDictation() {
        if (!isDictationMode) {
            Toast.makeText(this, "Not in dictation mode", Toast.LENGTH_SHORT).show()
            return
        }

        val section = dictationTargetSection
        val dictatedText = dictationBuffer.toString().trim()

        isDictationMode = false
        dictationTargetSection = null

        // Hide dictation indicator
        hideDictationIndicator()

        if (dictatedText.isEmpty()) {
            transcriptText.text = "Dictation ended (no text captured)"
            speakFeedback("No text captured")
            Log.d(TAG, "Dictation stopped with no text")
            return
        }

        if (section != null) {
            // Push to history before making changes
            pushEditHistory()

            // Append dictated text to the section
            appendToNoteSection(section, dictatedText)

            val sectionName = section.replaceFirstChar { it.uppercase() }
            val wordCount = dictatedText.split("\\s+".toRegex()).size
            transcriptText.text = "Added $wordCount words to $sectionName"
            speakFeedback("Added $wordCount words to $sectionName")
            Log.d(TAG, "Dictation complete: $wordCount words added to $section")
        }

        dictationBuffer.clear()
        statusText.text = "MDx Vision"
    }

    /**
     * Cancel dictation mode without inserting text.
     */
    private fun cancelDictation() {
        if (!isDictationMode) {
            Toast.makeText(this, "Not in dictation mode", Toast.LENGTH_SHORT).show()
            return
        }

        isDictationMode = false
        dictationTargetSection = null
        dictationBuffer.clear()

        hideDictationIndicator()

        transcriptText.text = "Dictation cancelled"
        statusText.text = "MDx Vision"
        speakFeedback("Dictation cancelled")
        Log.d(TAG, "Dictation cancelled")
    }

    /**
     * Add text to the dictation buffer (called during speech recognition in dictation mode).
     */
    private fun addToDictationBuffer(text: String) {
        if (!isDictationMode) return

        if (dictationBuffer.isNotEmpty()) {
            dictationBuffer.append(" ")
        }
        dictationBuffer.append(text)

        // Update display to show what's been captured
        val section = dictationTargetSection?.replaceFirstChar { it.uppercase() } ?: "Note"
        val wordCount = dictationBuffer.toString().split("\\s+".toRegex()).filter { it.isNotEmpty() }.size
        transcriptText.text = "🎙️ $section: $wordCount words captured\n\"${getLastWords(dictationBuffer.toString(), 10)}...\""

        Log.d(TAG, "Dictation buffer: ${dictationBuffer.length} chars, $wordCount words")
    }

    /**
     * Get the last N words from a string for preview.
     */
    private fun getLastWords(text: String, n: Int): String {
        val words = text.split("\\s+".toRegex()).filter { it.isNotEmpty() }
        return if (words.size <= n) {
            text
        } else {
            words.takeLast(n).joinToString(" ")
        }
    }

    /**
     * Show visual indicator for dictation mode.
     */
    private var dictationIndicator: android.widget.FrameLayout? = null

    private fun showDictationIndicator(sectionName: String) {
        // Remove existing indicator if any
        hideDictationIndicator()

        val rootView = window.decorView.findViewById<android.view.ViewGroup>(android.R.id.content)

        dictationIndicator = android.widget.FrameLayout(this).apply {
            setBackgroundColor(0xCC000000.toInt())

            val indicatorLayout = android.widget.LinearLayout(context).apply {
                orientation = android.widget.LinearLayout.VERTICAL
                gravity = android.view.Gravity.CENTER
                setPadding(32, 24, 32, 24)
                layoutParams = android.widget.FrameLayout.LayoutParams(
                    android.widget.FrameLayout.LayoutParams.MATCH_PARENT,
                    android.widget.FrameLayout.LayoutParams.WRAP_CONTENT
                ).apply {
                    gravity = android.view.Gravity.TOP
                }
            }

            // Recording indicator
            val recordingText = TextView(context).apply {
                text = "🎙️ DICTATING TO $sectionName"
                textSize = 18f
                setTextColor(0xFFEF4444.toInt())  // Red for recording
                gravity = android.view.Gravity.CENTER
                setPadding(0, 0, 0, 8)
            }
            indicatorLayout.addView(recordingText)

            // Instructions
            val instructionsText = TextView(context).apply {
                text = "Speak now • Say \"stop dictating\" when done"
                textSize = 14f
                setTextColor(0xFF94A3B8.toInt())
                gravity = android.view.Gravity.CENTER
            }
            indicatorLayout.addView(instructionsText)

            addView(indicatorLayout)

            // Tap to stop
            setOnClickListener {
                stopDictation()
            }
        }

        rootView.addView(dictationIndicator)
    }

    private fun hideDictationIndicator() {
        dictationIndicator?.let { indicator ->
            (indicator.parent as? android.view.ViewGroup)?.removeView(indicator)
            dictationIndicator = null
        }
    }

    /**
     * Check if currently in dictation mode.
     */
    private fun isInDictationMode(): Boolean = isDictationMode

    // ============ Voice Template Functions ============

    /**
     * Apply a template to the current note, replacing variables with patient data.
     */
    private fun applyTemplate(templateKey: String) {
        val template = builtInTemplates[templateKey] ?: getUserTemplate(templateKey)
        if (template == null) {
            Toast.makeText(this, "Template not found: $templateKey", Toast.LENGTH_SHORT).show()
            speakFeedback("Template not found")
            return
        }

        // Need a patient loaded for auto-fill
        val patient = currentPatientData
        if (patient == null) {
            Toast.makeText(this, "Load a patient first", Toast.LENGTH_SHORT).show()
            speakFeedback("Load a patient first to use templates")
            return
        }

        // Replace variables with patient data
        val filledContent = fillTemplateVariables(template.content, patient)

        // Set note type based on template
        currentNoteType = template.noteType

        // Show the note in edit overlay
        showNoteForEditing(filledContent, template.noteType)

        speakFeedback("${template.name} template applied")
        transcriptText.text = "Template: ${template.name}"
        Log.d(TAG, "Applied template: ${template.name}")
    }

    /**
     * Fill template variables with patient data.
     * Variables: {{patient_name}}, {{dob}}, {{age}}, {{gender}}, {{medications}}, {{allergies}}, {{vitals}}, {{conditions}}, {{date}}
     */
    private fun fillTemplateVariables(content: String, patient: JSONObject): String {
        var result = content

        // Patient name
        val name = patient.optString("name", "Patient")
        result = result.replace("{{patient_name}}", name)

        // Date of birth
        val dob = patient.optString("date_of_birth", "Unknown")
        result = result.replace("{{dob}}", dob)

        // Calculate age from DOB
        val age = calculateAge(dob)
        result = result.replace("{{age}}", age)

        // Gender
        val gender = patient.optString("gender", "").lowercase()
        val genderText = when (gender) {
            "male" -> "male"
            "female" -> "female"
            else -> gender
        }
        result = result.replace("{{gender}}", genderText)

        // Current date
        val dateFormat = java.text.SimpleDateFormat("MMMM d, yyyy", Locale.US)
        val currentDate = dateFormat.format(java.util.Date())
        result = result.replace("{{date}}", currentDate)

        // Medications
        val medications = patient.optJSONArray("medications")
        val medsText = if (medications != null && medications.length() > 0) {
            val medList = mutableListOf<String>()
            for (i in 0 until minOf(medications.length(), 5)) {
                val med = medications.optJSONObject(i)
                val medName = med?.optString("name", "") ?: ""
                if (medName.isNotEmpty()) medList.add(medName)
            }
            if (medList.isEmpty()) "None documented" else medList.joinToString(", ")
        } else {
            "None documented"
        }
        result = result.replace("{{medications}}", medsText)

        // Allergies
        val allergies = patient.optJSONArray("allergies")
        val allergiesText = if (allergies != null && allergies.length() > 0) {
            val allergyList = mutableListOf<String>()
            for (i in 0 until allergies.length()) {
                val allergy = allergies.optJSONObject(i)
                val allergyName = allergy?.optString("substance", "") ?: ""
                if (allergyName.isNotEmpty()) allergyList.add(allergyName)
            }
            if (allergyList.isEmpty()) "NKDA" else allergyList.joinToString(", ")
        } else {
            "NKDA"
        }
        result = result.replace("{{allergies}}", allergiesText)

        // Vitals
        val vitals = patient.optJSONArray("vitals")
        val vitalsText = if (vitals != null && vitals.length() > 0) {
            val vitalList = mutableListOf<String>()
            for (i in 0 until minOf(vitals.length(), 5)) {
                val vital = vitals.optJSONObject(i)
                val vitalName = vital?.optString("type", "") ?: ""
                val vitalValue = vital?.optString("value", "") ?: ""
                val vitalUnit = vital?.optString("unit", "") ?: ""
                if (vitalName.isNotEmpty() && vitalValue.isNotEmpty()) {
                    vitalList.add("$vitalName: $vitalValue $vitalUnit".trim())
                }
            }
            if (vitalList.isEmpty()) "Not available" else vitalList.joinToString(", ")
        } else {
            "Not available"
        }
        result = result.replace("{{vitals}}", vitalsText)

        // Conditions
        val conditions = patient.optJSONArray("conditions")
        val conditionsText = if (conditions != null && conditions.length() > 0) {
            val condList = mutableListOf<String>()
            for (i in 0 until minOf(conditions.length(), 5)) {
                val condition = conditions.optJSONObject(i)
                val condName = condition?.optString("name", "") ?: ""
                if (condName.isNotEmpty()) condList.add("• $condName")
            }
            if (condList.isEmpty()) "None documented" else condList.joinToString("\n")
        } else {
            "None documented"
        }
        result = result.replace("{{conditions}}", conditionsText)

        return result
    }

    /**
     * Calculate age from date of birth string.
     */
    private fun calculateAge(dob: String): String {
        try {
            val formats = listOf(
                java.text.SimpleDateFormat("yyyy-MM-dd", Locale.US),
                java.text.SimpleDateFormat("MM/dd/yyyy", Locale.US)
            )
            for (format in formats) {
                try {
                    val birthDate = format.parse(dob) ?: continue
                    val today = java.util.Calendar.getInstance()
                    val birth = java.util.Calendar.getInstance().apply { time = birthDate }

                    var age = today.get(java.util.Calendar.YEAR) - birth.get(java.util.Calendar.YEAR)
                    if (today.get(java.util.Calendar.DAY_OF_YEAR) < birth.get(java.util.Calendar.DAY_OF_YEAR)) {
                        age--
                    }
                    return age.toString()
                } catch (e: Exception) {
                    continue
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error calculating age: ${e.message}")
        }
        return "Unknown"
    }

    /**
     * Show the template list overlay.
     */
    private fun showTemplateListOverlay() {
        val sb = StringBuilder()
        sb.append("📋 AVAILABLE TEMPLATES\n")
        sb.append("${"═".repeat(30)}\n\n")

        // Group by category
        val categories = builtInTemplates.values.groupBy { it.category }

        for ((category, templates) in categories) {
            sb.append("▸ $category\n")
            for (template in templates) {
                val key = builtInTemplates.entries.find { it.value == template }?.key ?: ""
                sb.append("  • ${template.name} (\"use $key template\")\n")
            }
            sb.append("\n")
        }

        // User templates
        val userTemplates = getUserTemplates()
        if (userTemplates.isNotEmpty()) {
            sb.append("▸ My Templates\n")
            for ((key, template) in userTemplates) {
                sb.append("  • ${template.name} (\"use $key template\")\n")
            }
            sb.append("\n")
        }

        sb.append("${"─".repeat(30)}\n")
        sb.append("Say \"use [name] template\" to apply")

        showDataOverlay("Note Templates", sb.toString())
        speakFeedback("${builtInTemplates.size} templates available")
        Log.d(TAG, "Showing template list")
    }

    /**
     * Show note content for editing (used by templates).
     */
    private fun showNoteForEditing(content: String, noteType: String) {
        // Store the note for editing
        editableNoteContent = content
        isNoteEditing = true
        editHistory.clear()

        // Create a mock note object for the existing edit overlay
        val noteJson = JSONObject().apply {
            put("content", content)
            put("note_type", noteType)
        }
        lastGeneratedNote = noteJson

        // Show the edit overlay
        showNoteEditOverlay(content)
    }

    /**
     * Show note edit overlay (extracted for reuse with templates).
     */
    private fun showNoteEditOverlay(content: String) {
        // Remove existing overlay if any
        dataOverlay?.let { (it.parent as? android.view.ViewGroup)?.removeView(it) }

        val rootView = window.decorView.findViewById<android.view.ViewGroup>(android.R.id.content)

        dataOverlay = android.widget.FrameLayout(this).apply {
            setBackgroundColor(0xEE0A1628.toInt())
            isClickable = true

            val innerLayout = android.widget.LinearLayout(context).apply {
                orientation = android.widget.LinearLayout.VERTICAL
                setPadding(32, 32, 32, 32)
                layoutParams = android.widget.FrameLayout.LayoutParams(
                    android.widget.FrameLayout.LayoutParams.MATCH_PARENT,
                    android.widget.FrameLayout.LayoutParams.MATCH_PARENT
                )
            }

            // Title row with note type
            val titleRow = android.widget.LinearLayout(context).apply {
                orientation = android.widget.LinearLayout.HORIZONTAL
                gravity = android.view.Gravity.CENTER_VERTICAL
                setPadding(0, 0, 0, 8)
            }

            val titleText = TextView(context).apply {
                text = "📝 Edit Note"
                textSize = getTitleFontSize()
                setTextColor(0xFF10B981.toInt())
                layoutParams = android.widget.LinearLayout.LayoutParams(0, android.widget.LinearLayout.LayoutParams.WRAP_CONTENT, 1f)
            }
            titleRow.addView(titleText)
            innerLayout.addView(titleRow)

            // Hint text
            val hintText = TextView(context).apply {
                text = "Edit the note below, then tap SAVE or say 'save note'"
                textSize = 12f
                setTextColor(0xFF94A3B8.toInt())
                setPadding(0, 0, 0, 8)
            }
            innerLayout.addView(hintText)

            // Scrollable editable content
            val scrollView = android.widget.ScrollView(context).apply {
                layoutParams = android.widget.LinearLayout.LayoutParams(
                    android.widget.LinearLayout.LayoutParams.MATCH_PARENT, 0, 1f
                )
                setBackgroundColor(0xFF1E293B.toInt())
            }

            // EditText for editable note content
            noteEditText = android.widget.EditText(context).apply {
                setText(content)
                textSize = getContentFontSize()
                setTextColor(0xFFF8FAFC.toInt())
                setHintTextColor(0xFF64748B.toInt())
                setLineSpacing(4f, 1.2f)
                setBackgroundColor(0x00000000)
                setPadding(16, 16, 16, 16)
                gravity = android.view.Gravity.TOP or android.view.Gravity.START
                inputType = android.text.InputType.TYPE_CLASS_TEXT or
                        android.text.InputType.TYPE_TEXT_FLAG_MULTI_LINE or
                        android.text.InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS
                isSingleLine = false
                minLines = 10

                addTextChangedListener(object : android.text.TextWatcher {
                    override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
                    override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
                        isNoteEditing = true
                        editableNoteContent = s?.toString()
                    }
                    override fun afterTextChanged(s: android.text.Editable?) {}
                })
            }
            scrollView.addView(noteEditText)
            innerLayout.addView(scrollView)

            // Track for voice navigation
            currentScrollView = scrollView

            // Button row
            val buttonRow = android.widget.LinearLayout(context).apply {
                orientation = android.widget.LinearLayout.HORIZONTAL
                setPadding(0, 16, 0, 0)
            }

            // Reset button
            val resetButton = android.widget.Button(context).apply {
                text = "↩ RESET"
                setBackgroundColor(0xFF6366F1.toInt())
                setTextColor(0xFFFFFFFF.toInt())
                textSize = 14f
                layoutParams = android.widget.LinearLayout.LayoutParams(0, android.widget.LinearLayout.LayoutParams.WRAP_CONTENT, 0.8f).apply {
                    marginEnd = 4
                }
                setOnClickListener {
                    noteEditText?.setText(content)
                    editableNoteContent = content
                    isNoteEditing = false
                    editHistory.clear()
                    Toast.makeText(context, "Note reset", Toast.LENGTH_SHORT).show()
                }
            }
            buttonRow.addView(resetButton)

            // Save button
            val saveButton = android.widget.Button(context).apply {
                text = "💾 SAVE"
                setBackgroundColor(0xFF10B981.toInt())
                setTextColor(0xFFFFFFFF.toInt())
                textSize = 14f
                layoutParams = android.widget.LinearLayout.LayoutParams(0, android.widget.LinearLayout.LayoutParams.WRAP_CONTENT, 1f).apply {
                    marginStart = 4
                    marginEnd = 4
                }
                setOnClickListener {
                    saveCurrentNote()
                }
            }
            buttonRow.addView(saveButton)

            // Close button
            val closeButton = android.widget.Button(context).apply {
                text = "✕"
                setBackgroundColor(0xFF475569.toInt())
                setTextColor(0xFFFFFFFF.toInt())
                textSize = 14f
                layoutParams = android.widget.LinearLayout.LayoutParams(0, android.widget.LinearLayout.LayoutParams.WRAP_CONTENT, 0.5f).apply {
                    marginStart = 4
                }
                setOnClickListener {
                    hideDataOverlay()
                    noteEditText = null
                    editableNoteContent = null
                    isNoteEditing = false
                }
            }
            buttonRow.addView(closeButton)

            innerLayout.addView(buttonRow)
            addView(innerLayout)
        }

        rootView.addView(dataOverlay)
        statusText.text = "Edit Note"
        transcriptText.text = "Edit note or say 'save note'"
    }

    /**
     * Get user-created templates from SharedPreferences.
     */
    private fun getUserTemplates(): Map<String, NoteTemplate> {
        val templatesJson = cachePrefs.getString(USER_TEMPLATES_KEY, null) ?: return emptyMap()
        return try {
            val result = mutableMapOf<String, NoteTemplate>()
            val json = JSONObject(templatesJson)
            for (key in json.keys()) {
                val templateJson = json.getJSONObject(key)
                result[key] = NoteTemplate(
                    name = templateJson.optString("name", key),
                    category = templateJson.optString("category", "My Templates"),
                    noteType = templateJson.optString("noteType", "SOAP"),
                    content = templateJson.optString("content", "")
                )
            }
            result
        } catch (e: Exception) {
            Log.e(TAG, "Error loading user templates: ${e.message}")
            emptyMap()
        }
    }

    /**
     * Get a specific user template.
     */
    private fun getUserTemplate(key: String): NoteTemplate? {
        return getUserTemplates()[key]
    }

    /**
     * Save the current note as a user template.
     */
    private fun saveAsTemplate(templateName: String) {
        val content = editableNoteContent
        if (content.isNullOrEmpty()) {
            Toast.makeText(this, "No note content to save as template", Toast.LENGTH_SHORT).show()
            return
        }

        // Create template key from name
        val key = templateName.lowercase().replace(Regex("[^a-z0-9]"), "_")

        // Load existing templates
        val existingJson = cachePrefs.getString(USER_TEMPLATES_KEY, null)
        val templates = if (existingJson != null) JSONObject(existingJson) else JSONObject()

        // Add new template
        val templateJson = JSONObject().apply {
            put("name", templateName)
            put("category", "My Templates")
            put("noteType", currentNoteType)
            put("content", content)
        }
        templates.put(key, templateJson)

        // Save
        cachePrefs.edit().putString(USER_TEMPLATES_KEY, templates.toString()).apply()

        Toast.makeText(this, "Saved template: $templateName", Toast.LENGTH_SHORT).show()
        speakFeedback("Template saved as $templateName")
        Log.d(TAG, "Saved user template: $key")
    }

    /**
     * Delete a user template.
     */
    private fun deleteUserTemplate(templateName: String) {
        val key = templateName.lowercase().replace(Regex("[^a-z0-9]"), "_")

        val existingJson = cachePrefs.getString(USER_TEMPLATES_KEY, null) ?: return
        val templates = JSONObject(existingJson)

        if (templates.has(key)) {
            templates.remove(key)
            cachePrefs.edit().putString(USER_TEMPLATES_KEY, templates.toString()).apply()
            Toast.makeText(this, "Deleted template: $templateName", Toast.LENGTH_SHORT).show()
            speakFeedback("Template deleted")
            Log.d(TAG, "Deleted user template: $key")
        } else {
            Toast.makeText(this, "Template not found: $templateName", Toast.LENGTH_SHORT).show()
        }
    }

    /**
     * Find template by name (searches both built-in and user templates).
     */
    private fun findTemplateByName(name: String): String? {
        val lowerName = name.lowercase().trim()

        // Check built-in templates
        for ((key, template) in builtInTemplates) {
            if (key == lowerName || template.name.lowercase().contains(lowerName)) {
                return key
            }
        }

        // Check user templates
        for ((key, template) in getUserTemplates()) {
            if (key == lowerName || template.name.lowercase().contains(lowerName)) {
                return key
            }
        }

        // Check common aliases
        val aliases = mapOf(
            "dm" to "diabetes",
            "dm2" to "diabetes",
            "htn" to "hypertension",
            "bp" to "hypertension",
            "cold" to "uri",
            "physical" to "annual_physical",
            "wellness" to "annual_physical",
            "annual" to "annual_physical",
            "lbp" to "back_pain",
            "backache" to "back_pain",
            "chest" to "chest_pain",
            "cp" to "chest_pain",
            "peds" to "well_child",
            "child" to "well_child",
            "pediatric" to "well_child"
        )

        return aliases[lowerName]
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // CUSTOM VOICE COMMANDS - User-defined command aliases and macros
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Get all custom commands from SharedPreferences
     */
    private fun getCustomCommands(): Map<String, CustomCommand> {
        val commandsJson = cachePrefs.getString(CUSTOM_COMMANDS_KEY, null) ?: return emptyMap()
        return try {
            val result = mutableMapOf<String, CustomCommand>()
            val json = JSONObject(commandsJson)
            for (key in json.keys()) {
                result[key] = CustomCommand.fromJson(json.getJSONObject(key))
            }
            result
        } catch (e: Exception) {
            Log.e(TAG, "Error loading custom commands: ${e.message}")
            emptyMap()
        }
    }

    /**
     * Save a custom command
     */
    private fun saveCustomCommand(command: CustomCommand) {
        val key = command.trigger.lowercase().replace(Regex("[^a-z0-9 ]"), "").trim()

        val existingJson = cachePrefs.getString(CUSTOM_COMMANDS_KEY, null)
        val commands = if (existingJson != null) JSONObject(existingJson) else JSONObject()

        commands.put(key, command.toJson())
        cachePrefs.edit().putString(CUSTOM_COMMANDS_KEY, commands.toString()).apply()

        Log.d(TAG, "Saved custom command: ${command.name} -> ${command.actions}")
    }

    /**
     * Delete a custom command
     */
    private fun deleteCustomCommand(commandName: String) {
        val key = commandName.lowercase().replace(Regex("[^a-z0-9 ]"), "").trim()

        val existingJson = cachePrefs.getString(CUSTOM_COMMANDS_KEY, null) ?: return
        val commands = JSONObject(existingJson)

        // Try exact match first
        if (commands.has(key)) {
            commands.remove(key)
            cachePrefs.edit().putString(CUSTOM_COMMANDS_KEY, commands.toString()).apply()
            speakFeedback("Deleted command: $commandName")
            Log.d(TAG, "Deleted custom command: $key")
            return
        }

        // Try partial match
        for (cmdKey in commands.keys()) {
            val cmd = CustomCommand.fromJson(commands.getJSONObject(cmdKey))
            if (cmd.name.lowercase().contains(key) || cmd.trigger.lowercase().contains(key)) {
                commands.remove(cmdKey)
                cachePrefs.edit().putString(CUSTOM_COMMANDS_KEY, commands.toString()).apply()
                speakFeedback("Deleted command: ${cmd.name}")
                Log.d(TAG, "Deleted custom command: $cmdKey")
                return
            }
        }

        speakFeedback("Command not found: $commandName")
    }

    /**
     * Find a custom command by trigger phrase
     */
    private fun findCustomCommand(phrase: String): CustomCommand? {
        val lowerPhrase = phrase.lowercase().trim()
        val commands = getCustomCommands()

        // Exact match
        for ((_, cmd) in commands) {
            if (lowerPhrase == cmd.trigger.lowercase() ||
                lowerPhrase.contains(cmd.trigger.lowercase())) {
                return cmd
            }
        }

        return null
    }

    /**
     * Execute a custom command by running its actions in sequence
     */
    private fun executeCustomCommand(command: CustomCommand) {
        Log.d(TAG, "Executing custom command: ${command.name} with ${command.actions.size} actions")
        speakFeedback("Running ${command.name}")

        // Execute actions with a small delay between each
        var delay = 0L
        for (action in command.actions) {
            android.os.Handler(mainLooper).postDelayed({
                Log.d(TAG, "Executing action: $action")
                processTranscript(action)
            }, delay)
            delay += 500L // 500ms between actions
        }
    }

    /**
     * Parse and create a custom command from voice input
     * Patterns:
     * - "create command [name] that does [action1] then [action2]"
     * - "when I say [phrase] do [action]"
     * - "teach [name] to do [action1] and [action2]"
     */
    private fun parseAndCreateCommand(input: String): Boolean {
        val lower = input.lowercase().trim()

        // Pattern: "create command [name] that does [actions]"
        val createPattern = Regex("(?:create|make|add|new) (?:command|macro|shortcut) ([\\w\\s]+?) (?:that does?|to do|which does?|:) (.+)")
        val createMatch = createPattern.find(lower)
        if (createMatch != null) {
            val name = createMatch.groupValues[1].trim()
            val actionsStr = createMatch.groupValues[2].trim()
            val actions = parseActionList(actionsStr)

            if (actions.isNotEmpty()) {
                val command = CustomCommand(
                    name = name.split(" ").joinToString(" ") { it.replaceFirstChar { c -> c.uppercase() } },
                    trigger = name,
                    actions = actions,
                    description = "Custom command created by voice"
                )
                saveCustomCommand(command)
                speakFeedback("Created command: ${command.name}. Say \"${command.trigger}\" to run it.")
                showCommandCreatedOverlay(command)
                return true
            }
        }

        // Pattern: "when I say [phrase] do [action]"
        val whenPattern = Regex("when (?:i|I) say ([\\w\\s]+?) (?:do|run|execute) (.+)")
        val whenMatch = whenPattern.find(lower)
        if (whenMatch != null) {
            val trigger = whenMatch.groupValues[1].trim()
            val actionsStr = whenMatch.groupValues[2].trim()
            val actions = parseActionList(actionsStr)

            if (actions.isNotEmpty()) {
                val command = CustomCommand(
                    name = trigger.split(" ").joinToString(" ") { it.replaceFirstChar { c -> c.uppercase() } },
                    trigger = trigger,
                    actions = actions,
                    description = "Voice alias"
                )
                saveCustomCommand(command)
                speakFeedback("Got it! When you say \"$trigger\", I'll do that.")
                return true
            }
        }

        // Pattern: "teach [name] to [action]"
        val teachPattern = Regex("teach ([\\w\\s]+?) to (.+)")
        val teachMatch = teachPattern.find(lower)
        if (teachMatch != null) {
            val name = teachMatch.groupValues[1].trim()
            val actionsStr = teachMatch.groupValues[2].trim()
            val actions = parseActionList(actionsStr)

            if (actions.isNotEmpty()) {
                val command = CustomCommand(
                    name = name.split(" ").joinToString(" ") { it.replaceFirstChar { c -> c.uppercase() } },
                    trigger = name,
                    actions = actions,
                    description = "Taught command"
                )
                saveCustomCommand(command)
                speakFeedback("Learned! Say \"$name\" to run this command.")
                return true
            }
        }

        return false
    }

    /**
     * Parse action list from voice input
     * Handles: "then", "and", "and then", commas
     */
    private fun parseActionList(actionsStr: String): List<String> {
        // Split by common separators
        val parts = actionsStr
            .replace(" and then ", "|")
            .replace(" then ", "|")
            .replace(" and ", "|")
            .replace(", ", "|")
            .replace(",", "|")
            .split("|")
            .map { it.trim() }
            .filter { it.isNotEmpty() }

        return parts
    }

    /**
     * Show overlay confirming command creation
     */
    private fun showCommandCreatedOverlay(command: CustomCommand) {
        val content = StringBuilder()
        content.append("═══════════════════════════════════\n")
        content.append("✅ COMMAND CREATED\n")
        content.append("═══════════════════════════════════\n\n")
        content.append("📢 Name: ${command.name}\n\n")
        content.append("🎤 Say: \"${command.trigger}\"\n\n")
        content.append("📋 Actions:\n")
        command.actions.forEachIndexed { index, action ->
            content.append("  ${index + 1}. $action\n")
        }
        content.append("\n───────────────────────────────────\n")
        content.append("Say \"my commands\" to see all")

        showDataOverlay("Command Created", content.toString())
    }

    /**
     * Show all custom commands
     */
    private fun showCustomCommands() {
        val commands = getCustomCommands()

        if (commands.isEmpty()) {
            speakFeedback("No custom commands yet. Say: create command morning rounds that does show vitals then show meds")
            showDataOverlay("Custom Commands", "No custom commands created yet.\n\n" +
                "📝 To create a command, say:\n" +
                "• \"Create command [name] that does [actions]\"\n" +
                "• \"When I say [phrase] do [action]\"\n" +
                "• \"Teach [name] to [actions]\"\n\n" +
                "Example:\n" +
                "\"Create command morning rounds that does\n" +
                " show vitals then show meds then show labs\"")
            return
        }

        val content = StringBuilder()
        content.append("═══════════════════════════════════\n")
        content.append("🎤 MY CUSTOM COMMANDS\n")
        content.append("═══════════════════════════════════\n\n")

        commands.values.forEachIndexed { index, cmd ->
            content.append("${index + 1}. ${cmd.name}\n")
            content.append("   Say: \"${cmd.trigger}\"\n")
            content.append("   Does: ${cmd.actions.joinToString(" → ")}\n\n")
        }

        content.append("───────────────────────────────────\n")
        content.append("• \"Delete command [name]\" to remove\n")
        content.append("• \"Create command...\" to add new")

        showDataOverlay("My Commands", content.toString())
        speakFeedback("You have ${commands.size} custom commands.")
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // MEDICAL CALCULATOR - Voice-activated clinical calculations
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Available medical calculators
     */
    enum class MedCalcType(val displayName: String, val description: String) {
        BMI("BMI", "Body Mass Index"),
        EGFR("eGFR", "Estimated Glomerular Filtration Rate"),
        CHADS_VASC("CHADS₂-VASc", "Stroke Risk in AFib"),
        CORRECTED_CALCIUM("Corrected Calcium", "Calcium adjusted for albumin"),
        ANION_GAP("Anion Gap", "From BMP values"),
        A1C_TO_GLUCOSE("A1c to Glucose", "HbA1c to average glucose"),
        GLUCOSE_TO_A1C("Glucose to A1c", "Average glucose to HbA1c"),
        CREATININE_CLEARANCE("CrCl", "Cockcroft-Gault Creatinine Clearance"),
        WELLS_DVT("Wells DVT", "DVT Probability Score"),
        MELD("MELD", "Model for End-Stage Liver Disease"),
        MAP("MAP", "Mean Arterial Pressure"),
        BMI_PEDIATRIC("Pediatric BMI", "BMI percentile for children")
    }

    /**
     * Calculate BMI from weight (kg or lbs) and height (cm or ft/in)
     */
    private fun calculateBMI(weightKg: Double, heightCm: Double): Double {
        val heightM = heightCm / 100.0
        return weightKg / (heightM * heightM)
    }

    /**
     * Interpret BMI category
     */
    private fun interpretBMI(bmi: Double): String {
        return when {
            bmi < 18.5 -> "Underweight"
            bmi < 25.0 -> "Normal"
            bmi < 30.0 -> "Overweight"
            bmi < 35.0 -> "Obese Class I"
            bmi < 40.0 -> "Obese Class II"
            else -> "Obese Class III"
        }
    }

    /**
     * Calculate eGFR using CKD-EPI 2021 formula (race-free)
     * Returns mL/min/1.73m²
     */
    private fun calculateEGFR(creatinine: Double, age: Int, isFemale: Boolean): Double {
        // CKD-EPI 2021 (race-free) formula
        val kappa = if (isFemale) 0.7 else 0.9
        val alpha = if (isFemale) -0.241 else -0.302
        val multiplier = if (isFemale) 1.012 else 1.0

        val scrKappa = creatinine / kappa
        val minTerm = minOf(scrKappa, 1.0)
        val maxTerm = maxOf(scrKappa, 1.0)

        return 142 * Math.pow(minTerm, alpha) * Math.pow(maxTerm, -1.200) *
               Math.pow(0.9938, age.toDouble()) * multiplier
    }

    /**
     * Interpret eGFR stage
     */
    private fun interpretEGFR(egfr: Double): String {
        return when {
            egfr >= 90 -> "G1 - Normal"
            egfr >= 60 -> "G2 - Mild decrease"
            egfr >= 45 -> "G3a - Mild-moderate"
            egfr >= 30 -> "G3b - Moderate-severe"
            egfr >= 15 -> "G4 - Severe"
            else -> "G5 - Kidney failure"
        }
    }

    /**
     * Calculate corrected calcium for albumin
     */
    private fun calculateCorrectedCalcium(calcium: Double, albumin: Double): Double {
        return calcium + 0.8 * (4.0 - albumin)
    }

    /**
     * Calculate anion gap
     */
    private fun calculateAnionGap(sodium: Double, chloride: Double, bicarb: Double): Double {
        return sodium - (chloride + bicarb)
    }

    /**
     * Interpret anion gap
     */
    private fun interpretAnionGap(ag: Double): String {
        return when {
            ag < 3 -> "Low (lab error?)"
            ag <= 12 -> "Normal (3-12)"
            ag <= 20 -> "Elevated - consider MUDPILES"
            else -> "High - metabolic acidosis likely"
        }
    }

    /**
     * Convert A1c to estimated average glucose (mg/dL)
     */
    private fun a1cToGlucose(a1c: Double): Double {
        return 28.7 * a1c - 46.7
    }

    /**
     * Convert average glucose to estimated A1c
     */
    private fun glucoseToA1c(glucose: Double): Double {
        return (glucose + 46.7) / 28.7
    }

    /**
     * Calculate Mean Arterial Pressure
     */
    private fun calculateMAP(systolic: Double, diastolic: Double): Double {
        return diastolic + (systolic - diastolic) / 3.0
    }

    /**
     * Calculate Creatinine Clearance (Cockcroft-Gault)
     */
    private fun calculateCrCl(creatinine: Double, age: Int, weightKg: Double, isFemale: Boolean): Double {
        val result = ((140 - age) * weightKg) / (72 * creatinine)
        return if (isFemale) result * 0.85 else result
    }

    /**
     * Show list of available calculators
     */
    private fun showCalculatorList() {
        val content = StringBuilder()
        content.append("═══════════════════════════════════\n")
        content.append("🧮 MEDICAL CALCULATORS\n")
        content.append("═══════════════════════════════════\n\n")

        content.append("📊 BODY MEASUREMENTS\n")
        content.append("• \"Calculate BMI\" - Body Mass Index\n")
        content.append("• \"Calculate MAP\" - Mean Arterial Pressure\n\n")

        content.append("🩺 KIDNEY FUNCTION\n")
        content.append("• \"Calculate GFR\" - eGFR (CKD-EPI 2021)\n")
        content.append("• \"Calculate creatinine clearance\"\n\n")

        content.append("🧪 LAB CORRECTIONS\n")
        content.append("• \"Corrected calcium\" - Adjust for albumin\n")
        content.append("• \"Anion gap\" - From BMP\n\n")

        content.append("🩸 DIABETES\n")
        content.append("• \"A1c to glucose\" - Convert HbA1c\n")
        content.append("• \"Glucose to A1c\" - Reverse conversion\n\n")

        content.append("❤️ CARDIAC\n")
        content.append("• \"CHADS VASc\" - Stroke risk in AFib\n\n")

        content.append("───────────────────────────────────\n")
        content.append("Values auto-pulled from patient chart\n")
        content.append("when available")

        showDataOverlay("Calculators", content.toString())
        speakFeedback("12 medical calculators available. Say the calculation you need.")
    }

    /**
     * Process calculator voice command
     */
    private fun processCalculatorCommand(command: String) {
        val lower = command.lowercase()

        when {
            // BMI
            lower.contains("bmi") || lower.contains("body mass") -> {
                calculateAndShowBMI()
            }
            // eGFR
            lower.contains("gfr") || lower.contains("glomerular") ||
            lower.contains("kidney function") -> {
                calculateAndShowEGFR()
            }
            // Corrected Calcium
            lower.contains("corrected calcium") || lower.contains("calcium correct") -> {
                calculateAndShowCorrectedCalcium()
            }
            // Anion Gap
            lower.contains("anion gap") || lower.contains("anion") -> {
                calculateAndShowAnionGap()
            }
            // A1c conversions
            lower.contains("a1c to glucose") || lower.contains("a1c glucose") ||
            (lower.contains("convert") && lower.contains("a1c")) -> {
                calculateAndShowA1cToGlucose()
            }
            lower.contains("glucose to a1c") -> {
                calculateAndShowGlucoseToA1c()
            }
            // MAP
            lower.contains("map") || lower.contains("mean arterial") -> {
                calculateAndShowMAP()
            }
            // Creatinine Clearance
            lower.contains("creatinine clearance") || lower.contains("crcl") ||
            lower.contains("cockcroft") -> {
                calculateAndShowCrCl()
            }
            // CHADS-VASc
            lower.contains("chads") || lower.contains("stroke risk") -> {
                calculateAndShowCHADSVASc()
            }
            else -> {
                showCalculatorList()
            }
        }
    }

    /**
     * Calculate and show BMI using patient data or captured vitals
     */
    private fun calculateAndShowBMI() {
        // Try to get weight and height from captured vitals or patient data
        var weightKg: Double? = null
        var heightCm: Double? = null

        // Check captured vitals first
        for (vital in capturedVitals) {
            when (vital.type) {
                VitalType.WEIGHT -> {
                    val value = vital.value.replace(Regex("[^0-9.]"), "").toDoubleOrNull()
                    if (value != null) {
                        weightKg = if (vital.unit.contains("lb", ignoreCase = true)) value * 0.453592 else value
                    }
                }
                VitalType.HEIGHT -> {
                    val value = vital.value.replace(Regex("[^0-9.]"), "").toDoubleOrNull()
                    if (value != null) {
                        heightCm = if (vital.unit.contains("in", ignoreCase = true)) value * 2.54 else value
                    }
                }
                else -> {}
            }
        }

        // Try patient data if not in captured vitals
        if (weightKg == null || heightCm == null) {
            currentPatientData?.optJSONArray("vitals")?.let { vitals ->
                for (i in 0 until vitals.length()) {
                    val v = vitals.getJSONObject(i)
                    val name = v.optString("name", "").lowercase()
                    val value = v.optString("value", "").replace(Regex("[^0-9.]"), "").toDoubleOrNull()
                    val unit = v.optString("unit", "").lowercase()

                    if (value != null) {
                        when {
                            name.contains("weight") && weightKg == null -> {
                                weightKg = if (unit.contains("lb")) value * 0.453592 else value
                            }
                            name.contains("height") && heightCm == null -> {
                                heightCm = if (unit.contains("in")) value * 2.54 else value
                            }
                        }
                    }
                }
            }
        }

        val weight = weightKg
        val height = heightCm
        if (weight != null && height != null) {
            val bmi = calculateBMI(weight, height)
            val category = interpretBMI(bmi)
            val result = String.format("%.1f", bmi)

            val content = """
                |═══════════════════════════════════
                |🧮 BMI CALCULATION
                |═══════════════════════════════════
                |
                |Weight: ${String.format("%.1f", weight)} kg
                |Height: ${String.format("%.1f", height)} cm
                |
                |📊 BMI = $result
                |
                |Category: $category
                |
                |───────────────────────────────────
                |Normal range: 18.5 - 24.9
            """.trimMargin()

            showDataOverlay("BMI Result", content)
            speakFeedback("BMI is $result. Category: $category")
        } else {
            speakFeedback("Need weight and height. Say: weight 180 pounds, height 5 foot 10")
            showDataOverlay("BMI Calculator",
                "Missing data:\n\n" +
                "• Weight: ${if (weightKg != null) "✓" else "❌ needed"}\n" +
                "• Height: ${if (heightCm != null) "✓" else "❌ needed"}\n\n" +
                "Say vitals to capture:\n" +
                "\"Weight 180 pounds\"\n" +
                "\"Height 5 foot 10\"")
        }
    }

    /**
     * Calculate and show eGFR
     */
    private fun calculateAndShowEGFR() {
        var creatinine: Double? = null
        var age: Int? = null
        var isFemale: Boolean? = null

        // Get from patient data
        currentPatientData?.let { patient ->
            // Age from DOB
            patient.optString("date_of_birth", "")?.let { dob ->
                if (dob.isNotEmpty()) {
                    try {
                        val birthYear = dob.substring(0, 4).toInt()
                        val currentYear = java.util.Calendar.getInstance().get(java.util.Calendar.YEAR)
                        age = currentYear - birthYear
                    } catch (e: Exception) {}
                }
            }

            // Gender
            val gender = patient.optString("gender", "").lowercase()
            isFemale = gender == "female" || gender == "f"

            // Creatinine from labs
            patient.optJSONArray("labs")?.let { labs ->
                for (i in 0 until labs.length()) {
                    val lab = labs.getJSONObject(i)
                    val name = lab.optString("name", "").lowercase()
                    if (name.contains("creatinine") && !name.contains("clearance")) {
                        creatinine = lab.optString("value", "").replace(Regex("[^0-9.]"), "").toDoubleOrNull()
                        break
                    }
                }
            }
        }

        if (creatinine != null && age != null && isFemale != null) {
            val egfr = calculateEGFR(creatinine!!, age!!, isFemale!!)
            val stage = interpretEGFR(egfr)
            val result = String.format("%.0f", egfr)

            val content = """
                |═══════════════════════════════════
                |🧮 eGFR CALCULATION (CKD-EPI 2021)
                |═══════════════════════════════════
                |
                |Creatinine: $creatinine mg/dL
                |Age: $age years
                |Sex: ${if (isFemale!!) "Female" else "Male"}
                |
                |📊 eGFR = $result mL/min/1.73m²
                |
                |Stage: $stage
                |
                |───────────────────────────────────
                |Normal: ≥90 mL/min/1.73m²
            """.trimMargin()

            showDataOverlay("eGFR Result", content)
            speakFeedback("eGFR is $result. Stage: $stage")
        } else {
            speakFeedback("Need creatinine, age, and sex for GFR calculation")
            showDataOverlay("eGFR Calculator",
                "Missing data:\n\n" +
                "• Creatinine: ${if (creatinine != null) "$creatinine mg/dL ✓" else "❌ needed"}\n" +
                "• Age: ${if (age != null) "$age years ✓" else "❌ needed"}\n" +
                "• Sex: ${if (isFemale != null) (if (isFemale!!) "Female" else "Male") + " ✓" else "❌ needed"}\n\n" +
                "Load patient with labs to calculate")
        }
    }

    /**
     * Calculate and show corrected calcium
     */
    private fun calculateAndShowCorrectedCalcium() {
        var calcium: Double? = null
        var albumin: Double? = null

        currentPatientData?.optJSONArray("labs")?.let { labs ->
            for (i in 0 until labs.length()) {
                val lab = labs.getJSONObject(i)
                val name = lab.optString("name", "").lowercase()
                val value = lab.optString("value", "").replace(Regex("[^0-9.]"), "").toDoubleOrNull()

                when {
                    name.contains("calcium") && !name.contains("corrected") && calcium == null -> calcium = value
                    name.contains("albumin") && albumin == null -> albumin = value
                }
            }
        }

        if (calcium != null && albumin != null) {
            val corrected = calculateCorrectedCalcium(calcium!!, albumin!!)
            val result = String.format("%.1f", corrected)

            val interpretation = when {
                corrected < 8.5 -> "Low (hypocalcemia)"
                corrected > 10.5 -> "High (hypercalcemia)"
                else -> "Normal (8.5-10.5)"
            }

            val content = """
                |═══════════════════════════════════
                |🧮 CORRECTED CALCIUM
                |═══════════════════════════════════
                |
                |Measured Ca: $calcium mg/dL
                |Albumin: $albumin g/dL
                |
                |📊 Corrected Ca = $result mg/dL
                |
                |$interpretation
                |
                |───────────────────────────────────
                |Formula: Ca + 0.8 × (4.0 - Albumin)
            """.trimMargin()

            showDataOverlay("Corrected Calcium", content)
            speakFeedback("Corrected calcium is $result. $interpretation")
        } else {
            speakFeedback("Need calcium and albumin from labs")
            showDataOverlay("Corrected Calcium",
                "Missing data:\n\n" +
                "• Calcium: ${if (calcium != null) "$calcium mg/dL ✓" else "❌ needed"}\n" +
                "• Albumin: ${if (albumin != null) "$albumin g/dL ✓" else "❌ needed"}\n\n" +
                "Load patient with labs to calculate")
        }
    }

    /**
     * Calculate and show anion gap
     */
    private fun calculateAndShowAnionGap() {
        var sodium: Double? = null
        var chloride: Double? = null
        var bicarb: Double? = null

        currentPatientData?.optJSONArray("labs")?.let { labs ->
            for (i in 0 until labs.length()) {
                val lab = labs.getJSONObject(i)
                val name = lab.optString("name", "").lowercase()
                val value = lab.optString("value", "").replace(Regex("[^0-9.]"), "").toDoubleOrNull()

                when {
                    name.contains("sodium") && sodium == null -> sodium = value
                    name.contains("chloride") && chloride == null -> chloride = value
                    (name.contains("bicarb") || name.contains("co2") || name.contains("hco3")) && bicarb == null -> bicarb = value
                }
            }
        }

        if (sodium != null && chloride != null && bicarb != null) {
            val ag = calculateAnionGap(sodium!!, chloride!!, bicarb!!)
            val result = String.format("%.0f", ag)
            val interpretation = interpretAnionGap(ag)

            val content = """
                |═══════════════════════════════════
                |🧮 ANION GAP
                |═══════════════════════════════════
                |
                |Sodium: $sodium mEq/L
                |Chloride: $chloride mEq/L
                |Bicarb: $bicarb mEq/L
                |
                |📊 Anion Gap = $result mEq/L
                |
                |$interpretation
                |
                |───────────────────────────────────
                |Formula: Na - (Cl + HCO₃)
                |MUDPILES: Methanol, Uremia, DKA,
                |Propylene glycol, INH, Lactic acid,
                |Ethylene glycol, Salicylates
            """.trimMargin()

            showDataOverlay("Anion Gap", content)
            speakFeedback("Anion gap is $result. $interpretation")
        } else {
            speakFeedback("Need sodium, chloride, and bicarbonate from BMP")
            showDataOverlay("Anion Gap Calculator",
                "Missing data:\n\n" +
                "• Sodium: ${if (sodium != null) "$sodium mEq/L ✓" else "❌ needed"}\n" +
                "• Chloride: ${if (chloride != null) "$chloride mEq/L ✓" else "❌ needed"}\n" +
                "• Bicarb: ${if (bicarb != null) "$bicarb mEq/L ✓" else "❌ needed"}\n\n" +
                "Load patient with BMP to calculate")
        }
    }

    /**
     * Calculate and show A1c to glucose conversion
     */
    private fun calculateAndShowA1cToGlucose() {
        var a1c: Double? = null

        currentPatientData?.optJSONArray("labs")?.let { labs ->
            for (i in 0 until labs.length()) {
                val lab = labs.getJSONObject(i)
                val name = lab.optString("name", "").lowercase()
                if (name.contains("a1c") || name.contains("hemoglobin a1c") || name.contains("hba1c")) {
                    a1c = lab.optString("value", "").replace(Regex("[^0-9.]"), "").toDoubleOrNull()
                    break
                }
            }
        }

        if (a1c != null) {
            val glucose = a1cToGlucose(a1c!!)
            val result = String.format("%.0f", glucose)

            val control = when {
                a1c!! < 5.7 -> "Normal"
                a1c!! < 6.5 -> "Prediabetes"
                a1c!! < 7.0 -> "Good control"
                a1c!! < 8.0 -> "Fair control"
                a1c!! < 9.0 -> "Poor control"
                else -> "Very poor control"
            }

            val content = """
                |═══════════════════════════════════
                |🧮 A1c TO GLUCOSE
                |═══════════════════════════════════
                |
                |HbA1c: ${String.format("%.1f", a1c)}%
                |
                |📊 Est. Avg Glucose = $result mg/dL
                |
                |Control: $control
                |
                |───────────────────────────────────
                |Target A1c: <7% for most adults
                |Formula: eAG = 28.7 × A1c - 46.7
            """.trimMargin()

            showDataOverlay("A1c Conversion", content)
            speakFeedback("A1c of ${String.format("%.1f", a1c)} percent equals average glucose of $result. $control")
        } else {
            speakFeedback("No A1c found in labs. Load patient with A1c result.")
            showDataOverlay("A1c Conversion", "No HbA1c found in patient labs.\n\nLoad a patient with A1c result to convert.")
        }
    }

    /**
     * Calculate and show glucose to A1c conversion
     */
    private fun calculateAndShowGlucoseToA1c() {
        var glucose: Double? = null

        currentPatientData?.optJSONArray("labs")?.let { labs ->
            for (i in 0 until labs.length()) {
                val lab = labs.getJSONObject(i)
                val name = lab.optString("name", "").lowercase()
                if (name.contains("glucose") && !name.contains("a1c")) {
                    glucose = lab.optString("value", "").replace(Regex("[^0-9.]"), "").toDoubleOrNull()
                    break
                }
            }
        }

        if (glucose != null) {
            val a1c = glucoseToA1c(glucose!!)
            val result = String.format("%.1f", a1c)

            val content = """
                |═══════════════════════════════════
                |🧮 GLUCOSE TO A1c
                |═══════════════════════════════════
                |
                |Avg Glucose: ${String.format("%.0f", glucose)} mg/dL
                |
                |📊 Est. A1c = $result%
                |
                |───────────────────────────────────
                |Formula: A1c = (Glucose + 46.7) / 28.7
            """.trimMargin()

            showDataOverlay("Glucose to A1c", content)
            speakFeedback("Average glucose of ${String.format("%.0f", glucose)} equals estimated A1c of $result percent")
        } else {
            speakFeedback("No glucose found in labs")
            showDataOverlay("Glucose to A1c", "No glucose found in patient labs.\n\nLoad a patient with glucose result.")
        }
    }

    /**
     * Calculate and show MAP
     */
    private fun calculateAndShowMAP() {
        var systolic: Double? = null
        var diastolic: Double? = null

        // Check captured vitals first
        for (vital in capturedVitals) {
            if (vital.type == VitalType.BLOOD_PRESSURE) {
                val parts = vital.value.split("/")
                if (parts.size == 2) {
                    systolic = parts[0].replace(Regex("[^0-9]"), "").toDoubleOrNull()
                    diastolic = parts[1].replace(Regex("[^0-9]"), "").toDoubleOrNull()
                }
            }
        }

        // Try patient vitals if not captured
        if (systolic == null || diastolic == null) {
            currentPatientData?.optJSONArray("vitals")?.let { vitals ->
                for (i in 0 until vitals.length()) {
                    val v = vitals.getJSONObject(i)
                    val name = v.optString("name", "").lowercase()
                    val value = v.optString("value", "").replace(Regex("[^0-9.]"), "").toDoubleOrNull()

                    when {
                        name.contains("systolic") && systolic == null -> systolic = value
                        name.contains("diastolic") && diastolic == null -> diastolic = value
                    }
                }
            }
        }

        if (systolic != null && diastolic != null) {
            val map = calculateMAP(systolic!!, diastolic!!)
            val result = String.format("%.0f", map)

            val interpretation = when {
                map < 60 -> "Low - risk of organ hypoperfusion"
                map < 70 -> "Low-normal"
                map <= 100 -> "Normal (70-100)"
                map <= 110 -> "High-normal"
                else -> "High"
            }

            val content = """
                |═══════════════════════════════════
                |🧮 MEAN ARTERIAL PRESSURE
                |═══════════════════════════════════
                |
                |BP: ${systolic!!.toInt()}/${diastolic!!.toInt()} mmHg
                |
                |📊 MAP = $result mmHg
                |
                |$interpretation
                |
                |───────────────────────────────────
                |Formula: DBP + (SBP - DBP) / 3
                |Target: ≥65 mmHg for organ perfusion
            """.trimMargin()

            showDataOverlay("MAP Result", content)
            speakFeedback("Mean arterial pressure is $result. $interpretation")
        } else {
            speakFeedback("Need blood pressure. Say: BP 120 over 80")
            showDataOverlay("MAP Calculator",
                "Missing blood pressure.\n\n" +
                "Say: \"BP 120 over 80\"\n\n" +
                "Or load a patient with vitals.")
        }
    }

    /**
     * Calculate and show Creatinine Clearance
     */
    private fun calculateAndShowCrCl() {
        var creatinine: Double? = null
        var age: Int? = null
        var weightKg: Double? = null
        var isFemale: Boolean? = null

        currentPatientData?.let { patient ->
            // Age
            patient.optString("date_of_birth", "")?.let { dob ->
                if (dob.isNotEmpty()) {
                    try {
                        val birthYear = dob.substring(0, 4).toInt()
                        val currentYear = java.util.Calendar.getInstance().get(java.util.Calendar.YEAR)
                        age = currentYear - birthYear
                    } catch (e: Exception) {}
                }
            }

            // Gender
            val gender = patient.optString("gender", "").lowercase()
            isFemale = gender == "female" || gender == "f"

            // Creatinine
            patient.optJSONArray("labs")?.let { labs ->
                for (i in 0 until labs.length()) {
                    val lab = labs.getJSONObject(i)
                    val name = lab.optString("name", "").lowercase()
                    if (name.contains("creatinine") && !name.contains("clearance")) {
                        creatinine = lab.optString("value", "").replace(Regex("[^0-9.]"), "").toDoubleOrNull()
                        break
                    }
                }
            }

            // Weight
            patient.optJSONArray("vitals")?.let { vitals ->
                for (i in 0 until vitals.length()) {
                    val v = vitals.getJSONObject(i)
                    val name = v.optString("name", "").lowercase()
                    if (name.contains("weight")) {
                        val value = v.optString("value", "").replace(Regex("[^0-9.]"), "").toDoubleOrNull()
                        val unit = v.optString("unit", "").lowercase()
                        if (value != null) {
                            weightKg = if (unit.contains("lb")) value * 0.453592 else value
                        }
                        break
                    }
                }
            }
        }

        // Check captured vitals for weight
        if (weightKg == null) {
            for (vital in capturedVitals) {
                if (vital.type == VitalType.WEIGHT) {
                    val value = vital.value.replace(Regex("[^0-9.]"), "").toDoubleOrNull()
                    if (value != null) {
                        weightKg = if (vital.unit.contains("lb", ignoreCase = true)) value * 0.453592 else value
                    }
                }
            }
        }

        if (creatinine != null && age != null && weightKg != null && isFemale != null) {
            val crcl = calculateCrCl(creatinine!!, age!!, weightKg!!, isFemale!!)
            val result = String.format("%.0f", crcl)

            val interpretation = when {
                crcl >= 90 -> "Normal"
                crcl >= 60 -> "Mild impairment"
                crcl >= 30 -> "Moderate impairment"
                crcl >= 15 -> "Severe impairment"
                else -> "Kidney failure"
            }

            val content = """
                |═══════════════════════════════════
                |🧮 CREATININE CLEARANCE
                |═══════════════════════════════════
                |
                |Creatinine: $creatinine mg/dL
                |Age: $age years
                |Weight: ${String.format("%.1f", weightKg)} kg
                |Sex: ${if (isFemale!!) "Female" else "Male"}
                |
                |📊 CrCl = $result mL/min
                |
                |$interpretation
                |
                |───────────────────────────────────
                |Cockcroft-Gault formula
                |Use for drug dosing adjustments
            """.trimMargin()

            showDataOverlay("CrCl Result", content)
            speakFeedback("Creatinine clearance is $result mL per minute. $interpretation")
        } else {
            speakFeedback("Need creatinine, age, weight, and sex for creatinine clearance")
            showDataOverlay("CrCl Calculator",
                "Missing data:\n\n" +
                "• Creatinine: ${if (creatinine != null) "$creatinine mg/dL ✓" else "❌ needed"}\n" +
                "• Age: ${if (age != null) "$age years ✓" else "❌ needed"}\n" +
                "• Weight: ${if (weightKg != null) "${String.format("%.1f", weightKg)} kg ✓" else "❌ needed"}\n" +
                "• Sex: ${if (isFemale != null) (if (isFemale!!) "Female" else "Male") + " ✓" else "❌ needed"}\n\n" +
                "Load patient and capture weight if needed")
        }
    }

    /**
     * Calculate and show CHADS₂-VASc score
     */
    private fun calculateAndShowCHADSVASc() {
        // This would need more patient history data
        // For now, show the criteria
        val content = """
            |═══════════════════════════════════
            |🧮 CHADS₂-VASc SCORE
            |═══════════════════════════════════
            |
            |Score criteria (1 point each):
            |• CHF / LV dysfunction
            |• Hypertension
            |• Age 65-74
            |• Diabetes
            |• Vascular disease (MI, PAD, aortic plaque)
            |• Female sex
            |
            |2 points each:
            |• Age ≥75
            |• Prior Stroke/TIA/thromboembolism
            |
            |───────────────────────────────────
            |ANTICOAGULATION:
            |0 = Low risk (no anticoag)
            |1 = Low-moderate (consider anticoag)
            |≥2 = Anticoagulation recommended
            |
            |───────────────────────────────────
            |Say conditions to calculate:
            |"Patient has CHF and hypertension"
        """.trimMargin()

        showDataOverlay("CHADS₂-VASc", content)
        speakFeedback("CHADS VASc score requires patient history. See criteria on screen.")
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // VOICE ORDERS - Order Processing Functions
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Find lab order by alias text
     */
    private fun findLabByAlias(text: String): LabOrderInfo? {
        val lower = text.lowercase().trim()
        for ((_, lab) in labOrders) {
            if (lab.aliases.any { lower.contains(it) }) {
                return lab
            }
        }
        return null
    }

    /**
     * Find imaging order by alias text
     */
    private fun findImagingByAlias(text: String): ImagingOrderInfo? {
        val lower = text.lowercase().trim()
        for ((_, imaging) in imagingOrders) {
            if (imaging.aliases.any { lower.contains(it) }) {
                return imaging
            }
        }
        return null
    }

    /**
     * Find medication order by alias text
     */
    private fun findMedicationByAlias(text: String): MedicationOrderInfo? {
        val lower = text.lowercase().trim()
        for ((_, med) in medicationOrders) {
            if (med.aliases.any { lower.contains(it) }) {
                return med
            }
        }
        return null
    }

    /**
     * Check if text is a lab order
     */
    private fun isLabOrder(text: String): Boolean {
        return findLabByAlias(text) != null
    }

    /**
     * Check if text is an imaging order
     */
    private fun isImagingOrder(text: String): Boolean {
        return findImagingByAlias(text) != null
    }

    /**
     * Check if text is a medication order
     */
    private fun isMedicationOrder(text: String): Boolean {
        return findMedicationByAlias(text) != null
    }

    /**
     * Process a lab order voice command
     */
    private fun processLabOrder(text: String) {
        val lab = findLabByAlias(text)
        if (lab == null) {
            speakFeedback("Lab test not recognized. Try: CBC, CMP, BMP, UA, lipids, A1C, or TSH.")
            return
        }

        // Check for duplicate
        val duplicateWarning = checkDuplicateOrder(OrderType.LAB, lab.name)
        val warnings = listOfNotNull(duplicateWarning)

        val order = Order(
            type = OrderType.LAB,
            name = lab.name,
            displayName = lab.displayName,
            safetyWarnings = warnings,
            requiresConfirmation = warnings.isNotEmpty()
        )

        if (order.requiresConfirmation) {
            pendingConfirmationOrder = order
            speakFeedback("${duplicateWarning?.message} Do you still want to order? Say yes or no.")
        } else {
            addOrderToQueue(order)
            speakFeedback("Ordered ${lab.displayName}")
        }
    }

    /**
     * Process an imaging order voice command
     */
    private fun processImagingOrder(text: String) {
        val imaging = findImagingByAlias(text)
        if (imaging == null) {
            speakFeedback("Imaging study not recognized. Try: chest x-ray, CT head, MRI brain, or ultrasound.")
            return
        }

        // Parse contrast preference
        val lower = text.lowercase()
        val contrast = when {
            lower.contains("without contrast") -> false
            lower.contains("with and without") -> null  // Both phases
            lower.contains("with contrast") -> true
            else -> null  // Not specified
        }

        // Parse laterality
        val laterality = when {
            lower.contains("left") -> "left"
            lower.contains("right") -> "right"
            lower.contains("bilateral") -> "bilateral"
            else -> null
        }

        val warnings = mutableListOf<SafetyWarning>()

        // Check for duplicate
        checkDuplicateOrder(OrderType.IMAGING, imaging.name)?.let { warnings.add(it) }

        // Check metformin + contrast warning
        if (contrast == true) {
            checkMetforminContrastWarning()?.let { warnings.add(it) }
        }

        val contrastText = when (contrast) {
            true -> " with contrast"
            false -> " without contrast"
            null -> ""
        }

        val order = Order(
            type = OrderType.IMAGING,
            name = imaging.name,
            displayName = "${imaging.displayName}$contrastText",
            contrast = contrast,
            bodyPart = imaging.bodyPart,
            laterality = laterality,
            safetyWarnings = warnings,
            requiresConfirmation = warnings.isNotEmpty()
        )

        if (order.requiresConfirmation) {
            pendingConfirmationOrder = order
            val warningMsg = warnings.joinToString(". ") { it.message }
            if (warnings.any { it.severity == "high" }) {
                speakFeedback("Critical warning: $warningMsg Say yes to confirm or no to cancel.")
            } else {
                speakFeedback("Warning: $warningMsg Say yes to confirm or no to cancel.")
            }
        } else {
            addOrderToQueue(order)
            speakFeedback("Ordered ${order.displayName}")
        }
    }

    /**
     * Process a medication order voice command
     */
    private fun processMedicationOrder(text: String) {
        val med = findMedicationByAlias(text)
        if (med == null) {
            speakFeedback("Medication not recognized. Try common medications like amoxicillin, ibuprofen, or prednisone.")
            return
        }

        val lower = text.lowercase()

        // Parse dose (e.g., "500mg", "500 mg")
        val dosePattern = Regex("(\\d+)\\s*(mg|mcg|ml|g)")
        val doseMatch = dosePattern.find(lower)
        val dose = doseMatch?.value?.replace(" ", "") ?: med.commonDoses.firstOrNull()

        // Parse frequency
        var frequency: String? = null
        for ((alias, canonical) in frequencyAliases) {
            if (lower.contains(alias)) {
                frequency = canonical
                break
            }
        }
        frequency = frequency ?: med.commonFrequencies.firstOrNull()

        // Parse duration (e.g., "for 10 days", "for 2 weeks")
        val durationPattern = Regex("for\\s+(\\d+)\\s*(days?|weeks?)")
        val durationMatch = durationPattern.find(lower)
        val duration = durationMatch?.value?.replace("for ", "") ?: med.commonDurations.firstOrNull()

        // Check if PRN
        val prn = lower.contains("prn") || lower.contains("as needed") || lower.contains("when needed")

        // Safety checks
        val warnings = mutableListOf<SafetyWarning>()

        // 1. Allergy check
        checkMedicationAllergy(med)?.let { warnings.add(it) }

        // 2. Drug interaction check
        warnings.addAll(checkMedicationInteractions(med))

        // 3. Duplicate check
        checkDuplicateOrder(OrderType.MEDICATION, med.name)?.let { warnings.add(it) }

        // Build details string
        val details = buildString {
            append(dose ?: "")
            frequency?.let { append(" $it") }
            duration?.let { append(" x $it") }
            if (prn) append(" PRN")
        }.trim()

        val order = Order(
            type = OrderType.MEDICATION,
            name = med.name,
            displayName = med.name,
            details = details,
            dose = dose,
            frequency = frequency,
            duration = duration,
            route = med.route,
            prn = prn,
            safetyWarnings = warnings,
            requiresConfirmation = warnings.isNotEmpty()
        )

        if (order.requiresConfirmation) {
            pendingConfirmationOrder = order
            val highWarnings = warnings.filter { it.severity == "high" }
            if (highWarnings.isNotEmpty()) {
                val warningMsg = highWarnings.joinToString(". ") { it.message }
                speakFeedback("Critical warning: $warningMsg Do you still want to prescribe? Say yes to confirm or no to cancel.")
            } else {
                speakFeedback("Warning: ${warnings.first().message} Say yes to confirm or no to cancel.")
            }
        } else {
            addOrderToQueue(order)
            speakFeedback("Prescribed ${med.name} $details")
        }
    }

    /**
     * Check for duplicate order in queue
     */
    private fun checkDuplicateOrder(type: OrderType, name: String): SafetyWarning? {
        val duplicate = orderQueue.find { it.type == type && it.name.equals(name, ignoreCase = true) }
        return if (duplicate != null) {
            SafetyWarning(
                type = SafetyWarningType.DUPLICATE_ORDER,
                severity = "moderate",
                message = "$name has already been ordered in this session"
            )
        } else null
    }

    /**
     * Check for allergy to medication
     */
    private fun checkMedicationAllergy(med: MedicationOrderInfo): SafetyWarning? {
        val patient = currentPatientData ?: return null
        val allergies = patient.optJSONArray("allergies") ?: return null

        val patientAllergies = mutableListOf<String>()
        for (i in 0 until allergies.length()) {
            patientAllergies.add(allergies.getString(i).lowercase())
        }

        // Check cross-reactivity
        val crossMatch = med.allergyCrossReact.find { cross ->
            patientAllergies.any { allergy ->
                allergy.contains(cross.lowercase()) || cross.lowercase().contains(allergy)
            }
        }

        // Check direct match
        val directMatch = patientAllergies.find { allergy ->
            med.name.lowercase().contains(allergy) || allergy.contains(med.name.lowercase()) ||
            med.aliases.any { alias -> allergy.contains(alias) || alias.contains(allergy) }
        }

        return if (crossMatch != null || directMatch != null) {
            SafetyWarning(
                type = SafetyWarningType.ALLERGY,
                severity = "high",
                message = "Patient has documented allergy to ${directMatch ?: crossMatch}. ${med.name} may cause allergic reaction.",
                details = if (med.allergyCrossReact.isNotEmpty()) "Cross-reactivity: ${med.allergyCrossReact.joinToString(", ")}" else ""
            )
        } else null
    }

    /**
     * Check for drug interactions with current medications
     */
    private fun checkMedicationInteractions(med: MedicationOrderInfo): List<SafetyWarning> {
        val patient = currentPatientData ?: return emptyList()
        val currentMeds = patient.optJSONArray("medications") ?: return emptyList()

        val warnings = mutableListOf<SafetyWarning>()
        val patientMedNames = mutableListOf<String>()
        for (i in 0 until currentMeds.length()) {
            patientMedNames.add(currentMeds.getString(i).lowercase())
        }

        for (interactingDrug in med.interactionsWith) {
            val match = patientMedNames.find { patientMed ->
                patientMed.contains(interactingDrug.lowercase()) ||
                interactingDrug.lowercase().contains(patientMed)
            }
            if (match != null) {
                // Determine severity based on drug class
                val severity = when {
                    med.drugClass == "opioid" && (interactingDrug.contains("benzodiazepine") || interactingDrug.contains("alcohol")) -> "high"
                    interactingDrug.contains("warfarin") -> "high"
                    med.drugClass == "nsaid" && interactingDrug.contains("lithium") -> "high"
                    else -> "moderate"
                }
                warnings.add(SafetyWarning(
                    type = SafetyWarningType.DRUG_INTERACTION,
                    severity = severity,
                    message = "${med.name} interacts with patient's current medication: $match",
                    details = "Use with caution"
                ))
            }
        }

        return warnings
    }

    /**
     * Check for metformin + contrast warning
     */
    private fun checkMetforminContrastWarning(): SafetyWarning? {
        val patient = currentPatientData ?: return null
        val currentMeds = patient.optJSONArray("medications") ?: return null

        for (i in 0 until currentMeds.length()) {
            val med = currentMeds.getString(i).lowercase()
            if (med.contains("metformin") || med.contains("glucophage")) {
                return SafetyWarning(
                    type = SafetyWarningType.CONTRAINDICATION,
                    severity = "high",
                    message = "Patient takes metformin. Hold metformin 48 hours before and after contrast imaging to prevent lactic acidosis.",
                    details = "Recommend holding metformin around contrast administration"
                )
            }
        }
        return null
    }

    /**
     * Add order to queue, auto-add to Plan section, and auto-push to EHR
     */
    private fun addOrderToQueue(order: Order) {
        val confirmedOrder = order.copy(status = OrderStatus.CONFIRMED)
        orderQueue.add(confirmedOrder)
        saveOrdersToPrefs()
        addOrderToPlanSection(confirmedOrder)
        Log.d(TAG, "Order added: ${order.name}, queue size: ${orderQueue.size}")

        // Auto-push to EHR
        pushSingleOrderToEhr(confirmedOrder)
    }

    /**
     * Push a single order to EHR immediately
     */
    private fun pushSingleOrderToEhr(order: Order) {
        val patientId = currentPatientData?.optString("patient_id", "") ?: ""
        if (patientId.isEmpty() || !isNetworkAvailable()) {
            // Will sync later
            return
        }

        Thread {
            try {
                val requestBody = JSONObject().apply {
                    put("patient_id", patientId)
                    put("order_type", order.type.name)
                    put("code", order.name)
                    put("display_name", order.displayName)
                    put("status", "active")
                    put("priority", "routine")
                    put("requester_name", clinicianName)
                    put("notes", order.details)
                    order.dose?.let { put("dose", it) }
                    order.frequency?.let { put("frequency", it) }
                    order.duration?.let { put("duration", it) }
                    order.route?.let { put("route", it) }
                    put("prn", order.prn)
                    order.bodyPart?.let { put("body_site", it) }
                    order.laterality?.let { put("laterality", it) }
                    order.contrast?.let { put("contrast", it) }
                }

                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/orders/push")
                    .post(requestBody.toString().toRequestBody("application/json".toMediaType()))
                    .build()

                val response = httpClient.newCall(request).execute()
                val body = response.body?.string()
                val result = JSONObject(body ?: "{}")

                if (result.optBoolean("success", false)) {
                    // Remove from local queue after successful push
                    runOnUiThread {
                        orderQueue.removeAll { it.id == order.id }
                        saveOrdersToPrefs()
                    }
                    Log.d(TAG, "Auto-pushed order: ${order.displayName}")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Auto-push order failed: ${e.message}")
            }
        }.start()
    }

    /**
     * Save orders to SharedPreferences
     */
    private fun saveOrdersToPrefs() {
        try {
            val ordersJson = org.json.JSONArray()
            for (order in orderQueue) {
                ordersJson.put(order.toJson())
            }
            cachePrefs.edit()
                .putString(ORDERS_KEY, ordersJson.toString())
                .putString(ORDERS_PATIENT_KEY, currentPatientData?.optString("patient_id", "") ?: "")
                .apply()
        } catch (e: Exception) {
            Log.e(TAG, "Error saving orders: ${e.message}")
        }
    }

    /**
     * Load orders from SharedPreferences
     */
    private fun loadOrdersFromPrefs() {
        try {
            val currentPatientId = currentPatientData?.optString("patient_id", "") ?: ""
            val savedPatientId = cachePrefs.getString(ORDERS_PATIENT_KEY, "") ?: ""

            // Only load if same patient
            if (currentPatientId.isNotEmpty() && currentPatientId == savedPatientId) {
                val ordersStr = cachePrefs.getString(ORDERS_KEY, "[]") ?: "[]"
                val ordersJson = org.json.JSONArray(ordersStr)
                orderQueue.clear()
                for (i in 0 until ordersJson.length()) {
                    orderQueue.add(Order.fromJson(ordersJson.getJSONObject(i)))
                }
                Log.d(TAG, "Loaded ${orderQueue.size} orders for patient $currentPatientId")
            } else {
                // Different patient - clear orders
                orderQueue.clear()
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error loading orders: ${e.message}")
            orderQueue.clear()
        }
    }

    /**
     * Add order to Plan section of note
     */
    private fun addOrderToPlanSection(order: Order) {
        val orderText = when (order.type) {
            OrderType.LAB -> "• Order ${order.displayName}"
            OrderType.IMAGING -> {
                val contrastText = when (order.contrast) {
                    true -> " with contrast"
                    false -> " without contrast"
                    else -> ""
                }
                "• Order ${order.displayName}$contrastText"
            }
            OrderType.MEDICATION -> "• Rx: ${order.name} ${order.details}"
        }

        // If note is being edited, append to plan section
        if (noteEditText != null && editableNoteContent != null) {
            appendToNoteSection("plan", orderText)
        } else {
            // Store for when note is generated
            pendingPlanItems.add(orderText)
        }
    }

    /**
     * Show order queue overlay
     */
    private fun showOrderQueue() {
        if (orderQueue.isEmpty()) {
            val emptyText = """
                |📋 NO PENDING ORDERS
                |${"─".repeat(30)}
                |
                |Voice Commands:
                |• "Order CBC" - Order a lab test
                |• "Order chest x-ray" - Order imaging
                |• "Prescribe amoxicillin 500mg TID" - Prescribe medication
                |
                |Available Labs:
                |CBC, CMP, BMP, UA, Lipids, TSH, A1c, PT/INR, Troponin
                |
                |Available Imaging:
                |Chest X-ray, CT Head/Chest/Abdomen, MRI Brain/Spine, Echo
                |
                |Say "close" to dismiss
            """.trimMargin()
            showDataOverlay("📋 Orders", emptyText)
            speakFeedback("No pending orders")
            return
        }

        val sb = StringBuilder()

        // Group by type
        val labs = orderQueue.filter { it.type == OrderType.LAB }
        val imaging = orderQueue.filter { it.type == OrderType.IMAGING }
        val meds = orderQueue.filter { it.type == OrderType.MEDICATION }

        if (labs.isNotEmpty()) {
            sb.appendLine("🔬 LABS (${labs.size})")
            labs.forEachIndexed { index, order ->
                sb.appendLine("  ${index + 1}. ${order.displayName}")
            }
            sb.appendLine()
        }

        if (imaging.isNotEmpty()) {
            sb.appendLine("📷 IMAGING (${imaging.size})")
            imaging.forEachIndexed { index, order ->
                sb.appendLine("  ${index + 1}. ${order.displayName}")
            }
            sb.appendLine()
        }

        if (meds.isNotEmpty()) {
            sb.appendLine("💊 MEDICATIONS (${meds.size})")
            meds.forEachIndexed { index, order ->
                sb.appendLine("  ${index + 1}. ${order.name} ${order.details}")
                if (order.safetyWarnings.isNotEmpty()) {
                    order.safetyWarnings.forEach { warning ->
                        val icon = if (warning.severity == "high") "🚨" else "⚠️"
                        sb.appendLine("      $icon ${warning.message}")
                    }
                }
            }
            sb.appendLine()
        }

        sb.appendLine("─".repeat(40))
        sb.appendLine("Voice Commands:")
        sb.appendLine("• \"Cancel order\" - Remove last order")
        sb.appendLine("• \"Clear all orders\" - Remove all")
        sb.appendLine("• \"Close\" - Dismiss")

        showDataOverlay("📋 Orders (${orderQueue.size})", sb.toString())
        speakFeedback("${orderQueue.size} orders pending")
    }

    /**
     * Cancel the last order in queue
     */
    private fun cancelLastOrder() {
        if (orderQueue.isEmpty()) {
            speakFeedback("No orders to cancel")
            return
        }
        val removed = orderQueue.removeAt(orderQueue.size - 1)
        saveOrdersToPrefs()
        speakFeedback("Cancelled order for ${removed.displayName}")
        Log.d(TAG, "Cancelled order: ${removed.name}")
    }

    /**
     * Clear all orders in queue
     */
    private fun clearAllOrders() {
        val count = orderQueue.size
        orderQueue.clear()
        pendingPlanItems.clear()
        saveOrdersToPrefs()
        speakFeedback("Cleared $count orders")
        hideDataOverlay()
    }

    /**
     * Confirm pending order after safety warning
     */
    private fun confirmPendingOrder() {
        val order = pendingConfirmationOrder ?: return
        pendingConfirmationOrder = null
        addOrderToQueue(order)

        val message = when (order.type) {
            OrderType.LAB -> "Ordered ${order.displayName}"
            OrderType.IMAGING -> "Ordered ${order.displayName}"
            OrderType.MEDICATION -> "Prescribed ${order.name} ${order.details}"
        }
        speakFeedback(message)
    }

    /**
     * Reject pending order after safety warning
     */
    private fun rejectPendingOrder() {
        val order = pendingConfirmationOrder ?: return
        pendingConfirmationOrder = null
        speakFeedback("Order cancelled")
        Log.d(TAG, "Order rejected: ${order.name}")
    }

    /**
     * Get pending plan items for note generation
     */
    private fun getPendingOrdersForPlan(): String {
        if (pendingPlanItems.isEmpty()) return ""
        val items = pendingPlanItems.joinToString("\n")
        return items
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // DIFFERENTIAL DIAGNOSIS (DDx) FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Generate AI-powered differential diagnosis from clinical data.
     * Uses extracted entities from ambient mode, captured vitals, and patient chart.
     */
    private fun generateDifferentialDiagnosis() {
        if (currentPatientData == null) {
            speakFeedback("Please load a patient first")
            Toast.makeText(this, "No patient loaded", Toast.LENGTH_SHORT).show()
            return
        }

        lifecycleScope.launch {
            try {
                speakFeedback("Generating differential diagnosis")
                Toast.makeText(this@MainActivity, "🔍 Analyzing clinical data...", Toast.LENGTH_SHORT).show()

                // Build request from available data
                val requestJson = org.json.JSONObject().apply {
                    // Chief complaint - from ambient entities or patient
                    val chiefComplaint = if (extractedEntities.symptoms.isNotEmpty()) {
                        extractedEntities.symptoms.firstOrNull() ?: "Unspecified"
                    } else {
                        "General evaluation"
                    }
                    put("chief_complaint", chiefComplaint)

                    // Symptoms from ambient mode
                    if (extractedEntities.symptoms.isNotEmpty()) {
                        put("symptoms", org.json.JSONArray(extractedEntities.symptoms))
                    }

                    // Vitals - from captured vitals or ambient
                    val vitalsMap = org.json.JSONObject()
                    capturedVitals.forEach { vital ->
                        vitalsMap.put(vital.type.name, vital.value)
                    }
                    if (extractedEntities.vitalsMentioned.isNotEmpty()) {
                        extractedEntities.vitalsMentioned.forEach { (key, value) ->
                            vitalsMap.put(key, value)
                        }
                    }
                    if (vitalsMap.length() > 0) {
                        put("vitals", vitalsMap)
                    }

                    // Age from patient data
                    currentPatientData?.let { patient ->
                        val dob = patient.optString("birthDate", "")
                        if (dob.isNotEmpty()) {
                            try {
                                val birthYear = dob.substring(0, 4).toInt()
                                val age = java.util.Calendar.getInstance().get(java.util.Calendar.YEAR) - birthYear
                                put("age", age)
                            } catch (e: Exception) { /* ignore */ }
                        }
                        put("gender", patient.optString("gender", ""))
                    }

                    // Medical history from conditions
                    val conditions = currentPatientData?.optJSONArray("conditions")
                    if (conditions != null && conditions.length() > 0) {
                        val history = org.json.JSONArray()
                        for (i in 0 until minOf(conditions.length(), 10)) {
                            val cond = conditions.getJSONObject(i)
                            history.put(cond.optString("display", ""))
                        }
                        put("medical_history", history)
                    }

                    // Medications
                    val meds = currentPatientData?.optJSONArray("medications")
                    if (meds != null && meds.length() > 0) {
                        val medList = org.json.JSONArray()
                        for (i in 0 until minOf(meds.length(), 10)) {
                            val med = meds.getJSONObject(i)
                            medList.put(med.optString("name", ""))
                        }
                        put("medications", medList)
                    }

                    // Allergies
                    val allergies = currentPatientData?.optJSONArray("allergies")
                    if (allergies != null && allergies.length() > 0) {
                        val allergyList = org.json.JSONArray()
                        for (i in 0 until minOf(allergies.length(), 10)) {
                            val allergy = allergies.getJSONObject(i)
                            allergyList.put(allergy.optString("substance", ""))
                        }
                        put("allergies", allergyList)
                    }
                }

                // Make API call
                val response = withContext(Dispatchers.IO) {
                    val url = java.net.URL("$EHR_PROXY_URL/api/v1/ddx/generate")
                    val connection = url.openConnection() as java.net.HttpURLConnection
                    connection.requestMethod = "POST"
                    connection.setRequestProperty("Content-Type", "application/json")
                    connection.doOutput = true

                    connection.outputStream.use { os ->
                        os.write(requestJson.toString().toByteArray())
                    }

                    if (connection.responseCode == 200) {
                        connection.inputStream.bufferedReader().use { it.readText() }
                    } else {
                        val error = connection.errorStream?.bufferedReader()?.use { it.readText() } ?: "Unknown error"
                        throw Exception("DDx failed: ${connection.responseCode} - $error")
                    }
                }

                // Parse response
                val json = org.json.JSONObject(response)
                val differentials = mutableListOf<DifferentialDiagnosis>()
                val diffsArray = json.getJSONArray("differentials")
                for (i in 0 until diffsArray.length()) {
                    val d = diffsArray.getJSONObject(i)
                    differentials.add(DifferentialDiagnosis(
                        rank = d.getInt("rank"),
                        diagnosis = d.getString("diagnosis"),
                        icd10Code = d.getString("icd10_code"),
                        likelihood = d.getString("likelihood"),
                        supportingFindings = d.optJSONArray("supporting_findings")?.let { arr ->
                            (0 until arr.length()).map { arr.getString(it) }
                        } ?: emptyList(),
                        redFlags = d.optJSONArray("red_flags")?.let { arr ->
                            (0 until arr.length()).map { arr.getString(it) }
                        } ?: emptyList(),
                        nextSteps = d.optJSONArray("next_steps")?.let { arr ->
                            (0 until arr.length()).map { arr.getString(it) }
                        } ?: emptyList()
                    ))
                }

                val urgentConsiderations = json.optJSONArray("urgent_considerations")?.let { arr ->
                    (0 until arr.length()).map { arr.getString(it) }
                } ?: emptyList()

                lastDdxResponse = DdxResponse(
                    differentials = differentials,
                    clinicalReasoning = json.optString("clinical_reasoning", ""),
                    urgentConsiderations = urgentConsiderations,
                    timestamp = json.optString("timestamp", "")
                )

                // Display results
                showDdxResults(lastDdxResponse!!)

            } catch (e: Exception) {
                Log.e(TAG, "DDx generation failed", e)
                speakFeedback("Differential diagnosis failed")
                Toast.makeText(this@MainActivity, "❌ DDx Error: ${e.message}", Toast.LENGTH_SHORT).show()
            }
        }
    }

    /**
     * Display differential diagnosis results in AR overlay
     */
    private fun showDdxResults(response: DdxResponse) {
        val rootView = window.decorView.findViewById<android.view.ViewGroup>(android.R.id.content)

        dataOverlay = android.widget.FrameLayout(this).apply {
            setBackgroundColor(0xEE0A1628.toInt())
            isClickable = true

            val innerLayout = android.widget.LinearLayout(context).apply {
                orientation = android.widget.LinearLayout.VERTICAL
                setPadding(32, 32, 32, 32)
                layoutParams = android.widget.FrameLayout.LayoutParams(
                    android.widget.FrameLayout.LayoutParams.MATCH_PARENT,
                    android.widget.FrameLayout.LayoutParams.MATCH_PARENT
                )
            }

            // Header
            val header = TextView(context).apply {
                text = "🔍 DIFFERENTIAL DIAGNOSIS"
                textSize = getTitleFontSize()
                setTextColor(0xFF10B981.toInt())
                setPadding(0, 0, 0, 8)
            }
            innerLayout.addView(header)

            // Safety disclaimer
            val disclaimer = TextView(context).apply {
                text = "⚠️ For clinical decision support only - not a diagnosis"
                textSize = getContentFontSize() - 2f
                setTextColor(0xFFFBBF24.toInt())
                setPadding(0, 0, 0, 16)
            }
            innerLayout.addView(disclaimer)

            // Scrollable content
            val scrollView = android.widget.ScrollView(context).apply {
                layoutParams = android.widget.LinearLayout.LayoutParams(
                    android.widget.LinearLayout.LayoutParams.MATCH_PARENT, 0, 1f
                )
            }

            val contentLayout = android.widget.LinearLayout(context).apply {
                orientation = android.widget.LinearLayout.VERTICAL
            }

            // Differentials list
            response.differentials.forEach { ddx ->
                val ddxCard = android.widget.LinearLayout(context).apply {
                    orientation = android.widget.LinearLayout.VERTICAL
                    setBackgroundColor(0xFF1E293B.toInt())
                    setPadding(16, 12, 16, 12)
                    val params = android.widget.LinearLayout.LayoutParams(
                        android.widget.LinearLayout.LayoutParams.MATCH_PARENT,
                        android.widget.LinearLayout.LayoutParams.WRAP_CONTENT
                    )
                    params.bottomMargin = 12
                    layoutParams = params
                }

                // Likelihood indicator
                val likelihoodColor = when (ddx.likelihood.lowercase()) {
                    "high" -> 0xFFEF4444.toInt()  // Red
                    "moderate" -> 0xFFFBBF24.toInt()  // Yellow
                    else -> 0xFF94A3B8.toInt()  // Gray
                }

                // Diagnosis title with rank and likelihood
                val titleText = TextView(context).apply {
                    text = "${ddx.rank}. [${ddx.likelihood.uppercase()}] ${ddx.diagnosis} (${ddx.icd10Code})"
                    textSize = getContentFontSize()
                    setTextColor(likelihoodColor)
                    setTypeface(null, android.graphics.Typeface.BOLD)
                }
                ddxCard.addView(titleText)

                // Supporting findings
                if (ddx.supportingFindings.isNotEmpty()) {
                    val supportingText = TextView(context).apply {
                        text = "   ✓ Supporting: ${ddx.supportingFindings.joinToString(", ")}"
                        textSize = getContentFontSize() - 2f
                        setTextColor(0xFF10B981.toInt())
                        setPadding(0, 4, 0, 0)
                    }
                    ddxCard.addView(supportingText)
                }

                // Red flags
                if (ddx.redFlags.isNotEmpty()) {
                    val redFlagsText = TextView(context).apply {
                        text = "   🚩 Red flags: ${ddx.redFlags.joinToString(", ")}"
                        textSize = getContentFontSize() - 2f
                        setTextColor(0xFFEF4444.toInt())
                        setPadding(0, 4, 0, 0)
                    }
                    ddxCard.addView(redFlagsText)
                }

                // Next steps
                if (ddx.nextSteps.isNotEmpty()) {
                    val nextStepsText = TextView(context).apply {
                        text = "   → Next: ${ddx.nextSteps.joinToString(", ")}"
                        textSize = getContentFontSize() - 2f
                        setTextColor(0xFF60A5FA.toInt())
                        setPadding(0, 4, 0, 0)
                    }
                    ddxCard.addView(nextStepsText)
                }

                contentLayout.addView(ddxCard)
            }

            // Clinical reasoning
            if (response.clinicalReasoning.isNotEmpty()) {
                val reasoningCard = android.widget.LinearLayout(context).apply {
                    orientation = android.widget.LinearLayout.VERTICAL
                    setBackgroundColor(0xFF1E3A5F.toInt())
                    setPadding(16, 12, 16, 12)
                    val params = android.widget.LinearLayout.LayoutParams(
                        android.widget.LinearLayout.LayoutParams.MATCH_PARENT,
                        android.widget.LinearLayout.LayoutParams.WRAP_CONTENT
                    )
                    params.topMargin = 8
                    layoutParams = params
                }

                val reasoningTitle = TextView(context).apply {
                    text = "💡 CLINICAL REASONING"
                    textSize = getContentFontSize()
                    setTextColor(0xFF60A5FA.toInt())
                    setTypeface(null, android.graphics.Typeface.BOLD)
                }
                reasoningCard.addView(reasoningTitle)

                val reasoningText = TextView(context).apply {
                    text = response.clinicalReasoning
                    textSize = getContentFontSize() - 1f
                    setTextColor(0xFFE2E8F0.toInt())
                    setPadding(0, 8, 0, 0)
                }
                reasoningCard.addView(reasoningText)

                contentLayout.addView(reasoningCard)
            }

            // Urgent considerations
            if (response.urgentConsiderations.isNotEmpty()) {
                val urgentCard = android.widget.LinearLayout(context).apply {
                    orientation = android.widget.LinearLayout.VERTICAL
                    setBackgroundColor(0xFF7F1D1D.toInt())
                    setPadding(16, 12, 16, 12)
                    val params = android.widget.LinearLayout.LayoutParams(
                        android.widget.LinearLayout.LayoutParams.MATCH_PARENT,
                        android.widget.LinearLayout.LayoutParams.WRAP_CONTENT
                    )
                    params.topMargin = 8
                    layoutParams = params
                }

                val urgentTitle = TextView(context).apply {
                    text = "⚠️ URGENT CONSIDERATIONS"
                    textSize = getContentFontSize()
                    setTextColor(0xFFFCA5A5.toInt())
                    setTypeface(null, android.graphics.Typeface.BOLD)
                }
                urgentCard.addView(urgentTitle)

                response.urgentConsiderations.forEach { consideration ->
                    val urgentText = TextView(context).apply {
                        text = "• $consideration"
                        textSize = getContentFontSize() - 1f
                        setTextColor(0xFFFECACA.toInt())
                        setPadding(0, 4, 0, 0)
                    }
                    urgentCard.addView(urgentText)
                }

                contentLayout.addView(urgentCard)
            }

            scrollView.addView(contentLayout)
            innerLayout.addView(scrollView)

            // Hint text
            val hintText = TextView(context).apply {
                text = "💡 Say \"read ddx\", \"close\", or \"order [test]\""
                textSize = getContentFontSize() - 3f
                setTextColor(0xFF64748B.toInt())
                setPadding(0, 12, 0, 0)
                gravity = android.view.Gravity.CENTER
            }
            innerLayout.addView(hintText)

            addView(innerLayout)
        }

        rootView.addView(dataOverlay)
        speakFeedback("Differential diagnosis ready. Top diagnosis: ${response.differentials.firstOrNull()?.diagnosis ?: "none"}")
    }

    /**
     * Speak differential diagnosis results via TTS
     */
    private fun speakDdxResults() {
        val response = lastDdxResponse
        if (response == null || response.differentials.isEmpty()) {
            speakFeedback("No differential diagnosis available. Say differential diagnosis to generate one.")
            return
        }

        val sb = StringBuilder()
        sb.append("Differential diagnosis. ")

        // Read top 3 diagnoses
        response.differentials.take(3).forEach { ddx ->
            sb.append("Number ${ddx.rank}: ${ddx.diagnosis}, ")
            sb.append("${ddx.likelihood} likelihood. ")
            if (ddx.supportingFindings.isNotEmpty()) {
                sb.append("Supporting: ${ddx.supportingFindings.take(2).joinToString(", ")}. ")
            }
        }

        // Urgent considerations
        if (response.urgentConsiderations.isNotEmpty()) {
            sb.append("Urgent: ${response.urgentConsiderations.first()}. ")
        }

        speakFeedback(sb.toString())
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // MEDICAL IMAGE ANALYSIS FUNCTIONS (Feature #70)
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Start image capture for medical image analysis
     * @param context Optional analysis context: "wound", "rash", "xray", or null for general
     */
    private fun startImageCapture(context: String? = null) {
        pendingImageContext = context
        val intent = Intent(this, ImageCaptureActivity::class.java).apply {
            if (context != null) {
                putExtra(ImageCaptureActivity.INPUT_ANALYSIS_CONTEXT, context)
            }
        }

        val contextLabel = when (context) {
            "wound" -> "wound"
            "rash" -> "skin or rash"
            "xray" -> "X-ray"
            else -> "medical image"
        }
        speakFeedback("Opening camera for $contextLabel capture")

        imageCaptureUrl.launch(intent)
    }

    /**
     * Send captured image to backend for Claude Vision analysis
     */
    private fun analyzeMedicalImage(imageBase64: String, mediaType: String, context: String?) {
        lifecycleScope.launch {
            try {
                val response = withContext(Dispatchers.IO) {
                    val requestBody = buildString {
                        append("{")
                        append("\"image_base64\":\"$imageBase64\",")
                        append("\"media_type\":\"$mediaType\"")
                        if (context != null) {
                            append(",\"analysis_context\":\"$context\"")
                        }
                        // Include patient context if available
                        currentPatientData?.optString("patient_id", "")?.takeIf { it.isNotEmpty() }?.let { id ->
                            append(",\"patient_id\":\"$id\"")
                        }
                        if (context != null && currentPatientData != null) {
                            // Add chief complaint from context
                            append(",\"chief_complaint\":\"${context.capitalize()} assessment\"")
                        }
                        append("}")
                    }

                    val url = java.net.URL("$EHR_PROXY_URL/api/v1/image/analyze")
                    val conn = url.openConnection() as java.net.HttpURLConnection
                    conn.requestMethod = "POST"
                    conn.setRequestProperty("Content-Type", "application/json")
                    conn.doOutput = true
                    conn.connectTimeout = 90000  // 90 second timeout for vision API
                    conn.readTimeout = 90000

                    conn.outputStream.use { os ->
                        os.write(requestBody.toByteArray())
                    }

                    if (conn.responseCode == 200) {
                        conn.inputStream.bufferedReader().readText()
                    } else {
                        val error = conn.errorStream?.bufferedReader()?.readText() ?: "Unknown error"
                        throw Exception("API error ${conn.responseCode}: $error")
                    }
                }

                // Parse response
                val json = org.json.JSONObject(response)
                val findingsList = mutableListOf<ImageFinding>()
                val findingsArray = json.optJSONArray("findings") ?: org.json.JSONArray()
                for (i in 0 until findingsArray.length()) {
                    val f = findingsArray.getJSONObject(i)
                    val chars = mutableListOf<String>()
                    val charsArray = f.optJSONArray("characteristics") ?: org.json.JSONArray()
                    for (j in 0 until charsArray.length()) {
                        chars.add(charsArray.getString(j))
                    }
                    findingsList.add(ImageFinding(
                        finding = f.getString("finding"),
                        confidence = f.optString("confidence", "moderate"),
                        location = f.optString("location", null),
                        characteristics = chars
                    ))
                }

                val icd10List = mutableListOf<Map<String, String>>()
                val icd10Array = json.optJSONArray("icd10_codes") ?: org.json.JSONArray()
                for (i in 0 until icd10Array.length()) {
                    val code = icd10Array.getJSONObject(i)
                    icd10List.add(mapOf(
                        "code" to code.optString("code", ""),
                        "description" to code.optString("description", "")
                    ))
                }

                val recsList = mutableListOf<String>()
                val recsArray = json.optJSONArray("recommendations") ?: org.json.JSONArray()
                for (i in 0 until recsArray.length()) {
                    recsList.add(recsArray.getString(i))
                }

                val redFlagsList = mutableListOf<String>()
                val redFlagsArray = json.optJSONArray("red_flags") ?: org.json.JSONArray()
                for (i in 0 until redFlagsArray.length()) {
                    redFlagsList.add(redFlagsArray.getString(i))
                }

                val diffList = mutableListOf<String>()
                val diffArray = json.optJSONArray("differential_considerations") ?: org.json.JSONArray()
                for (i in 0 until diffArray.length()) {
                    diffList.add(diffArray.getString(i))
                }

                val analysisResponse = ImageAnalysisResponse(
                    assessment = json.getString("assessment"),
                    findings = findingsList,
                    icd10Codes = icd10List,
                    recommendations = recsList,
                    redFlags = redFlagsList,
                    differentialConsiderations = diffList,
                    disclaimer = json.optString("disclaimer", "For clinical decision support only"),
                    timestamp = json.optString("timestamp", "")
                )

                lastImageAnalysis = analysisResponse
                showImageAnalysisResults(analysisResponse)

            } catch (e: Exception) {
                Log.e(TAG, "Image analysis failed: ${e.message}")
                runOnUiThread {
                    transcriptText.text = "Image analysis failed: ${e.message}"
                }
                speakFeedback("Image analysis failed. Please try again.")
            }
        }
    }

    /**
     * Display image analysis results in AR overlay
     */
    private fun showImageAnalysisResults(response: ImageAnalysisResponse) {
        val sb = StringBuilder()

        // Header
        sb.appendLine("📷 IMAGE ANALYSIS")
        sb.appendLine("═".repeat(40))

        // Red flags first (safety)
        if (response.redFlags.isNotEmpty()) {
            sb.appendLine()
            sb.appendLine("🚨 RED FLAGS:")
            response.redFlags.forEach { flag ->
                sb.appendLine("  ⚠️ $flag")
            }
        }

        // Assessment
        sb.appendLine()
        sb.appendLine("📋 ASSESSMENT:")
        sb.appendLine("  ${response.assessment}")

        // Findings
        if (response.findings.isNotEmpty()) {
            sb.appendLine()
            sb.appendLine("🔍 FINDINGS:")
            response.findings.forEach { finding ->
                val confidence = when (finding.confidence.lowercase()) {
                    "high" -> "●●●"
                    "moderate" -> "●●○"
                    else -> "●○○"
                }
                sb.append("  • ${finding.finding} [$confidence]")
                finding.location?.let { sb.append(" @ $it") }
                sb.appendLine()
            }
        }

        // ICD-10 codes
        if (response.icd10Codes.isNotEmpty()) {
            sb.appendLine()
            sb.appendLine("🏥 ICD-10 CODES:")
            response.icd10Codes.forEach { code ->
                sb.appendLine("  • ${code["code"]}: ${code["description"]}")
            }
        }

        // Recommendations
        if (response.recommendations.isNotEmpty()) {
            sb.appendLine()
            sb.appendLine("💡 RECOMMENDATIONS:")
            response.recommendations.forEach { rec ->
                sb.appendLine("  • $rec")
            }
        }

        // Differential considerations
        if (response.differentialConsiderations.isNotEmpty()) {
            sb.appendLine()
            sb.appendLine("🤔 CONSIDER:")
            response.differentialConsiderations.take(3).forEach { diff ->
                sb.appendLine("  • $diff")
            }
        }

        // Disclaimer
        sb.appendLine()
        sb.appendLine("─".repeat(40))
        sb.appendLine("⚕️ ${response.disclaimer}")

        runOnUiThread {
            transcriptText.text = sb.toString()
        }

        // Speak red flags immediately if present
        if (response.redFlags.isNotEmpty()) {
            speakFeedback("Alert. Red flags detected. ${response.redFlags.first()}")
        } else {
            speakFeedback("Image analysis complete. ${response.findings.size} findings identified.")
        }
    }

    /**
     * TTS readback of last image analysis
     */
    private fun speakImageAnalysisResults() {
        val response = lastImageAnalysis
        if (response == null) {
            speakFeedback("No image analysis available. Say take photo to capture an image.")
            return
        }

        val sb = StringBuilder()
        sb.append("Image analysis. ")

        // Red flags first
        if (response.redFlags.isNotEmpty()) {
            sb.append("Alert: ${response.redFlags.size} red flags. ")
            sb.append("${response.redFlags.first()}. ")
        }

        // Assessment
        sb.append("Assessment: ${response.assessment}. ")

        // Top findings
        if (response.findings.isNotEmpty()) {
            sb.append("${response.findings.size} findings. ")
            response.findings.take(2).forEach { finding ->
                sb.append("${finding.finding}, ${finding.confidence} confidence. ")
            }
        }

        // Top recommendation
        if (response.recommendations.isNotEmpty()) {
            sb.append("Recommendation: ${response.recommendations.first()}. ")
        }

        speakFeedback(sb.toString())
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // BILLING/CLAIM FUNCTIONS (Feature #71)
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Create billing claim from last saved note
     */
    private fun createClaimFromNote(noteId: String) {
        val patientId = currentPatientData?.optString("patient_id", "")
        if (patientId.isNullOrEmpty()) {
            speakFeedback("No patient loaded. Load patient first.")
            return
        }

        val serviceDate = java.text.SimpleDateFormat("yyyy-MM-dd", java.util.Locale.US)
            .format(java.util.Date())

        lifecycleScope.launch {
            try {
                speakFeedback("Creating billing claim")

                val response = withContext(Dispatchers.IO) {
                    val requestBody = org.json.JSONObject().apply {
                        put("patient_id", patientId as String)
                        put("note_id", noteId)
                        put("service_date", serviceDate)
                    }.toString()

                    val url = java.net.URL("$EHR_PROXY_URL/api/v1/billing/claims")
                    val conn = url.openConnection() as java.net.HttpURLConnection
                    conn.requestMethod = "POST"
                    conn.setRequestProperty("Content-Type", "application/json")
                    conn.doOutput = true
                    conn.connectTimeout = 30000
                    conn.readTimeout = 30000

                    conn.outputStream.use { os ->
                        os.write(requestBody.toByteArray())
                    }

                    if (conn.responseCode == 200) {
                        conn.inputStream.bufferedReader().readText()
                    } else {
                        val error = conn.errorStream?.bufferedReader()?.readText() ?: "Unknown error"
                        throw Exception("API error ${conn.responseCode}: $error")
                    }
                }

                val json = org.json.JSONObject(response)
                if (json.optBoolean("success")) {
                    currentClaim = parseClaimJson(json.optJSONObject("claim"))
                    speakFeedback("Claim created. Review codes before submission.")
                    showBillingReviewUI()
                } else {
                    speakFeedback("Failed to create claim")
                }

            } catch (e: Exception) {
                Log.e(TAG, "Create claim failed: ${e.message}")
                speakFeedback("Failed to create claim. ${e.message}")
            }
        }
    }

    /**
     * Parse claim JSON to data class
     */
    private fun parseClaimJson(json: org.json.JSONObject?): BillingClaim? {
        json ?: return null

        val diagnoses = mutableListOf<BillingDiagnosisCode>()
        val diagArray = json.optJSONArray("diagnoses") ?: org.json.JSONArray()
        for (i in 0 until diagArray.length()) {
            val dx = diagArray.getJSONObject(i)
            diagnoses.add(BillingDiagnosisCode(
                code = dx.optString("code"),
                description = dx.optString("description"),
                sequence = dx.optInt("sequence", i + 1),
                isPrincipal = dx.optBoolean("is_principal")
            ))
        }

        val serviceLines = mutableListOf<BillingServiceLine>()
        val linesArray = json.optJSONArray("service_lines") ?: org.json.JSONArray()
        for (i in 0 until linesArray.length()) {
            val line = linesArray.getJSONObject(i)
            val proc = line.optJSONObject("procedure") ?: org.json.JSONObject()
            val modifiers = mutableListOf<String>()
            val modArray = proc.optJSONArray("modifiers") ?: org.json.JSONArray()
            for (j in 0 until modArray.length()) {
                modifiers.add(modArray.getString(j))
            }

            serviceLines.add(BillingServiceLine(
                lineNumber = line.optInt("line_number", i + 1),
                serviceDate = line.optString("service_date"),
                procedure = BillingProcedureCode(
                    code = proc.optString("code"),
                    description = proc.optString("description"),
                    modifiers = modifiers,
                    units = proc.optInt("units", 1)
                )
            ))
        }

        return BillingClaim(
            claimId = json.optString("claim_id"),
            status = try { ClaimStatus.valueOf(json.optString("status", "DRAFT").uppercase()) }
                     catch (e: Exception) { ClaimStatus.DRAFT },
            patientId = json.optString("patient_id"),
            patientName = json.optString("patient_name"),
            noteId = json.optString("note_id"),
            serviceDate = json.optString("service_date"),
            diagnoses = diagnoses,
            serviceLines = serviceLines,
            totalCharge = json.optDouble("total_charge", 0.0).toFloat(),
            createdAt = json.optString("created_at"),
            submittedAt = json.optString("submitted_at"),
            fhirClaimId = json.optString("fhir_claim_id")
        )
    }

    /**
     * Show billing review UI overlay
     */
    private fun showBillingReviewUI() {
        val claim = currentClaim ?: return

        val sb = StringBuilder()
        sb.appendLine("💰 BILLING CLAIM REVIEW")
        sb.appendLine("═".repeat(40))
        sb.appendLine("Patient: ${currentPatientData?.optString("name", "Unknown")}")
        sb.appendLine("Service Date: ${claim.serviceDate}")
        sb.appendLine("Status: ${claim.status}")
        sb.appendLine()

        // Diagnoses section
        sb.appendLine("📋 DIAGNOSES (ICD-10):")
        if (claim.diagnoses.isEmpty()) {
            sb.appendLine("  No diagnoses added")
        } else {
            claim.diagnoses.forEachIndexed { index, dx ->
                val principal = if (dx.isPrincipal) " ★" else ""
                sb.appendLine("  ${index + 1}. ${dx.code} - ${dx.description}$principal")
            }
        }

        sb.appendLine()

        // Procedures section
        sb.appendLine("🏥 PROCEDURES (CPT):")
        if (claim.serviceLines.isEmpty()) {
            sb.appendLine("  No procedures added")
        } else {
            claim.serviceLines.forEach { line ->
                val modStr = if (line.procedure.modifiers.isNotEmpty())
                    " [${line.procedure.modifiers.joinToString(", ")}]" else ""
                sb.appendLine("  ${line.lineNumber}. ${line.procedure.code}$modStr - ${line.procedure.description}")
            }
        }

        sb.appendLine()
        sb.appendLine("─".repeat(40))
        sb.appendLine("Voice Commands:")
        sb.appendLine("• \"submit claim\" - Submit for processing")
        sb.appendLine("• \"add diagnosis [code]\" - Add ICD-10")
        sb.appendLine("• \"add procedure [code]\" - Add CPT")
        sb.appendLine("• \"close billing\" - Cancel")

        runOnUiThread {
            transcriptText.text = sb.toString()
        }
    }

    /**
     * Submit billing claim
     */
    private fun submitBillingClaim() {
        val claim = currentClaim
        if (claim == null) {
            speakFeedback("No claim to submit. Create a claim first.")
            return
        }

        if (claim.diagnoses.isEmpty()) {
            speakFeedback("Claim requires at least one diagnosis")
            return
        }

        if (claim.serviceLines.isEmpty()) {
            speakFeedback("Claim requires at least one procedure")
            return
        }

        isAwaitingClaimConfirmation = true
        speakFeedback("Ready to submit claim with ${claim.diagnoses.size} diagnoses and ${claim.serviceLines.size} procedures. Say confirm to proceed or cancel to abort.")
    }

    /**
     * Confirm and execute claim submission
     */
    private fun confirmClaimSubmission() {
        val claim = currentClaim ?: return
        isAwaitingClaimConfirmation = false

        lifecycleScope.launch {
            try {
                speakFeedback("Submitting claim")

                val response = withContext(Dispatchers.IO) {
                    val requestBody = org.json.JSONObject().apply {
                        put("confirm", true)
                    }.toString()

                    val url = java.net.URL("$EHR_PROXY_URL/api/v1/billing/claims/${claim.claimId}/submit")
                    val conn = url.openConnection() as java.net.HttpURLConnection
                    conn.requestMethod = "POST"
                    conn.setRequestProperty("Content-Type", "application/json")
                    conn.doOutput = true

                    conn.outputStream.use { os ->
                        os.write(requestBody.toByteArray())
                    }

                    if (conn.responseCode == 200) {
                        conn.inputStream.bufferedReader().readText()
                    } else {
                        val error = conn.errorStream?.bufferedReader()?.readText() ?: "Unknown error"
                        throw Exception("API error ${conn.responseCode}: $error")
                    }
                }

                val json = org.json.JSONObject(response)
                if (json.optBoolean("success")) {
                    val fhirId = json.optString("fhir_claim_id", "")
                    speakFeedback("Claim submitted successfully")
                    runOnUiThread {
                        transcriptText.text = "✅ CLAIM SUBMITTED\n\nClaim ID: ${claim.claimId}\nFHIR ID: $fhirId\nStatus: SUBMITTED"
                    }
                    currentClaim = null
                } else {
                    speakFeedback("Submission failed: ${json.optString("error")}")
                }

            } catch (e: Exception) {
                Log.e(TAG, "Submit claim failed: ${e.message}")
                speakFeedback("Submission failed. ${e.message}")
            }
        }
    }

    /**
     * Show claim history for current patient
     */
    private fun showClaimHistory() {
        val patientId = currentPatientData?.optString("patient_id", "")
        if (patientId.isNullOrEmpty()) {
            speakFeedback("No patient loaded")
            return
        }

        lifecycleScope.launch {
            try {
                val response = withContext(Dispatchers.IO) {
                    java.net.URL("$EHR_PROXY_URL/api/v1/patient/$patientId/claims").readText()
                }

                val json = org.json.JSONObject(response)
                val claims = json.optJSONArray("claims") ?: org.json.JSONArray()

                val sb = StringBuilder()
                sb.appendLine("📋 BILLING CLAIMS HISTORY")
                sb.appendLine("═".repeat(40))

                if (claims.length() == 0) {
                    sb.appendLine("No claims found for this patient")
                } else {
                    for (i in 0 until claims.length()) {
                        val c = claims.getJSONObject(i)
                        val status = c.optString("status", "unknown").uppercase()
                        val date = c.optString("service_date", "")
                        val dxCount = c.optJSONArray("diagnoses")?.length() ?: 0
                        val cptCount = c.optJSONArray("service_lines")?.length() ?: 0

                        val statusIcon = when (status) {
                            "DRAFT" -> "📝"
                            "SUBMITTED" -> "📤"
                            "ACCEPTED" -> "✅"
                            "REJECTED" -> "❌"
                            else -> "❓"
                        }

                        sb.appendLine("${i + 1}. $statusIcon $date - $status")
                        sb.appendLine("   $dxCount diagnoses, $cptCount procedures")
                    }
                }

                runOnUiThread {
                    transcriptText.text = sb.toString()
                }
                speakFeedback("Found ${claims.length()} claims")

            } catch (e: Exception) {
                Log.e(TAG, "Fetch claims failed: ${e.message}")
                speakFeedback("Failed to load claim history")
            }
        }
    }

    /**
     * Close billing review UI
     */
    private fun closeBillingUI() {
        currentClaim = null
        isAwaitingClaimConfirmation = false
        speakFeedback("Billing closed")
        runOnUiThread {
            transcriptText.text = "Billing session closed"
        }
    }

    /**
     * Add diagnosis code to current claim
     */
    private fun addDiagnosisToClaim(code: String) {
        val claim = currentClaim ?: return

        lifecycleScope.launch {
            try {
                // First search for the code to get description
                val searchResponse = withContext(Dispatchers.IO) {
                    java.net.URL("$EHR_PROXY_URL/api/v1/billing/codes/icd10/search?q=$code&limit=1").readText()
                }

                val searchJson = org.json.JSONObject(searchResponse)
                val results = searchJson.optJSONArray("results") ?: org.json.JSONArray()

                val description = if (results.length() > 0) {
                    results.getJSONObject(0).optString("description", "Unknown")
                } else {
                    "Unknown diagnosis"
                }

                // Update claim via API
                val newDiagnoses = claim.diagnoses.toMutableList()
                val isPrincipal = newDiagnoses.isEmpty()
                newDiagnoses.add(BillingDiagnosisCode(
                    code = code,
                    description = description,
                    sequence = newDiagnoses.size + 1,
                    isPrincipal = isPrincipal
                ))

                val updateResponse = withContext(Dispatchers.IO) {
                    val diagArray = org.json.JSONArray()
                    newDiagnoses.forEach { dx ->
                        diagArray.put(org.json.JSONObject().apply {
                            put("code", dx.code)
                            put("description", dx.description)
                            put("sequence", dx.sequence)
                            put("is_principal", dx.isPrincipal)
                        })
                    }

                    val requestBody = org.json.JSONObject().apply {
                        put("diagnoses", diagArray)
                    }.toString()

                    val url = java.net.URL("$EHR_PROXY_URL/api/v1/billing/claims/${claim.claimId}")
                    val conn = url.openConnection() as java.net.HttpURLConnection
                    conn.requestMethod = "PUT"
                    conn.setRequestProperty("Content-Type", "application/json")
                    conn.doOutput = true

                    conn.outputStream.use { os ->
                        os.write(requestBody.toByteArray())
                    }

                    conn.inputStream.bufferedReader().readText()
                }

                val json = org.json.JSONObject(updateResponse)
                if (json.optBoolean("success")) {
                    currentClaim = parseClaimJson(json.optJSONObject("claim"))
                    speakFeedback("Added $code")
                    showBillingReviewUI()
                }

            } catch (e: Exception) {
                Log.e(TAG, "Add diagnosis failed: ${e.message}")
                speakFeedback("Failed to add diagnosis")
            }
        }
    }

    /**
     * Remove diagnosis from current claim by index
     */
    private fun removeDiagnosisFromClaim(index: Int) {
        val claim = currentClaim ?: return

        if (index < 0 || index >= claim.diagnoses.size) {
            speakFeedback("Invalid diagnosis number")
            return
        }

        lifecycleScope.launch {
            try {
                val newDiagnoses = claim.diagnoses.toMutableList()
                val removed = newDiagnoses.removeAt(index)

                // Re-sequence and re-assign principal if needed
                newDiagnoses.forEachIndexed { i, dx ->
                    newDiagnoses[i] = dx.copy(
                        sequence = i + 1,
                        isPrincipal = i == 0
                    )
                }

                val updateResponse = withContext(Dispatchers.IO) {
                    val diagArray = org.json.JSONArray()
                    newDiagnoses.forEach { dx ->
                        diagArray.put(org.json.JSONObject().apply {
                            put("code", dx.code)
                            put("description", dx.description)
                            put("sequence", dx.sequence)
                            put("is_principal", dx.isPrincipal)
                        })
                    }

                    val requestBody = org.json.JSONObject().apply {
                        put("diagnoses", diagArray)
                    }.toString()

                    val url = java.net.URL("$EHR_PROXY_URL/api/v1/billing/claims/${claim.claimId}")
                    val conn = url.openConnection() as java.net.HttpURLConnection
                    conn.requestMethod = "PUT"
                    conn.setRequestProperty("Content-Type", "application/json")
                    conn.doOutput = true

                    conn.outputStream.use { os ->
                        os.write(requestBody.toByteArray())
                    }

                    conn.inputStream.bufferedReader().readText()
                }

                val json = org.json.JSONObject(updateResponse)
                if (json.optBoolean("success")) {
                    currentClaim = parseClaimJson(json.optJSONObject("claim"))
                    speakFeedback("Removed ${removed.code}")
                    showBillingReviewUI()
                }

            } catch (e: Exception) {
                Log.e(TAG, "Remove diagnosis failed: ${e.message}")
                speakFeedback("Failed to remove diagnosis")
            }
        }
    }

    /**
     * Add procedure code to current claim
     */
    private fun addProcedureToClaim(code: String) {
        val claim = currentClaim ?: return

        lifecycleScope.launch {
            try {
                // Search for CPT code description
                val searchResponse = withContext(Dispatchers.IO) {
                    java.net.URL("$EHR_PROXY_URL/api/v1/billing/codes/cpt/search?q=$code&limit=1").readText()
                }

                val searchJson = org.json.JSONObject(searchResponse)
                val results = searchJson.optJSONArray("results") ?: org.json.JSONArray()

                val description = if (results.length() > 0) {
                    results.getJSONObject(0).optString("description", "Unknown")
                } else {
                    "Unknown procedure"
                }

                // Update claim via API
                val newLines = claim.serviceLines.toMutableList()
                newLines.add(BillingServiceLine(
                    lineNumber = newLines.size + 1,
                    serviceDate = claim.serviceDate,
                    procedure = BillingProcedureCode(
                        code = code,
                        description = description,
                        modifiers = emptyList(),
                        units = 1
                    )
                ))

                val updateResponse = withContext(Dispatchers.IO) {
                    val linesArray = org.json.JSONArray()
                    newLines.forEach { line ->
                        linesArray.put(org.json.JSONObject().apply {
                            put("line_number", line.lineNumber)
                            put("service_date", line.serviceDate)
                            put("procedure", org.json.JSONObject().apply {
                                put("code", line.procedure.code)
                                put("description", line.procedure.description)
                                put("modifiers", org.json.JSONArray(line.procedure.modifiers))
                                put("units", line.procedure.units)
                            })
                            put("diagnosis_pointers", org.json.JSONArray(listOf(1)))
                        })
                    }

                    val requestBody = org.json.JSONObject().apply {
                        put("service_lines", linesArray)
                    }.toString()

                    val url = java.net.URL("$EHR_PROXY_URL/api/v1/billing/claims/${claim.claimId}")
                    val conn = url.openConnection() as java.net.HttpURLConnection
                    conn.requestMethod = "PUT"
                    conn.setRequestProperty("Content-Type", "application/json")
                    conn.doOutput = true

                    conn.outputStream.use { os ->
                        os.write(requestBody.toByteArray())
                    }

                    conn.inputStream.bufferedReader().readText()
                }

                val json = org.json.JSONObject(updateResponse)
                if (json.optBoolean("success")) {
                    currentClaim = parseClaimJson(json.optJSONObject("claim"))
                    speakFeedback("Added $code")
                    showBillingReviewUI()
                }

            } catch (e: Exception) {
                Log.e(TAG, "Add procedure failed: ${e.message}")
                speakFeedback("Failed to add procedure")
            }
        }
    }

    /**
     * Add modifier to procedure in current claim
     */
    private fun addModifierToProcedure(modifier: String, procIndex: Int) {
        val claim = currentClaim ?: return

        if (procIndex < 0 || procIndex >= claim.serviceLines.size) {
            speakFeedback("Invalid procedure number")
            return
        }

        lifecycleScope.launch {
            try {
                val newLines = claim.serviceLines.toMutableList()
                val line = newLines[procIndex]
                val newModifiers = line.procedure.modifiers.toMutableList()

                if (newModifiers.contains(modifier)) {
                    speakFeedback("Modifier $modifier already added")
                    return@launch
                }

                newModifiers.add(modifier)
                newLines[procIndex] = line.copy(
                    procedure = line.procedure.copy(modifiers = newModifiers)
                )

                val updateResponse = withContext(Dispatchers.IO) {
                    val linesArray = org.json.JSONArray()
                    newLines.forEach { l ->
                        linesArray.put(org.json.JSONObject().apply {
                            put("line_number", l.lineNumber)
                            put("service_date", l.serviceDate)
                            put("procedure", org.json.JSONObject().apply {
                                put("code", l.procedure.code)
                                put("description", l.procedure.description)
                                put("modifiers", org.json.JSONArray(l.procedure.modifiers))
                                put("units", l.procedure.units)
                            })
                            put("diagnosis_pointers", org.json.JSONArray(listOf(1)))
                        })
                    }

                    val requestBody = org.json.JSONObject().apply {
                        put("service_lines", linesArray)
                    }.toString()

                    val url = java.net.URL("$EHR_PROXY_URL/api/v1/billing/claims/${claim.claimId}")
                    val conn = url.openConnection() as java.net.HttpURLConnection
                    conn.requestMethod = "PUT"
                    conn.setRequestProperty("Content-Type", "application/json")
                    conn.doOutput = true

                    conn.outputStream.use { os ->
                        os.write(requestBody.toByteArray())
                    }

                    conn.inputStream.bufferedReader().readText()
                }

                val json = org.json.JSONObject(updateResponse)
                if (json.optBoolean("success")) {
                    currentClaim = parseClaimJson(json.optJSONObject("claim"))
                    speakFeedback("Added modifier $modifier to procedure ${procIndex + 1}")
                    showBillingReviewUI()
                }

            } catch (e: Exception) {
                Log.e(TAG, "Add modifier failed: ${e.message}")
                speakFeedback("Failed to add modifier")
            }
        }
    }

    /**
     * Search ICD-10 codes and display results
     */
    private fun searchICD10Codes(query: String) {
        lifecycleScope.launch {
            try {
                speakFeedback("Searching I C D codes")

                val response = withContext(Dispatchers.IO) {
                    java.net.URL("$EHR_PROXY_URL/api/v1/billing/codes/icd10/search?q=${java.net.URLEncoder.encode(query, "UTF-8")}&limit=10").readText()
                }

                val json = org.json.JSONObject(response)
                val results = json.optJSONArray("results") ?: org.json.JSONArray()

                val sb = StringBuilder()
                sb.appendLine("🔍 ICD-10 SEARCH: \"$query\"")
                sb.appendLine("═".repeat(40))

                if (results.length() == 0) {
                    sb.appendLine("No codes found")
                    speakFeedback("No I C D codes found for $query")
                } else {
                    for (i in 0 until results.length()) {
                        val code = results.getJSONObject(i)
                        sb.appendLine("${i + 1}. ${code.optString("code")} - ${code.optString("description")}")
                    }
                    sb.appendLine()
                    sb.appendLine("Say \"add diagnosis [code]\" to add")
                    speakFeedback("Found ${results.length()} codes")
                }

                runOnUiThread {
                    transcriptText.text = sb.toString()
                }

            } catch (e: Exception) {
                Log.e(TAG, "ICD-10 search failed: ${e.message}")
                speakFeedback("Search failed")
            }
        }
    }

    /**
     * Search CPT codes and display results
     */
    private fun searchCPTCodes(query: String) {
        lifecycleScope.launch {
            try {
                speakFeedback("Searching C P T codes")

                val response = withContext(Dispatchers.IO) {
                    java.net.URL("$EHR_PROXY_URL/api/v1/billing/codes/cpt/search?q=${java.net.URLEncoder.encode(query, "UTF-8")}&limit=10").readText()
                }

                val json = org.json.JSONObject(response)
                val results = json.optJSONArray("results") ?: org.json.JSONArray()

                val sb = StringBuilder()
                sb.appendLine("🔍 CPT SEARCH: \"$query\"")
                sb.appendLine("═".repeat(40))

                if (results.length() == 0) {
                    sb.appendLine("No codes found")
                    speakFeedback("No C P T codes found for $query")
                } else {
                    for (i in 0 until results.length()) {
                        val code = results.getJSONObject(i)
                        sb.appendLine("${i + 1}. ${code.optString("code")} - ${code.optString("description")}")
                    }
                    sb.appendLine()
                    sb.appendLine("Say \"add procedure [code]\" to add")
                    speakFeedback("Found ${results.length()} codes")
                }

                runOnUiThread {
                    transcriptText.text = sb.toString()
                }

            } catch (e: Exception) {
                Log.e(TAG, "CPT search failed: ${e.message}")
                speakFeedback("Search failed")
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // DNFB (DISCHARGED NOT FINAL BILLED) FUNCTIONS (Feature #72)
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Fetch and display DNFB worklist
     */
    private fun showDNFBWorklist(filter: String? = null) {
        lifecycleScope.launch {
            try {
                speakFeedback("Loading D N F B worklist")

                val url = if (filter != null) {
                    "$EHR_PROXY_URL/api/v1/dnfb?reason=$filter"
                } else {
                    "$EHR_PROXY_URL/api/v1/dnfb"
                }

                val response = withContext(Dispatchers.IO) {
                    java.net.URL(url).readText()
                }

                val json = org.json.JSONObject(response)
                val accounts = json.optJSONArray("accounts") ?: org.json.JSONArray()
                val totalCharges = json.optDouble("total_estimated_charges", 0.0)
                val priorAuthCount = json.optInt("prior_auth_issues", 0)

                dnfbAccounts.clear()

                val sb = StringBuilder()
                sb.appendLine("💰 DNFB WORKLIST")
                sb.appendLine("═".repeat(40))
                sb.appendLine("Total: ${accounts.length()} | \$${String.format("%,.0f", totalCharges)}")
                if (priorAuthCount > 0) {
                    sb.appendLine("⚠️ Prior Auth Issues: $priorAuthCount")
                }
                sb.appendLine()

                if (accounts.length() == 0) {
                    sb.appendLine("No unbilled accounts found")
                    speakFeedback("No D N F B accounts")
                } else {
                    for (i in 0 until accounts.length()) {
                        val acc = accounts.getJSONObject(i)
                        val name = acc.optString("patient_name", "Unknown")
                        val days = acc.optInt("days_since_discharge", 0)
                        val reason = acc.optString("reason", "").replace("_", " ")
                        val charges = acc.optDouble("estimated_charges", 0.0)
                        val bucket = acc.optString("aging_bucket", "0-3")

                        val agingIcon = when {
                            days > 14 -> "🔴"
                            days > 7 -> "🟡"
                            else -> "🟢"
                        }

                        sb.appendLine("${i + 1}. $agingIcon $name")
                        sb.appendLine("   $days days | $bucket | \$${String.format("%,.0f", charges)}")
                        sb.appendLine("   Reason: $reason")

                        // Check for prior auth issues
                        if (reason.contains("prior_auth")) {
                            sb.appendLine("   ⚠️ Prior Auth Issue")
                        }
                        sb.appendLine()
                    }

                    sb.appendLine("─".repeat(40))
                    sb.appendLine("Voice Commands:")
                    sb.appendLine("• \"prior auth issues\" - Filter by prior auth")
                    sb.appendLine("• \"over 7 days\" - Show aging > 7 days")
                    sb.appendLine("• \"resolve 1\" - Mark as billed")
                    speakFeedback("Found ${accounts.length()} unbilled accounts totaling ${String.format("%,.0f", totalCharges)} dollars")
                }

                runOnUiThread {
                    transcriptText.text = sb.toString()
                }

            } catch (e: Exception) {
                Log.e(TAG, "DNFB fetch failed: ${e.message}")
                speakFeedback("Failed to load D N F B worklist")
            }
        }
    }

    /**
     * Show DNFB summary metrics
     */
    private fun showDNFBSummary() {
        lifecycleScope.launch {
            try {
                val response = withContext(Dispatchers.IO) {
                    java.net.URL("$EHR_PROXY_URL/api/v1/dnfb/summary").readText()
                }

                val json = org.json.JSONObject(response)
                val total = json.optInt("total_accounts", 0)
                val totalCharges = json.optDouble("total_estimated_charges", 0.0)
                val avgDays = json.optDouble("average_days_unbilled", 0.0)
                val over7 = json.optInt("aging_over_7_days", 0)
                val over14 = json.optInt("aging_over_14_days", 0)

                val priorAuth = json.optJSONObject("prior_auth_issues")
                val priorAuthCount = priorAuth?.optInt("count", 0) ?: 0
                val priorAuthCharges = priorAuth?.optDouble("charges", 0.0) ?: 0.0

                val sb = StringBuilder()
                sb.appendLine("📊 DNFB SUMMARY")
                sb.appendLine("═".repeat(40))
                sb.appendLine()
                sb.appendLine("Total Unbilled: $total accounts")
                sb.appendLine("Total Charges: \$${String.format("%,.0f", totalCharges)}")
                sb.appendLine("Avg Days: ${String.format("%.1f", avgDays)}")
                sb.appendLine()
                sb.appendLine("AGING:")
                sb.appendLine("  Over 7 days: $over7")
                sb.appendLine("  Over 14 days: $over14")
                sb.appendLine()
                sb.appendLine("PRIOR AUTH ISSUES:")
                sb.appendLine("  Count: $priorAuthCount")
                sb.appendLine("  At Risk: \$${String.format("%,.0f", priorAuthCharges)}")

                // Add breakdown by reason
                val byReason = json.optJSONObject("by_reason")
                if (byReason != null && byReason.length() > 0) {
                    sb.appendLine()
                    sb.appendLine("BY REASON:")
                    byReason.keys().forEach { key ->
                        val data = byReason.optJSONObject(key)
                        val count = data?.optInt("count", 0) ?: 0
                        val charges = data?.optDouble("charges", 0.0) ?: 0.0
                        sb.appendLine("  ${key.replace("_", " ")}: $count (\$${String.format("%,.0f", charges)})")
                    }
                }

                runOnUiThread {
                    transcriptText.text = sb.toString()
                }

                speakFeedback("$total unbilled accounts totaling ${String.format("%,.0f", totalCharges)} dollars. $priorAuthCount have prior auth issues.")

            } catch (e: Exception) {
                Log.e(TAG, "DNFB summary failed: ${e.message}")
                speakFeedback("Failed to load D N F B summary")
            }
        }
    }

    /**
     * Show only prior auth related DNFB issues
     */
    private fun showPriorAuthIssues() {
        lifecycleScope.launch {
            try {
                speakFeedback("Loading prior authorization issues")

                val response = withContext(Dispatchers.IO) {
                    java.net.URL("$EHR_PROXY_URL/api/v1/dnfb?prior_auth_issue=true").readText()
                }

                val json = org.json.JSONObject(response)
                val accounts = json.optJSONArray("accounts") ?: org.json.JSONArray()
                val totalCharges = json.optDouble("total_estimated_charges", 0.0)

                val sb = StringBuilder()
                sb.appendLine("⚠️ PRIOR AUTH ISSUES")
                sb.appendLine("═".repeat(40))
                sb.appendLine("At Risk: \$${String.format("%,.0f", totalCharges)}")
                sb.appendLine()

                if (accounts.length() == 0) {
                    sb.appendLine("No prior auth issues found")
                    speakFeedback("No prior authorization issues")
                } else {
                    for (i in 0 until accounts.length()) {
                        val acc = accounts.getJSONObject(i)
                        val name = acc.optString("patient_name", "Unknown")
                        val reason = acc.optString("reason", "")
                        val charges = acc.optDouble("estimated_charges", 0.0)
                        val days = acc.optInt("days_since_discharge", 0)

                        val statusIcon = when {
                            reason.contains("denied") -> "❌"
                            reason.contains("expired") -> "⏰"
                            reason.contains("missing") -> "❓"
                            else -> "⚠️"
                        }

                        sb.appendLine("${i + 1}. $statusIcon $name")
                        sb.appendLine("   \$${String.format("%,.0f", charges)} | $days days")
                        sb.appendLine("   Status: ${reason.replace("prior_auth_", "").replace("_", " ").uppercase()}")

                        // Show prior auth details if available
                        val priorAuth = acc.optJSONObject("prior_auth")
                        if (priorAuth != null) {
                            val payer = priorAuth.optString("payer_name", "")
                            val expDate = priorAuth.optString("expiration_date", "")
                            val denial = priorAuth.optString("denial_reason", "")

                            if (payer.isNotEmpty()) sb.appendLine("   Payer: $payer")
                            if (expDate.isNotEmpty()) sb.appendLine("   Expires: $expDate")
                            if (denial.isNotEmpty()) sb.appendLine("   Denial: $denial")
                        }
                        sb.appendLine()
                    }

                    speakFeedback("Found ${accounts.length()} prior auth issues totaling ${String.format("%,.0f", totalCharges)} dollars at risk")
                }

                runOnUiThread {
                    transcriptText.text = sb.toString()
                }

            } catch (e: Exception) {
                Log.e(TAG, "Prior auth issues fetch failed: ${e.message}")
                speakFeedback("Failed to load prior auth issues")
            }
        }
    }

    /**
     * Show DNFB accounts over X days
     */
    private fun showDNFBOverDays(days: Int) {
        lifecycleScope.launch {
            try {
                val bucket = when {
                    days >= 15 -> "15-30"
                    days >= 8 -> "8-14"
                    days >= 4 -> "4-7"
                    else -> "0-3"
                }

                speakFeedback("Loading accounts over $days days")

                val response = withContext(Dispatchers.IO) {
                    java.net.URL("$EHR_PROXY_URL/api/v1/dnfb").readText()
                }

                val json = org.json.JSONObject(response)
                val allAccounts = json.optJSONArray("accounts") ?: org.json.JSONArray()

                val filteredAccounts = mutableListOf<org.json.JSONObject>()
                for (i in 0 until allAccounts.length()) {
                    val acc = allAccounts.getJSONObject(i)
                    if (acc.optInt("days_since_discharge", 0) > days) {
                        filteredAccounts.add(acc)
                    }
                }

                val totalCharges = filteredAccounts.sumOf { it.optDouble("estimated_charges", 0.0) }

                val sb = StringBuilder()
                sb.appendLine("📅 DNFB OVER $days DAYS")
                sb.appendLine("═".repeat(40))
                sb.appendLine("Count: ${filteredAccounts.size} | \$${String.format("%,.0f", totalCharges)}")
                sb.appendLine()

                if (filteredAccounts.isEmpty()) {
                    sb.appendLine("No accounts over $days days")
                    speakFeedback("No accounts over $days days")
                } else {
                    filteredAccounts.sortedByDescending { it.optInt("days_since_discharge", 0) }
                        .forEachIndexed { index, acc ->
                            val name = acc.optString("patient_name", "Unknown")
                            val accDays = acc.optInt("days_since_discharge", 0)
                            val charges = acc.optDouble("estimated_charges", 0.0)
                            val reason = acc.optString("reason", "").replace("_", " ")

                            sb.appendLine("${index + 1}. 🔴 $name")
                            sb.appendLine("   $accDays days | \$${String.format("%,.0f", charges)}")
                            sb.appendLine("   $reason")
                            sb.appendLine()
                        }

                    speakFeedback("${filteredAccounts.size} accounts over $days days totaling ${String.format("%,.0f", totalCharges)} dollars")
                }

                runOnUiThread {
                    transcriptText.text = sb.toString()
                }

            } catch (e: Exception) {
                Log.e(TAG, "DNFB over days fetch failed: ${e.message}")
                speakFeedback("Failed to load aging accounts")
            }
        }
    }

    /**
     * Resolve DNFB account (mark as billed)
     */
    private fun resolveDNFBAccount(index: Int) {
        if (dnfbAccounts.isEmpty()) {
            speakFeedback("No D N F B accounts loaded. Say show D N F B first.")
            return
        }

        if (index < 0 || index >= dnfbAccounts.size) {
            speakFeedback("Invalid account number")
            return
        }

        val account = dnfbAccounts[index]

        lifecycleScope.launch {
            try {
                val response = withContext(Dispatchers.IO) {
                    val url = java.net.URL("$EHR_PROXY_URL/api/v1/dnfb/${account.dnfbId}/resolve")
                    val conn = url.openConnection() as java.net.HttpURLConnection
                    conn.requestMethod = "POST"
                    conn.setRequestProperty("Content-Type", "application/json")
                    conn.doOutput = true

                    conn.outputStream.use { os ->
                        os.write("{}".toByteArray())
                    }

                    conn.inputStream.bufferedReader().readText()
                }

                val json = org.json.JSONObject(response)
                if (json.optBoolean("success")) {
                    speakFeedback("Account ${index + 1} resolved")
                    // Refresh the list
                    showDNFBWorklist(currentDNFBFilter)
                }

            } catch (e: Exception) {
                Log.e(TAG, "Resolve DNFB failed: ${e.message}")
                speakFeedback("Failed to resolve account")
            }
        }
    }

    /**
     * Show patient's DNFB status
     */
    private fun showPatientDNFB() {
        val patientId = currentPatientData?.optString("patient_id", "")
        if (patientId.isNullOrEmpty()) {
            speakFeedback("No patient loaded")
            return
        }

        lifecycleScope.launch {
            try {
                val response = withContext(Dispatchers.IO) {
                    java.net.URL("$EHR_PROXY_URL/api/v1/patient/$patientId/dnfb").readText()
                }

                val json = org.json.JSONObject(response)
                val accounts = json.optJSONArray("accounts") ?: org.json.JSONArray()
                val activeCount = json.optInt("active_count", 0)
                val unbilledCharges = json.optDouble("total_unbilled_charges", 0.0)

                val sb = StringBuilder()
                sb.appendLine("📋 PATIENT DNFB STATUS")
                sb.appendLine("═".repeat(40))

                if (activeCount == 0) {
                    sb.appendLine("No unbilled accounts for this patient")
                    speakFeedback("No unbilled accounts for current patient")
                } else {
                    sb.appendLine("Unbilled: $activeCount accounts")
                    sb.appendLine("Total: \$${String.format("%,.0f", unbilledCharges)}")
                    sb.appendLine()

                    for (i in 0 until accounts.length()) {
                        val acc = accounts.getJSONObject(i)
                        if (acc.optBoolean("is_resolved")) continue

                        val discharge = acc.optString("discharge_date", "")
                        val days = acc.optInt("days_since_discharge", 0)
                        val reason = acc.optString("reason", "").replace("_", " ")
                        val charges = acc.optDouble("estimated_charges", 0.0)

                        sb.appendLine("${i + 1}. Discharged: $discharge ($days days)")
                        sb.appendLine("   Reason: $reason")
                        sb.appendLine("   Charges: \$${String.format("%,.0f", charges)}")
                        sb.appendLine()
                    }

                    speakFeedback("Patient has $activeCount unbilled accounts totaling ${String.format("%,.0f", unbilledCharges)} dollars")
                }

                runOnUiThread {
                    transcriptText.text = sb.toString()
                }

            } catch (e: Exception) {
                Log.e(TAG, "Patient DNFB fetch failed: ${e.message}")
                speakFeedback("Failed to load patient D N F B status")
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // PATIENT WORKLIST FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════════

    data class WorklistPatient(
        val patientId: String,
        val name: String,
        val dateOfBirth: String,
        val gender: String,
        val mrn: String?,
        val room: String?,
        val appointmentTime: String?,
        val appointmentType: String?,
        val chiefComplaint: String?,
        val status: String,
        val hasCriticalAlerts: Boolean,
        val priority: Int
    )

    private var worklistPatients = mutableListOf<WorklistPatient>()
    private var worklistPosition: Int = 0  // Current position in worklist for touchpad navigation
    private var pendingOrderUpdate: Order? = null  // Order being updated

    /**
     * Fetch and display today's patient worklist
     */
    private fun showWorklist() {
        lifecycleScope.launch {
            try {
                speakFeedback("Loading worklist")
                val response = withContext(Dispatchers.IO) {
                    java.net.URL("$EHR_PROXY_URL/api/v1/worklist").readText()
                }
                val json = org.json.JSONObject(response)
                val patients = json.getJSONArray("patients")
                worklistPatients.clear()

                val sb = StringBuilder()
                sb.appendLine("📋 TODAY'S WORKLIST")
                sb.appendLine("═".repeat(40))
                sb.appendLine("${json.optString("provider", "")} | ${json.optString("location", "")}")
                sb.appendLine()

                for (i in 0 until patients.length()) {
                    val p = patients.getJSONObject(i)
                    val patient = WorklistPatient(
                        patientId = p.getString("patient_id"),
                        name = p.getString("name"),
                        dateOfBirth = p.getString("date_of_birth"),
                        gender = p.getString("gender"),
                        mrn = p.optString("mrn"),
                        room = p.optString("room", null),
                        appointmentTime = p.optString("appointment_time"),
                        appointmentType = p.optString("appointment_type"),
                        chiefComplaint = p.optString("chief_complaint", null),
                        status = p.getString("status"),
                        hasCriticalAlerts = p.optBoolean("has_critical_alerts"),
                        priority = p.optInt("priority", 0)
                    )
                    worklistPatients.add(patient)

                    // Status icon
                    val statusIcon = when (patient.status) {
                        "scheduled" -> "⏳"
                        "checked_in" -> "✅"
                        "in_room" -> "🚪"
                        "in_progress" -> "👨‍⚕️"
                        "completed" -> "✔️"
                        else -> "•"
                    }

                    // Priority indicator
                    val priorityIcon = when (patient.priority) {
                        2 -> "🔴"  // STAT
                        1 -> "🟡"  // Urgent
                        else -> ""
                    }

                    // Alert indicator
                    val alertIcon = if (patient.hasCriticalAlerts) "⚠️" else ""

                    sb.appendLine("${i + 1}. $statusIcon $priorityIcon${patient.name} $alertIcon")
                    sb.appendLine("   ${patient.appointmentTime ?: ""} | ${patient.appointmentType ?: ""}")
                    if (!patient.room.isNullOrEmpty()) {
                        sb.appendLine("   Room: ${patient.room}")
                    }
                    if (!patient.chiefComplaint.isNullOrEmpty()) {
                        sb.appendLine("   CC: ${patient.chiefComplaint}")
                    }
                    sb.appendLine()
                }

                sb.appendLine("─".repeat(40))
                sb.appendLine("📊 ${json.optInt("total_scheduled")} scheduled | ${json.optInt("checked_in")} waiting | ${json.optInt("completed")} done")
                sb.appendLine()
                sb.appendLine("Voice Commands:")
                sb.appendLine("• \"Load 1\" - Load patient #1")
                sb.appendLine("• \"Check in 2\" - Check in patient #2")
                sb.appendLine("• \"Who's next\" - Next patient to see")

                showDataOverlay("📋 Worklist", sb.toString())
                speakFeedback("${patients.length()} patients on worklist")

            } catch (e: Exception) {
                Log.e(TAG, "Failed to fetch worklist: ${e.message}")
                speakFeedback("Could not load worklist")
            }
        }
    }

    /**
     * Check in a patient from the worklist
     */
    private fun checkInPatient(index: Int, room: String? = null) {
        if (index < 1 || index > worklistPatients.size) {
            speakFeedback("Invalid patient number")
            return
        }

        val patient = worklistPatients[index - 1]

        lifecycleScope.launch {
            try {
                val requestBody = org.json.JSONObject().apply {
                    put("patient_id", patient.patientId)
                    if (!room.isNullOrEmpty()) put("room", room)
                }

                val response = withContext(Dispatchers.IO) {
                    val url = java.net.URL("$EHR_PROXY_URL/api/v1/worklist/check-in")
                    val conn = url.openConnection() as java.net.HttpURLConnection
                    conn.requestMethod = "POST"
                    conn.setRequestProperty("Content-Type", "application/json")
                    conn.doOutput = true
                    conn.outputStream.write(requestBody.toString().toByteArray())
                    conn.inputStream.bufferedReader().readText()
                }

                val json = org.json.JSONObject(response)
                if (json.optBoolean("success", false)) {
                    worklistPatients[index - 1] = patient.copy(status = "checked_in", room = room)
                    speakFeedback("${patient.name} checked in" + if (!room.isNullOrEmpty()) " to $room" else "")
                    showWorklist()  // Refresh
                }
            } catch (e: Exception) {
                Log.e(TAG, "Failed to check in patient: ${e.message}")
                speakFeedback("Could not check in patient")
            }
        }
    }

    /**
     * Get the next patient to see
     */
    private fun getNextPatient() {
        lifecycleScope.launch {
            try {
                val response = withContext(Dispatchers.IO) {
                    java.net.URL("$EHR_PROXY_URL/api/v1/worklist/next").readText()
                }
                val json = org.json.JSONObject(response)
                val nextPatient = json.optJSONObject("next_patient")

                if (nextPatient == null) {
                    speakFeedback("No patients waiting")
                    return@launch
                }

                val name = nextPatient.getString("name")
                val room = nextPatient.optString("room", "")
                val cc = nextPatient.optString("chief_complaint", "")
                val waitingCount = json.optInt("waiting_count", 0)

                val message = buildString {
                    append("Next patient: $name")
                    if (room.isNotEmpty()) append(", room $room")
                    if (cc.isNotEmpty()) append(". Chief complaint: $cc")
                    if (waitingCount > 1) append(". ${waitingCount - 1} more waiting")
                }

                speakFeedback(message)

                // Show brief overlay
                val sb = StringBuilder()
                sb.appendLine("👨‍⚕️ NEXT PATIENT")
                sb.appendLine("═".repeat(30))
                sb.appendLine(name)
                if (room.isNotEmpty()) sb.appendLine("Room: $room")
                if (cc.isNotEmpty()) sb.appendLine("CC: $cc")
                sb.appendLine()
                sb.appendLine("Say \"load patient\" to open chart")

                showDataOverlay("Next Patient", sb.toString())

            } catch (e: Exception) {
                Log.e(TAG, "Failed to get next patient: ${e.message}")
                speakFeedback("Could not get next patient")
            }
        }
    }

    /**
     * Update patient status in worklist
     */
    private fun updateWorklistStatus(index: Int, newStatus: String) {
        if (index < 1 || index > worklistPatients.size) {
            speakFeedback("Invalid patient number")
            return
        }

        val patient = worklistPatients[index - 1]

        lifecycleScope.launch {
            try {
                val requestBody = org.json.JSONObject().apply {
                    put("patient_id", patient.patientId)
                    put("status", newStatus)
                }

                val response = withContext(Dispatchers.IO) {
                    val url = java.net.URL("$EHR_PROXY_URL/api/v1/worklist/status")
                    val conn = url.openConnection() as java.net.HttpURLConnection
                    conn.requestMethod = "POST"
                    conn.setRequestProperty("Content-Type", "application/json")
                    conn.doOutput = true
                    conn.outputStream.write(requestBody.toString().toByteArray())
                    conn.inputStream.bufferedReader().readText()
                }

                val json = org.json.JSONObject(response)
                if (json.optBoolean("success", false)) {
                    worklistPatients[index - 1] = patient.copy(status = newStatus)
                    speakFeedback("${patient.name} marked as ${newStatus.replace("_", " ")}")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Failed to update status: ${e.message}")
                speakFeedback("Could not update status")
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // ORDER UPDATE/MODIFY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Show orders with numbers for update/delete
     */
    private fun showOrdersForUpdate() {
        if (orderQueue.isEmpty()) {
            showOrderQueue()
            return
        }

        val sb = StringBuilder()
        sb.appendLine("📋 CURRENT ORDERS")
        sb.appendLine("═".repeat(40))
        sb.appendLine()

        orderQueue.forEachIndexed { index, order ->
            val typeIcon = when (order.type) {
                OrderType.LAB -> "🔬"
                OrderType.IMAGING -> "📷"
                OrderType.MEDICATION -> "💊"
            }

            sb.appendLine("${index + 1}. $typeIcon ${order.displayName}")
            if (order.details.isNotEmpty()) {
                sb.appendLine("   ${order.details}")
            }
            sb.appendLine()
        }

        sb.appendLine("─".repeat(40))
        sb.appendLine("Voice Commands:")
        sb.appendLine("• \"Update 1 to 650mg every 4 hours\"")
        sb.appendLine("• \"Delete 2\" - Remove order #2")
        sb.appendLine("• \"Cancel order\" - Remove last order")
        sb.appendLine("• \"Confirm\" - Push orders to EHR")

        showDataOverlay("📋 Orders (${orderQueue.size})", sb.toString())
        speakFeedback("${orderQueue.size} orders. Say update followed by number to modify")
    }

    /**
     * Update an existing order
     * Example: "update 1 to 500mg every 6 hours"
     * Example: "update tylenol to 650mg PRN"
     */
    private fun updateOrder(input: String) {
        val lower = input.lowercase()

        // Parse order identifier (number or name)
        var orderIndex = -1
        var orderToUpdate: Order? = null

        // Try to find by number: "update 1", "update order 1"
        val numberPattern = Regex("update\\s*(?:order\\s*)?(\\d+)")
        val numberMatch = numberPattern.find(lower)
        if (numberMatch != null) {
            orderIndex = numberMatch.groupValues[1].toIntOrNull()?.minus(1) ?: -1
            if (orderIndex >= 0 && orderIndex < orderQueue.size) {
                orderToUpdate = orderQueue[orderIndex]
            }
        }

        // Try to find by medication name if not found by number
        if (orderToUpdate == null) {
            val medNames = listOf("tylenol", "acetaminophen", "ibuprofen", "advil", "motrin",
                "aspirin", "amoxicillin", "metformin", "lisinopril", "atorvastatin",
                "omeprazole", "amlodipine", "metoprolol", "losartan", "gabapentin",
                "hydrocodone", "prednisone", "albuterol", "levothyroxine", "pantoprazole")

            for (medName in medNames) {
                if (lower.contains(medName)) {
                    orderIndex = orderQueue.indexOfFirst {
                        it.name.lowercase().contains(medName) ||
                        it.displayName.lowercase().contains(medName)
                    }
                    if (orderIndex >= 0) {
                        orderToUpdate = orderQueue[orderIndex]
                        break
                    }
                }
            }
        }

        if (orderToUpdate == null) {
            speakFeedback("Order not found. Say show orders to see list")
            return
        }

        // Parse the update details after "to"
        val toIndex = lower.indexOf(" to ")
        if (toIndex == -1) {
            speakFeedback("Say update followed by order number, then to, then new details")
            return
        }

        val newDetails = input.substring(toIndex + 4).trim()

        // Parse dose, frequency, duration from new details
        val dosePattern = Regex("(\\d+)\\s*(?:mg|mcg|ml|g|units?)")
        val freqPattern = Regex("(?:every|q)\\s*(\\d+)\\s*(?:hours?|hrs?|h)|(?:once|twice|three times|four times)\\s*(?:daily|a day)|(?:bid|tid|qid|daily|prn|qhs|qam|qpm)", RegexOption.IGNORE_CASE)
        val durationPattern = Regex("(?:for|x)\\s*(\\d+)\\s*(?:days?|weeks?|months?)")

        val doseMatch = dosePattern.find(newDetails)
        val freqMatch = freqPattern.find(newDetails)
        val durationMatch = durationPattern.find(newDetails)
        val isPRN = lower.contains("prn") || lower.contains("as needed")

        val newDose = doseMatch?.value ?: orderToUpdate.dose
        val newFreq = freqMatch?.value ?: orderToUpdate.frequency
        val newDuration = durationMatch?.value ?: orderToUpdate.duration

        // Build new details string
        val updatedDetails = buildString {
            if (!newDose.isNullOrEmpty()) append("$newDose ")
            if (!newFreq.isNullOrEmpty()) append("$newFreq ")
            if (!newDuration.isNullOrEmpty()) append("$newDuration")
            if (isPRN && !contains("prn", ignoreCase = true)) append(" PRN")
        }.trim()

        // Create updated order
        val updatedOrder = orderToUpdate.copy(
            dose = newDose,
            frequency = newFreq,
            duration = newDuration,
            prn = isPRN,
            details = updatedDetails,
            timestamp = System.currentTimeMillis()
        )

        // Store for confirmation
        pendingOrderUpdate = updatedOrder

        // Show confirmation
        val sb = StringBuilder()
        sb.appendLine("📝 CONFIRM ORDER UPDATE")
        sb.appendLine("═".repeat(35))
        sb.appendLine()
        sb.appendLine("BEFORE:")
        sb.appendLine("  ${orderToUpdate.displayName}")
        sb.appendLine("  ${orderToUpdate.details}")
        sb.appendLine()
        sb.appendLine("AFTER:")
        sb.appendLine("  ${updatedOrder.displayName}")
        sb.appendLine("  ${updatedOrder.details}")
        sb.appendLine()
        sb.appendLine("─".repeat(35))
        sb.appendLine("Say \"confirm\" or \"yes\" to update")
        sb.appendLine("Say \"cancel\" or \"no\" to keep original")

        showDataOverlay("Confirm Update", sb.toString())
        speakFeedback("Updating ${orderToUpdate.displayName} to ${updatedDetails}. Say confirm or cancel")
    }

    /**
     * Confirm pending order update
     */
    private fun confirmOrderUpdate() {
        val update = pendingOrderUpdate ?: return

        // Find and replace the order
        val index = orderQueue.indexOfFirst { it.id == update.id }
        if (index >= 0) {
            orderQueue[index] = update
            saveOrdersToPrefs()
            speakFeedback("Order updated: ${update.displayName} ${update.details}")
            pendingOrderUpdate = null
            hideDataOverlay()
        } else {
            speakFeedback("Could not find order to update")
            pendingOrderUpdate = null
        }
    }

    /**
     * Cancel pending order update
     */
    private fun cancelOrderUpdate() {
        pendingOrderUpdate = null
        speakFeedback("Update cancelled")
        hideDataOverlay()
    }

    /**
     * Delete order by number or medication name
     * Example: "delete 2", "remove order 3", "delete tylenol", "remove amoxicillin"
     */
    private fun deleteOrderByNumber(input: String) {
        val lower = input.lowercase()
        var orderIndex = -1

        // Try to find by number first: "delete 1", "remove order 2"
        val numberPattern = Regex("(?:delete|remove)\\s*(?:order\\s*)?(\\d+)")
        val numberMatch = numberPattern.find(lower)

        if (numberMatch != null) {
            val orderNum = numberMatch.groupValues[1].toIntOrNull() ?: -1
            orderIndex = orderNum - 1
        } else {
            // Try to find by medication name
            val medNames = listOf("tylenol", "acetaminophen", "ibuprofen", "advil", "motrin",
                "aspirin", "amoxicillin", "metformin", "lisinopril", "atorvastatin",
                "omeprazole", "amlodipine", "metoprolol", "losartan", "gabapentin",
                "hydrocodone", "prednisone", "albuterol", "levothyroxine", "pantoprazole",
                "cbc", "cmp", "bmp", "lipid", "tsh", "a1c", "troponin", "pt", "inr",
                "chest x-ray", "ct head", "ct chest", "ct abdomen", "mri", "echo", "ekg")

            for (medName in medNames) {
                if (lower.contains(medName)) {
                    orderIndex = orderQueue.indexOfFirst {
                        it.name.lowercase().contains(medName) ||
                        it.displayName.lowercase().contains(medName)
                    }
                    if (orderIndex >= 0) break
                }
            }
        }

        if (orderIndex < 0 || orderIndex >= orderQueue.size) {
            speakFeedback("Order not found. Say show orders to see list")
            return
        }

        val removed = orderQueue.removeAt(orderIndex)
        saveOrdersToPrefs()
        speakFeedback("Deleted ${removed.displayName}")

        // Refresh display
        if (orderQueue.isNotEmpty()) {
            showOrdersForUpdate()
        } else {
            hideDataOverlay()
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // ORDER SETS - Batch ordering functions
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Find an order set by alias
     */
    private fun findOrderSet(text: String): OrderSetInfo? {
        val lower = text.lowercase().trim()
        // Direct key match
        orderSets[lower]?.let { return it }
        // Alias match
        for ((_, setInfo) in orderSets) {
            if (setInfo.aliases.any { lower.contains(it) }) {
                return setInfo
            }
        }
        return null
    }

    /**
     * Check if text matches an order set pattern
     */
    private fun isOrderSet(text: String): Boolean {
        return findOrderSet(text) != null
    }

    /**
     * Process an order set - queue all orders with safety checks
     */
    private fun processOrderSet(setInfo: OrderSetInfo) {
        if (currentPatientData == null) {
            speakFeedback("Please load a patient first")
            return
        }

        val orderedItems = mutableListOf<String>()
        val warnings = mutableListOf<String>()
        var hasHighSeverityWarning = false

        // Process each item in the order set
        for (item in setInfo.items) {
            when (item.type) {
                OrderType.LAB -> {
                    val lab = labOrders[item.orderKey]
                    if (lab != null) {
                        // Check for duplicate
                        val duplicate = checkDuplicateOrder(OrderType.LAB, lab.name)
                        if (duplicate != null) {
                            warnings.add("${lab.name}: duplicate order")
                        } else {
                            val order = Order(
                                type = OrderType.LAB,
                                name = lab.name,
                                displayName = lab.displayName,
                                details = "CPT: ${lab.cptCode}"
                            )
                            orderQueue.add(order)
                            pendingPlanItems.add("• ${lab.displayName}")
                            orderedItems.add(lab.name)
                        }
                    }
                }
                OrderType.IMAGING -> {
                    val imaging = imagingOrders[item.orderKey]
                    if (imaging != null) {
                        // Check for duplicate
                        val duplicate = checkDuplicateOrder(OrderType.IMAGING, imaging.name)
                        if (duplicate != null) {
                            warnings.add("${imaging.name}: duplicate order")
                        } else {
                            // Check metformin/contrast warning
                            if (imaging.supportsContrast || item.details.contains("contrast")) {
                                val metforminWarning = checkMetforminContrastWarning()
                                if (metforminWarning != null) {
                                    warnings.add("${imaging.name}: ${metforminWarning.message}")
                                    hasHighSeverityWarning = true
                                }
                            }
                            val order = Order(
                                type = OrderType.IMAGING,
                                name = imaging.name,
                                displayName = imaging.displayName,
                                details = "CPT: ${imaging.cptCode}",
                                contrast = imaging.supportsContrast,
                                bodyPart = imaging.bodyPart
                            )
                            orderQueue.add(order)
                            pendingPlanItems.add("• ${imaging.displayName}")
                            orderedItems.add(imaging.name)
                        }
                    }
                }
                OrderType.MEDICATION -> {
                    // Order sets typically don't include medications, but support it
                    Log.d(TAG, "Medication in order set not processed: ${item.orderKey}")
                }
            }
        }

        saveOrdersToPrefs()

        // Build feedback message
        val message = StringBuilder()
        message.append("Ordered ${setInfo.name}: ")
        message.append(orderedItems.joinToString(", "))

        if (warnings.isNotEmpty()) {
            message.append(". Warnings: ")
            message.append(warnings.joinToString("; "))
        }

        // Show visual summary
        showOrderSetSummary(setInfo, orderedItems, warnings)

        // Speak feedback
        speakFeedback(message.toString())

        Log.d(TAG, "Order set ${setInfo.id}: ${orderedItems.size} orders placed, ${warnings.size} warnings")
    }

    /**
     * Show visual summary of order set
     */
    private fun showOrderSetSummary(setInfo: OrderSetInfo, ordered: List<String>, warnings: List<String>) {
        val content = StringBuilder()
        content.append("═══════════════════════════\n")
        content.append("📦 ${setInfo.displayName}\n")
        content.append("═══════════════════════════\n\n")

        content.append("✓ Orders Placed:\n")
        ordered.forEach { content.append("  • $it\n") }

        if (warnings.isNotEmpty()) {
            content.append("\n⚠️ Warnings:\n")
            warnings.forEach { content.append("  • $it\n") }
        }

        content.append("\n───────────────────────────\n")
        content.append("Total: ${ordered.size} orders\n")
        content.append("Say \"show orders\" to view queue")

        showDataOverlay("Order Set", content.toString())
    }

    /**
     * Show list of available order sets
     */
    private fun showOrderSetList() {
        val content = StringBuilder()
        content.append("═══════════════════════════\n")
        content.append("📦 ORDER SETS\n")
        content.append("═══════════════════════════\n\n")

        orderSets.values.forEach { setInfo ->
            val labCount = setInfo.items.count { it.type == OrderType.LAB }
            val imagingCount = setInfo.items.count { it.type == OrderType.IMAGING }
            content.append("• ${setInfo.name}\n")
            content.append("  \"Order ${setInfo.aliases.first()}\"\n")
            content.append("  $labCount labs")
            if (imagingCount > 0) content.append(", $imagingCount imaging")
            content.append("\n\n")
        }

        content.append("───────────────────────────\n")
        content.append("Say \"what's in [name]\" to preview")

        showDataOverlay("Order Sets", content.toString())
        speakFeedback("Showing ${orderSets.size} order sets. Say order followed by the set name to place orders.")
    }

    /**
     * Preview contents of an order set without ordering
     */
    private fun previewOrderSet(text: String) {
        val setInfo = findOrderSet(text)
        if (setInfo == null) {
            speakFeedback("Order set not found. Say list order sets to see available options.")
            return
        }

        val content = StringBuilder()
        content.append("═══════════════════════════\n")
        content.append("📦 ${setInfo.displayName}\n")
        content.append("═══════════════════════════\n\n")
        content.append("${setInfo.description}\n\n")

        val labs = setInfo.items.filter { it.type == OrderType.LAB }
        val imaging = setInfo.items.filter { it.type == OrderType.IMAGING }

        if (labs.isNotEmpty()) {
            content.append("🧪 Labs:\n")
            labs.forEach { item ->
                val lab = labOrders[item.orderKey]
                content.append("  • ${lab?.displayName ?: item.orderKey}\n")
            }
            content.append("\n")
        }

        if (imaging.isNotEmpty()) {
            content.append("📷 Imaging:\n")
            imaging.forEach { item ->
                val img = imagingOrders[item.orderKey]
                content.append("  • ${img?.displayName ?: item.orderKey}\n")
            }
            content.append("\n")
        }

        content.append("───────────────────────────\n")
        content.append("Say \"order ${setInfo.aliases.first()}\" to place")

        showDataOverlay("Order Set Preview", content.toString())
        speakFeedback("${setInfo.name} contains ${labs.size} labs and ${imaging.size} imaging studies. Say order ${setInfo.aliases.first()} to place these orders.")
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // VOICE VITALS ENTRY - Capture and manage vitals by voice
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Check if text contains a vital sign entry
     */
    private fun isVitalEntry(text: String): Boolean {
        val lower = text.lowercase()
        return vitalAliases.values.any { aliases ->
            aliases.any { alias -> lower.contains(alias) }
        } && Regex("\\d+").containsMatchIn(lower)
    }

    /**
     * Parse and process a vital sign from voice input
     */
    private fun processVitalEntry(text: String) {
        val lower = text.lowercase()

        // Try to match each vital type
        when {
            // Blood Pressure: "BP 120 over 80", "blood pressure 120/80"
            vitalAliases[VitalType.BLOOD_PRESSURE]?.any { lower.contains(it) } == true -> {
                parseBloodPressure(lower)
            }
            // Heart Rate: "heart rate 72", "pulse 80 bpm"
            vitalAliases[VitalType.HEART_RATE]?.any { lower.contains(it) } == true -> {
                parseHeartRate(lower)
            }
            // Temperature: "temp 98.6", "temperature 101.2 fahrenheit"
            vitalAliases[VitalType.TEMPERATURE]?.any { lower.contains(it) } == true -> {
                parseTemperature(lower)
            }
            // Oxygen Saturation: "o2 sat 98", "oxygen 95 percent"
            vitalAliases[VitalType.OXYGEN_SATURATION]?.any { lower.contains(it) } == true -> {
                parseOxygenSaturation(lower)
            }
            // Respiratory Rate: "resp rate 16", "respirations 18"
            vitalAliases[VitalType.RESPIRATORY_RATE]?.any { lower.contains(it) } == true -> {
                parseRespiratoryRate(lower)
            }
            // Weight: "weight 180 pounds", "weight 82 kilos"
            vitalAliases[VitalType.WEIGHT]?.any { lower.contains(it) } == true -> {
                parseWeight(lower)
            }
            // Height: "height 5 foot 10", "height 178 centimeters"
            vitalAliases[VitalType.HEIGHT]?.any { lower.contains(it) } == true -> {
                parseHeight(lower)
            }
            // Pain Level: "pain 5 out of 10", "pain level 7"
            vitalAliases[VitalType.PAIN_LEVEL]?.any { lower.contains(it) } == true -> {
                parsePainLevel(lower)
            }
            else -> {
                speakFeedback("Could not recognize vital sign. Try: BP 120 over 80, pulse 72, or temp 98.6")
            }
        }
    }

    /**
     * Parse blood pressure: "120 over 80", "120/80", "120 80"
     */
    private fun parseBloodPressure(text: String) {
        // Match patterns like "120 over 80", "120/80", "120 80"
        val patterns = listOf(
            Regex("(\\d{2,3})\\s*(?:over|/)\\s*(\\d{2,3})"),
            Regex("(\\d{2,3})\\s+(\\d{2,3})")
        )

        for (pattern in patterns) {
            val match = pattern.find(text)
            if (match != null) {
                val systolic = match.groupValues[1].toIntOrNull() ?: continue
                val diastolic = match.groupValues[2].toIntOrNull() ?: continue

                // Validate ranges
                val sysRange = vitalRanges["systolic"]!!
                val diaRange = vitalRanges["diastolic"]!!

                if (systolic < sysRange.min || systolic > sysRange.max) {
                    speakFeedback("Systolic $systolic seems out of range. Please verify.")
                    return
                }
                if (diastolic < diaRange.min || diastolic > diaRange.max) {
                    speakFeedback("Diastolic $diastolic seems out of range. Please verify.")
                    return
                }

                val vital = CapturedVital(
                    type = VitalType.BLOOD_PRESSURE,
                    value = "$systolic/$diastolic",
                    unit = "mmHg",
                    displayName = "Blood Pressure"
                )
                addCapturedVital(vital)

                // Check for critical values
                val isCritical = (sysRange.criticalHigh != null && systolic >= sysRange.criticalHigh) ||
                                 (diaRange.criticalHigh != null && diastolic >= diaRange.criticalHigh) ||
                                 (sysRange.criticalLow != null && systolic <= sysRange.criticalLow)

                if (isCritical) {
                    speakFeedback("Warning! Blood pressure $systolic over $diastolic recorded. Critical value detected.")
                } else {
                    speakFeedback("Blood pressure $systolic over $diastolic recorded.")
                }
                return
            }
        }
        speakFeedback("Could not parse blood pressure. Say: BP 120 over 80")
    }

    /**
     * Parse heart rate: "72", "72 bpm", "pulse 80"
     */
    private fun parseHeartRate(text: String) {
        val match = Regex("(\\d{2,3})").find(text)
        if (match != null) {
            val hr = match.groupValues[1].toIntOrNull() ?: return
            val range = vitalRanges["heart_rate"]!!

            if (hr < range.min || hr > range.max) {
                speakFeedback("Heart rate $hr seems out of range. Please verify.")
                return
            }

            val vital = CapturedVital(
                type = VitalType.HEART_RATE,
                value = hr.toString(),
                unit = "bpm",
                displayName = "Heart Rate"
            )
            addCapturedVital(vital)

            val isCritical = (range.criticalHigh != null && hr >= range.criticalHigh) ||
                             (range.criticalLow != null && hr <= range.criticalLow)

            if (isCritical) {
                speakFeedback("Warning! Heart rate $hr recorded. Critical value detected.")
            } else {
                speakFeedback("Heart rate $hr recorded.")
            }
        } else {
            speakFeedback("Could not parse heart rate. Say: pulse 72")
        }
    }

    /**
     * Parse temperature: "98.6", "101.2 fahrenheit", "37.5 celsius"
     */
    private fun parseTemperature(text: String) {
        val match = Regex("(\\d{2,3}(?:\\.\\d)?)").find(text)
        if (match != null) {
            val temp = match.groupValues[1].toDoubleOrNull() ?: return

            // Determine if Celsius or Fahrenheit
            val isCelsius = text.contains("celsius") || text.contains("centigrade") || temp < 50
            val range = if (isCelsius) vitalRanges["temperature_c"]!! else vitalRanges["temperature_f"]!!
            val unit = if (isCelsius) "°C" else "°F"

            if (temp < range.min || temp > range.max) {
                speakFeedback("Temperature $temp $unit seems out of range. Please verify.")
                return
            }

            val vital = CapturedVital(
                type = VitalType.TEMPERATURE,
                value = temp.toString(),
                unit = unit,
                displayName = "Temperature"
            )
            addCapturedVital(vital)

            val isCritical = (range.criticalHigh != null && temp >= range.criticalHigh) ||
                             (range.criticalLow != null && temp <= range.criticalLow)

            if (isCritical) {
                speakFeedback("Warning! Temperature $temp $unit recorded. Critical value detected.")
            } else {
                speakFeedback("Temperature $temp $unit recorded.")
            }
        } else {
            speakFeedback("Could not parse temperature. Say: temp 98.6")
        }
    }

    /**
     * Parse oxygen saturation: "98", "95 percent"
     */
    private fun parseOxygenSaturation(text: String) {
        val match = Regex("(\\d{2,3})").find(text)
        if (match != null) {
            val o2 = match.groupValues[1].toIntOrNull() ?: return
            val range = vitalRanges["oxygen_saturation"]!!

            if (o2 < range.min || o2 > range.max) {
                speakFeedback("Oxygen saturation $o2% seems out of range. Please verify.")
                return
            }

            val vital = CapturedVital(
                type = VitalType.OXYGEN_SATURATION,
                value = o2.toString(),
                unit = "%",
                displayName = "Oxygen Saturation"
            )
            addCapturedVital(vital)

            val isCritical = range.criticalLow != null && o2 <= range.criticalLow

            if (isCritical) {
                speakFeedback("Warning! Oxygen saturation $o2% recorded. Critical low value detected.")
            } else {
                speakFeedback("Oxygen saturation $o2% recorded.")
            }
        } else {
            speakFeedback("Could not parse oxygen saturation. Say: O2 sat 98")
        }
    }

    /**
     * Parse respiratory rate: "16", "18 breaths per minute"
     */
    private fun parseRespiratoryRate(text: String) {
        val match = Regex("(\\d{1,2})").find(text)
        if (match != null) {
            val rr = match.groupValues[1].toIntOrNull() ?: return
            val range = vitalRanges["respiratory_rate"]!!

            if (rr < range.min || rr > range.max) {
                speakFeedback("Respiratory rate $rr seems out of range. Please verify.")
                return
            }

            val vital = CapturedVital(
                type = VitalType.RESPIRATORY_RATE,
                value = rr.toString(),
                unit = "/min",
                displayName = "Respiratory Rate"
            )
            addCapturedVital(vital)

            val isCritical = (range.criticalHigh != null && rr >= range.criticalHigh) ||
                             (range.criticalLow != null && rr <= range.criticalLow)

            if (isCritical) {
                speakFeedback("Warning! Respiratory rate $rr recorded. Critical value detected.")
            } else {
                speakFeedback("Respiratory rate $rr recorded.")
            }
        } else {
            speakFeedback("Could not parse respiratory rate. Say: resp rate 16")
        }
    }

    /**
     * Parse weight: "180 pounds", "82 kilos", "180 lbs"
     */
    private fun parseWeight(text: String) {
        val match = Regex("(\\d{1,3}(?:\\.\\d)?)").find(text)
        if (match != null) {
            val weight = match.groupValues[1].toDoubleOrNull() ?: return

            // Determine unit
            val isKg = text.contains("kilo") || text.contains("kg")
            val unit = if (isKg) "kg" else "lbs"
            val range = if (isKg) vitalRanges["weight_kg"]!! else vitalRanges["weight_lbs"]!!

            if (weight < range.min || weight > range.max) {
                speakFeedback("Weight $weight $unit seems out of range. Please verify.")
                return
            }

            val vital = CapturedVital(
                type = VitalType.WEIGHT,
                value = weight.toString(),
                unit = unit,
                displayName = "Weight"
            )
            addCapturedVital(vital)
            speakFeedback("Weight $weight $unit recorded.")
        } else {
            speakFeedback("Could not parse weight. Say: weight 180 pounds")
        }
    }

    /**
     * Parse height: "5 foot 10", "178 centimeters", "70 inches"
     */
    private fun parseHeight(text: String) {
        // Try feet and inches: "5 foot 10", "5'10"
        val feetInchesMatch = Regex("(\\d)\\s*(?:foot|feet|ft|')\\s*(\\d{1,2})").find(text)
        if (feetInchesMatch != null) {
            val feet = feetInchesMatch.groupValues[1].toIntOrNull() ?: 0
            val inches = feetInchesMatch.groupValues[2].toIntOrNull() ?: 0
            val totalInches = feet * 12 + inches

            val vital = CapturedVital(
                type = VitalType.HEIGHT,
                value = "$feet'$inches\"",
                unit = "ft/in",
                displayName = "Height"
            )
            addCapturedVital(vital)
            speakFeedback("Height $feet foot $inches recorded.")
            return
        }

        // Try just a number with unit
        val match = Regex("(\\d{2,3})").find(text)
        if (match != null) {
            val height = match.groupValues[1].toIntOrNull() ?: return

            val isCm = text.contains("centimeter") || text.contains("cm") || height > 100
            val unit = if (isCm) "cm" else "in"

            val vital = CapturedVital(
                type = VitalType.HEIGHT,
                value = height.toString(),
                unit = unit,
                displayName = "Height"
            )
            addCapturedVital(vital)
            speakFeedback("Height $height $unit recorded.")
        } else {
            speakFeedback("Could not parse height. Say: height 5 foot 10")
        }
    }

    /**
     * Parse pain level: "5 out of 10", "pain level 7", "pain 8"
     */
    private fun parsePainLevel(text: String) {
        val match = Regex("(\\d{1,2})").find(text)
        if (match != null) {
            val pain = match.groupValues[1].toIntOrNull() ?: return
            val range = vitalRanges["pain"]!!

            if (pain < range.min || pain > range.max) {
                speakFeedback("Pain level must be 0 to 10.")
                return
            }

            val vital = CapturedVital(
                type = VitalType.PAIN_LEVEL,
                value = pain.toString(),
                unit = "/10",
                displayName = "Pain Level"
            )
            addCapturedVital(vital)
            speakFeedback("Pain level $pain out of 10 recorded.")
        } else {
            speakFeedback("Could not parse pain level. Say: pain 5 out of 10")
        }
    }

    /**
     * Add a captured vital, update the display, and auto-push to EHR
     */
    private fun addCapturedVital(vital: CapturedVital) {
        // Remove any existing vital of the same type (keep most recent)
        capturedVitals.removeAll { it.type == vital.type }
        capturedVitals.add(vital)
        Log.d(TAG, "Captured vital: ${vital.displayName} = ${vital.value} ${vital.unit}")

        // Auto-push to EHR
        pushSingleVitalToEhr(vital)
    }

    /**
     * Push a single vital to EHR immediately
     */
    private fun pushSingleVitalToEhr(vital: CapturedVital) {
        val patientId = currentPatientData?.optString("patient_id", "") ?: ""
        if (patientId.isEmpty() || !isNetworkAvailable()) {
            return
        }

        Thread {
            try {
                val vitalType = when (vital.type) {
                    VitalType.BLOOD_PRESSURE -> "blood_pressure"
                    VitalType.HEART_RATE -> "heart_rate"
                    VitalType.TEMPERATURE -> "temperature"
                    VitalType.OXYGEN_SATURATION -> "oxygen_saturation"
                    VitalType.RESPIRATORY_RATE -> "respiratory_rate"
                    VitalType.WEIGHT -> "weight"
                    VitalType.HEIGHT -> "height"
                    VitalType.PAIN_LEVEL -> "pain_level"
                }

                val requestBody = JSONObject().apply {
                    put("patient_id", patientId)
                    put("vital_type", vitalType)
                    put("value", vital.value)
                    put("unit", vital.unit)
                    put("performer_name", clinicianName)
                    put("device_type", "AR_GLASSES")

                    if (vital.type == VitalType.BLOOD_PRESSURE && vital.value.contains("/")) {
                        val parts = vital.value.split("/")
                        if (parts.size == 2) {
                            put("systolic", parts[0].trim().toIntOrNull() ?: 0)
                            put("diastolic", parts[1].trim().toIntOrNull() ?: 0)
                        }
                    }
                }

                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/vitals/push")
                    .post(requestBody.toString().toRequestBody("application/json".toMediaType()))
                    .build()

                val response = httpClient.newCall(request).execute()
                if (response.isSuccessful) {
                    Log.d(TAG, "Auto-pushed vital: ${vital.displayName}")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Auto-push vital failed: ${e.message}")
            }
        }.start()
    }

    /**
     * Show all captured vitals
     */
    private fun showCapturedVitals() {
        if (capturedVitals.isEmpty()) {
            speakFeedback("No vitals captured yet. Say a vital like: BP 120 over 80")
            return
        }

        val content = StringBuilder()
        content.append("═══════════════════════════\n")
        content.append("📊 CAPTURED VITALS\n")
        content.append("═══════════════════════════\n\n")

        capturedVitals.forEach { vital ->
            val timeAgo = getTimeAgo(vital.timestamp)
            content.append("${vital.displayName}: ${vital.value} ${vital.unit}\n")
            content.append("  ($timeAgo)\n\n")
        }

        content.append("───────────────────────────\n")
        content.append("Say \"add vitals to note\" or\n")
        content.append("\"clear vitals\" to reset")

        showDataOverlay("Captured Vitals", content.toString())
        speakFeedback("${capturedVitals.size} vitals captured.")
    }

    /**
     * Clear all captured vitals
     */
    private fun clearCapturedVitals() {
        val count = capturedVitals.size
        capturedVitals.clear()
        hideDataOverlay()
        speakFeedback("Cleared $count vitals.")
    }

    /**
     * Format captured vitals for note insertion
     */
    private fun getCapturedVitalsForNote(): String {
        if (capturedVitals.isEmpty()) return ""

        val sb = StringBuilder()
        sb.append("Vitals:\n")
        capturedVitals.forEach { vital ->
            sb.append("• ${vital.displayName}: ${vital.value} ${vital.unit}\n")
        }
        return sb.toString()
    }

    /**
     * Add captured vitals to the current note
     */
    private fun addVitalsToNote() {
        if (capturedVitals.isEmpty()) {
            speakFeedback("No vitals to add. Capture vitals first.")
            return
        }

        val vitalsText = getCapturedVitalsForNote()

        // Add to objective section if note is active
        if (noteEditText != null && editableNoteContent != null) {
            appendToNoteSection("objective", vitalsText)
            speakFeedback("Added ${capturedVitals.size} vitals to objective section.")
        } else {
            // Store for later use
            pendingPlanItems.add(vitalsText)
            speakFeedback("${capturedVitals.size} vitals saved. They will be included in your next note.")
        }
    }

    /**
     * Add medication directly to note plan section
     * Voice: "add med aspirin", "add medication ibuprofen 400mg twice daily"
     */
    private fun addMedicationToNote(medText: String) {
        if (medText.isBlank()) {
            speakFeedback("Please specify a medication. Say add med followed by the medication name and dose.")
            return
        }

        // Capitalize first letter
        val formattedMed = medText.trim().replaceFirstChar { it.uppercase() }
        val medEntry = "• Rx: $formattedMed"

        // Add to plan section if note is active
        if (noteEditText != null && editableNoteContent != null) {
            appendToNoteSection("plan", medEntry)
            showDataOverlay("MEDICATION ADDED", "Added to Plan:\n$medEntry")
            speakFeedback("Added $formattedMed to plan.")
        } else {
            // Store for later use
            pendingPlanItems.add(medEntry)
            showDataOverlay("MEDICATION SAVED", "Saved for next note:\n$medEntry")
            speakFeedback("Saved $formattedMed. It will be included in your next note.")
        }
    }

    /**
     * Get relative time ago string
     */
    private fun getTimeAgo(timestamp: Long): String {
        val diff = System.currentTimeMillis() - timestamp
        val seconds = diff / 1000
        val minutes = seconds / 60
        val hours = minutes / 60

        return when {
            seconds < 60 -> "just now"
            minutes < 60 -> "$minutes min ago"
            hours < 24 -> "$hours hr ago"
            else -> "${hours / 24} days ago"
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // VITAL HISTORY - Historical Vital Sign Display
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Fetch and display vital sign history from EHR
     */
    private fun fetchVitalHistory() {
        val patientId = currentPatientData?.optString("patient_id")
        if (patientId.isNullOrEmpty()) {
            speakFeedback("No patient loaded. Load a patient first.")
            return
        }

        statusText.text = "Loading vital history..."
        transcriptText.text = "Fetching from EHR"

        Thread {
            try {
                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/patient/$patientId/vital-history")
                    .get()
                    .build()

                httpClient.newCall(request).enqueue(object : Callback {
                    override fun onFailure(call: Call, e: IOException) {
                        Log.e(TAG, "Vital history fetch error: ${e.message}")
                        runOnUiThread {
                            statusText.text = "Failed to load"
                            transcriptText.text = "Error: ${e.message}"
                            speakFeedback("Failed to load vital history.")
                        }
                    }

                    override fun onResponse(call: Call, response: Response) {
                        val body = response.body?.string()
                        Log.d(TAG, "Vital history response: $body")

                        runOnUiThread {
                            try {
                                val json = JSONObject(body ?: "{}")
                                showVitalHistoryOverlay(json)
                            } catch (e: Exception) {
                                Log.e(TAG, "Parse error: ${e.message}")
                                showDataOverlay("Error", "Parse error: ${e.message}")
                            }
                        }
                    }
                })
            } catch (e: Exception) {
                Log.e(TAG, "Failed to fetch vital history: ${e.message}")
            }
        }.start()
    }

    /**
     * Display vital history in a timeline format
     */
    private fun showVitalHistoryOverlay(historyJson: JSONObject) {
        val history = historyJson.optJSONObject("history")
        if (history == null || history.length() == 0) {
            showDataOverlay("Vital History", "No vital sign history available.")
            speakFeedback("No vital history found for this patient.")
            return
        }

        val content = StringBuilder()
        content.append("═══════════════════════════════════\n")
        content.append("📊 VITAL SIGN HISTORY\n")
        content.append("═══════════════════════════════════\n\n")

        // Define the order we want to display vitals
        val vitalOrder = listOf(
            "Blood Pressure",
            "Systolic Blood Pressure",
            "Diastolic Blood Pressure",
            "Heart rate",
            "Body temperature",
            "Oxygen saturation",
            "Respiratory rate",
            "Body Weight",
            "Body Height",
            "BMI"
        )

        // Track displayed vitals
        val displayedVitals = mutableSetOf<String>()

        // First, display vitals in preferred order
        for (vitalName in vitalOrder) {
            if (history.has(vitalName)) {
                displayVitalTimeline(content, vitalName, history.getJSONArray(vitalName))
                displayedVitals.add(vitalName)
            }
        }

        // Then display any remaining vitals not in our preferred order
        val keys = history.keys()
        while (keys.hasNext()) {
            val vitalName = keys.next()
            if (vitalName !in displayedVitals) {
                displayVitalTimeline(content, vitalName, history.getJSONArray(vitalName))
            }
        }

        content.append("\n───────────────────────────────────\n")
        content.append("📅 Last ${historyJson.optInt("vital_types", 0)} vital types shown")

        showDataOverlay("Vital History", content.toString())

        // Provide TTS summary
        val vitalCount = historyJson.optInt("vital_types", 0)
        speakFeedback("Showing history for $vitalCount vital types.")
    }

    /**
     * Display a single vital's timeline with trend indicators
     */
    private fun displayVitalTimeline(sb: StringBuilder, vitalName: String, readings: JSONArray) {
        if (readings.length() == 0) return

        // Get emoji for vital type
        val emoji = when {
            vitalName.contains("Blood Pressure", ignoreCase = true) -> "🩸"
            vitalName.contains("Heart", ignoreCase = true) || vitalName.contains("Pulse", ignoreCase = true) -> "💓"
            vitalName.contains("Temperature", ignoreCase = true) -> "🌡️"
            vitalName.contains("Oxygen", ignoreCase = true) || vitalName.contains("SpO2", ignoreCase = true) -> "🫁"
            vitalName.contains("Respiratory", ignoreCase = true) -> "💨"
            vitalName.contains("Weight", ignoreCase = true) -> "⚖️"
            vitalName.contains("Height", ignoreCase = true) -> "📏"
            vitalName.contains("BMI", ignoreCase = true) -> "📊"
            else -> "•"
        }

        sb.append("$emoji $vitalName\n")
        sb.append("───────────────────────────────────\n")

        var previousValue: Double? = null

        for (i in 0 until readings.length()) {
            val reading = readings.getJSONObject(i)
            val value = reading.optString("value", "N/A")
            val unit = reading.optString("unit", "")
            val dateStr = reading.optString("date", "")
            val interpretation = reading.optString("interpretation", "")

            // Parse numeric value for trend calculation
            val numericValue = value.replace(Regex("[^0-9.-]"), "").toDoubleOrNull()

            // Calculate trend indicator
            val trendIcon = if (numericValue != null && previousValue != null) {
                val diff = numericValue - previousValue
                when {
                    diff > 0 -> "↗️"
                    diff < 0 -> "↘️"
                    else -> "→"
                }
            } else if (i == 0) {
                "🆕"  // Most recent
            } else {
                ""
            }

            // Format date to be more readable
            val formattedDate = formatVitalDate(dateStr)

            // Interpretation indicator
            val interpIndicator = when (interpretation) {
                "HH" -> "‼️"
                "LL" -> "‼️"
                "H" -> "↑"
                "L" -> "↓"
                else -> ""
            }

            // Build the reading line
            sb.append("  $trendIcon $value $unit $interpIndicator")
            if (formattedDate.isNotEmpty()) {
                sb.append(" ($formattedDate)")
            }
            sb.append("\n")

            previousValue = numericValue
        }

        sb.append("\n")
    }

    /**
     * Format FHIR date string to readable format
     */
    private fun formatVitalDate(dateStr: String): String {
        if (dateStr.isEmpty()) return ""

        try {
            // Parse ISO date format (e.g., "2024-12-29T10:30:00Z" or "2024-12-29")
            val inputFormat = if (dateStr.contains("T")) {
                java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", java.util.Locale.US)
            } else {
                java.text.SimpleDateFormat("yyyy-MM-dd", java.util.Locale.US)
            }
            val outputFormat = java.text.SimpleDateFormat("MMM d", java.util.Locale.US)

            val date = inputFormat.parse(dateStr.substringBefore("Z").substringBefore("+"))
            return date?.let { outputFormat.format(it) } ?: dateStr.substring(0, minOf(10, dateStr.length))
        } catch (e: Exception) {
            // Return first 10 chars if parsing fails
            return dateStr.substring(0, minOf(10, dateStr.length))
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // ENCOUNTER TIMER - Timer Control Functions
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Start the encounter timer
     */
    private fun startEncounterTimer() {
        if (encounterTimerRunning) {
            val elapsed = getElapsedTimeFormatted()
            speakFeedback("Timer already running. $elapsed elapsed.")
            return
        }

        encounterStartTime = System.currentTimeMillis()
        encounterTimerRunning = true
        showTimerIndicator()
        startTimerUpdates()
        speakFeedback("Encounter timer started")
        Log.d(TAG, "Encounter timer started")
    }

    /**
     * Stop the encounter timer
     */
    private fun stopEncounterTimer() {
        if (!encounterTimerRunning) {
            speakFeedback("No timer running")
            return
        }

        val elapsed = getElapsedTimeFormatted()
        val minutes = getElapsedMinutes()
        encounterTimerRunning = false
        stopTimerUpdates()
        hideTimerIndicator()

        // Speak the total time
        speakFeedback("Encounter timer stopped. Total time: $elapsed")

        // Show summary
        Toast.makeText(this, "Encounter: $elapsed ($minutes min)", Toast.LENGTH_LONG).show()
        Log.d(TAG, "Encounter timer stopped: $elapsed")
    }

    /**
     * Report the current elapsed time
     */
    private fun reportEncounterTime() {
        if (!encounterTimerRunning) {
            speakFeedback("No timer running. Say start timer to begin.")
            return
        }

        val elapsed = getElapsedTimeFormatted()
        val minutes = getElapsedMinutes()
        speakFeedback("You have been with this patient for $elapsed. That's $minutes minutes.")
    }

    /**
     * Reset the encounter timer without stopping
     */
    private fun resetEncounterTimer() {
        if (!encounterTimerRunning) {
            speakFeedback("No timer running")
            return
        }

        encounterStartTime = System.currentTimeMillis()
        speakFeedback("Timer reset")
        updateTimerDisplay()
    }

    /**
     * Get elapsed time in formatted string (e.g., "5 minutes 30 seconds")
     */
    private fun getElapsedTimeFormatted(): String {
        val startTime = encounterStartTime ?: return "0 seconds"
        val elapsedMs = System.currentTimeMillis() - startTime
        val totalSeconds = elapsedMs / 1000
        val minutes = totalSeconds / 60
        val seconds = totalSeconds % 60

        return when {
            minutes == 0L -> "$seconds seconds"
            seconds == 0L -> "$minutes minutes"
            else -> "$minutes minutes $seconds seconds"
        }
    }

    /**
     * Get elapsed time in minutes (for billing)
     */
    private fun getElapsedMinutes(): Int {
        val startTime = encounterStartTime ?: return 0
        val elapsedMs = System.currentTimeMillis() - startTime
        return (elapsedMs / 60000).toInt()
    }

    /**
     * Get elapsed time in MM:SS format for display
     */
    private fun getElapsedTimeDisplay(): String {
        val startTime = encounterStartTime ?: return "00:00"
        val elapsedMs = System.currentTimeMillis() - startTime
        val totalSeconds = elapsedMs / 1000
        val minutes = totalSeconds / 60
        val seconds = totalSeconds % 60
        return String.format("%02d:%02d", minutes, seconds)
    }

    /**
     * Get elapsed time in seconds
     */
    private fun getElapsedSeconds(): Long {
        val startTime = encounterStartTime ?: return 0
        return (System.currentTimeMillis() - startTime) / 1000
    }

    /**
     * Show the timer indicator on screen
     */
    private fun showTimerIndicator() {
        if (timerIndicatorView != null) return

        timerIndicatorView = TextView(this).apply {
            text = "⏱ 00:00"
            textSize = 14f
            setTextColor(0xFFFFFFFF.toInt())
            setBackgroundColor(0xCC2563EB.toInt())  // Blue with transparency
            setPadding(16, 8, 16, 8)
            gravity = android.view.Gravity.CENTER

            // Position at top right
            val params = android.widget.FrameLayout.LayoutParams(
                android.widget.FrameLayout.LayoutParams.WRAP_CONTENT,
                android.widget.FrameLayout.LayoutParams.WRAP_CONTENT
            ).apply {
                gravity = android.view.Gravity.TOP or android.view.Gravity.END
                topMargin = 100
                rightMargin = 16
            }
            layoutParams = params
        }

        val rootView = findViewById<android.view.ViewGroup>(android.R.id.content)
        rootView.addView(timerIndicatorView)
    }

    /**
     * Hide the timer indicator
     */
    private fun hideTimerIndicator() {
        timerIndicatorView?.let { view ->
            val rootView = findViewById<android.view.ViewGroup>(android.R.id.content)
            rootView.removeView(view)
        }
        timerIndicatorView = null
    }

    /**
     * Start periodic timer updates
     */
    private fun startTimerUpdates() {
        timerUpdateHandler = android.os.Handler(android.os.Looper.getMainLooper())
        timerUpdateRunnable = object : Runnable {
            override fun run() {
                if (encounterTimerRunning) {
                    updateTimerDisplay()
                    timerUpdateHandler?.postDelayed(this, 1000)  // Update every second
                }
            }
        }
        timerUpdateHandler?.post(timerUpdateRunnable!!)
    }

    /**
     * Stop periodic timer updates
     */
    private fun stopTimerUpdates() {
        timerUpdateRunnable?.let { timerUpdateHandler?.removeCallbacks(it) }
        timerUpdateHandler = null
        timerUpdateRunnable = null
    }

    /**
     * Update the timer display
     */
    private fun updateTimerDisplay() {
        timerIndicatorView?.text = "⏱ ${getElapsedTimeDisplay()}"
    }

    /**
     * Get encounter time for documentation (adds to note)
     */
    private fun getEncounterTimeForNote(): String {
        if (!encounterTimerRunning && encounterStartTime == null) return ""
        val minutes = getElapsedMinutes()
        return "Time spent with patient: $minutes minutes"
    }

    private fun showVoiceCommandHelp() {
        val helpText = """
            |🎤 VOICE COMMANDS
            |${"─".repeat(30)}
            |
            |📋 PATIENT DATA
            |• "Load patient" - Load test patient
            |• "Find [name]" - Search patients
            |• "Scan wristband" - Scan barcode
            |
            |🏥 CLINICAL INFO
            |• "Show vitals" - Display vitals
            |• "Show allergies" - Display allergies
            |• "Show meds" - Display medications
            |• "Show labs" - Display lab results
            |• "Show procedures" - Display procedures
            |• "Show immunizations" - Display vaccines
            |• "Show conditions" - Display diagnoses
            |• "Show care plans" - Display care plans
            |• "Show notes" - Display clinical notes
            |
            |🔊 PATIENT SUMMARY (Hands-Free)
            |• "Patient summary" - Show quick overview
            |• "Brief me" - Speak summary aloud
            |• "Tell me about patient" - Spoken briefing
            |• "Stop talking" - Stop speech
            |
            |📋 SBAR HANDOFF
            |• "Handoff report" - Generate SBAR report
            |• "SBAR" - Show handoff report
            |• "Read handoff" - Speak handoff aloud
            |• "Give handoff" - Verbal SBAR report
            |
            |📄 DISCHARGE SUMMARY
            |• "Discharge summary" - Generate summary
            |• "Discharge instructions" - Patient instructions
            |• "Read discharge" - Speak to patient
            |• "Patient education" - Verbal instructions
            |
            |✅ PROCEDURE CHECKLISTS
            |• "Show checklists" - List available checklists
            |• "Start timeout checklist" - Begin timeout
            |• "Start central line checklist" - CL insertion
            |• "Check [number]" - Check off item
            |• "Check all" - Mark all complete
            |• "Read checklist" - Speak items aloud
            |
            |🔔 CLINICAL REMINDERS
            |• "Clinical reminders" - Show care reminders
            |• "Preventive care" - Age/condition-based alerts
            |• "Health reminders" - Screening prompts
            |
            |⚖️ MED RECONCILIATION
            |• "Med reconciliation" - Start med rec
            |• "Add home med [name]" - Add medication
            |• "Remove home med [#]" - Remove by number
            |• "Compare meds" - Show discrepancies
            |• "Clear home meds" - Start over
            |
            |📤 REFERRAL TRACKING
            |• "Show referrals" - View all referrals
            |• "Refer to [specialty] for [reason]"
            |• "Urgent referral to [specialty]"
            |• "Mark referral [#] scheduled"
            |• "Mark referral [#] complete"
            |
            |📝 DOCUMENTATION
            |• "Start note" - Begin documentation
            |• "Live transcribe" - Real-time transcription
            |• "Stop transcription" - End transcription
            |• "SOAP note" - Set note type to SOAP
            |• "Progress note" - Set to Progress Note
            |• "H&P note" - Set to H&P
            |• "Consult note" - Set to Consult
            |• "Auto note" - Auto-detect note type
            |
            |📋 TRANSCRIPT PREVIEW
            |• "Generate note" - Create note from transcript
            |• "Looks good" - Confirm and generate
            |• "Re-record" - Start over
            |• "Try again" - Discard and re-record
            |
            |💾 NOTE MANAGEMENT
            |• "Edit note" - Focus note for editing
            |• "Reset note" - Restore original note
            |• "Save note" - Sign off and save
            |
            |✏️ VOICE NOTE EDITING
            |• "Change [section] to [text]" - Replace section
            |• "Add to [section]: [text]" - Append to section
            |• "Delete last sentence" - Remove last sentence
            |• "Delete [section] item [N]" - Remove item
            |• "Clear [section]" - Clear entire section
            |• "Insert normal exam" - Add normal exam
            |• "Insert follow up" - Add follow-up text
            |• "Undo" - Undo last change
            |
            |🧭 VOICE NAVIGATION
            |• "Scroll down" / "Page down" - Scroll down
            |• "Scroll up" / "Page up" - Scroll up
            |• "Go to top" - Scroll to top
            |• "Go to bottom" - Scroll to bottom
            |• "Go to [section]" - Jump to section
            |• "Show [section] only" - Show one section
            |• "Read [section]" - Read section aloud
            |• "Read note" - Read entire note aloud
            |
            |🎙️ VOICE DICTATION
            |• "Dictate to [section]" - Start dictating
            |• "Stop dictating" - End and insert text
            |• "Cancel dictation" - Discard dictated text
            |
            |📤 OFFLINE DRAFTS
            |• "Show drafts" - View pending drafts
            |• "Sync notes" - Upload pending drafts
            |• "Delete draft [N]" - Remove draft
            |• "View draft [N]" - See draft details
            |
            |⚙️ SETTINGS
            |• "My name is Dr. [Name]" - Set clinician
            |• "Increase font" - Larger text
            |• "Decrease font" - Smaller text
            |• "Auto scroll on/off" - Toggle scroll
            |• "Speech feedback" - Toggle voice confirmations
            |
            |📋 HISTORY
            |• "Show history" - Recent patients
            |• "Load [N]" - Load patient from history
            |• "Clear history" - Clear patient history
            |
            |🔐 SECURITY
            |• "Lock session" - Lock for HIPAA
            |• "Unlock" - Unlock session
            |• "Timeout [N] min" - Set timeout
            |
            |📄 VOICE TEMPLATES
            |• "Use [template] template" - Apply template
            |• "List templates" - Show all templates
            |• "Save as template [name]" - Save current note
            |• "Delete template [name]" - Remove user template
            |  (diabetes, hypertension, URI, physical,
            |   back pain, UTI, well child, chest pain)
            |
            |📋 VOICE ORDERS
            |• "Order [lab]" - Order a lab test
            |  (CBC, CMP, BMP, UA, Lipids, TSH, A1c, PT/INR)
            |• "Order [imaging]" - Order imaging study
            |  (chest x-ray, CT head/chest, MRI, echo)
            |• "Order CT [part] with/without contrast"
            |• "Prescribe [med] [dose] [freq] for [duration]"
            |  (amoxicillin, ibuprofen, prednisone, etc.)
            |• "Show orders" - View pending orders
            |• "Cancel order" - Remove last order
            |• "Clear all orders" - Remove all orders
            |• "Yes" / "No" - Confirm/reject after warning
            |
            |📦 ORDER SETS (Batch Orders)
            |• "Order chest pain workup" - ACS rule-out
            |• "Order sepsis bundle" - Sepsis workup
            |• "Order stroke workup" - CVA workup
            |• "Order admission labs" - Standard admission
            |• "Order preop labs" - Surgical clearance
            |• "Order PE workup" - Pulmonary embolism
            |• "Order DKA protocol" - Diabetic ketoacidosis
            |• "Order pneumonia workup" - CAP workup
            |• "List order sets" - Show all sets
            |• "What's in [set]" - Preview set contents
            |
            |⏱️ ENCOUNTER TIMER
            |• "Start timer" - Begin timing encounter
            |• "Stop timer" - End timer, report total
            |• "How long" - Check elapsed time
            |• "Reset timer" - Restart from zero
            |
            |📊 VOICE VITALS ENTRY
            |• "BP 120 over 80" - Record blood pressure
            |• "Pulse 72" / "Heart rate 80" - Record HR
            |• "Temp 98.6" - Record temperature
            |• "O2 sat 98" / "Oxygen 95" - Record SpO2
            |• "Resp rate 16" - Record respiratory rate
            |• "Weight 180 pounds" - Record weight
            |• "Height 5 foot 10" - Record height
            |• "Pain 5 out of 10" - Record pain level
            |• "Show captured vitals" - View all vitals
            |• "Vital history" - View past readings
            |• "Add vitals to note" - Insert into note
            |• "Clear vitals" - Remove all captured
            |
            |🧮 MEDICAL CALCULATORS
            |• "Calculate BMI" - Body mass index
            |• "Calculate GFR" - Kidney function
            |• "Corrected calcium" - Adjust for albumin
            |• "Anion gap" - From BMP labs
            |• "A1c to glucose" - Convert HbA1c
            |• "Calculate MAP" - Mean arterial pressure
            |• "Creatinine clearance" - CrCl
            |• "CHADS VASc" - Stroke risk
            |• "Calculators" - Show all
            |
            |🎤 CUSTOM COMMANDS
            |• "Create command [name] that does [actions]"
            |• "When I say [phrase] do [action]"
            |• "Teach [name] to [actions]"
            |• "My commands" - List custom commands
            |• "Delete command [name]" - Remove
            |
            |🏥 SPECIALTY TEMPLATES
            |• "Specialty templates" - List all 14 templates
            |• "Use [template] template" - Apply template
            |  (cardiology chest pain, heart failure, afib,
            |   ortho joint pain, fracture, neuro headache,
            |   stroke, gi abdominal pain, gerd, pulm copd,
            |   asthma, psych depression, anxiety, trauma, sepsis)
            |
            |📜 NOTE VERSIONING
            |• "Version history" - Show all note versions
            |• "Restore version [N]" - Restore older version
            |• "Compare versions" - Diff current vs previous
            |• "Clear version history" - Clear all versions
            |
            |🔐 DATA ENCRYPTION
            |• "Encryption status" - Show security info
            |• "Wipe data" - Securely erase all PHI
            |
            |🔧 OTHER
            |• Just speak naturally - no wake word needed
            |• "Close" - Dismiss overlay
            |• "Clear cache" - Clear offline data
            |• "Help" - Show this help
        """.trimMargin()

        showDataOverlay("Voice Commands", helpText)
        statusText.text = "Voice Command Help"
        transcriptText.text = "Say any command or 'close'"
        Log.d(TAG, "Showing voice command help")
    }

    private fun showQuickPatientSummary() {
        val patient = currentPatientData
        if (patient == null) {
            Toast.makeText(this, "No patient loaded. Say 'load patient' first.", Toast.LENGTH_SHORT).show()
            return
        }

        val name = patient.optString("name", "Unknown")
        val dob = patient.optString("date_of_birth", "")
        val gender = patient.optString("gender", "").uppercase()

        val sb = StringBuilder()
        sb.append("👤 PATIENT SUMMARY\n")
        sb.append("${"═".repeat(30)}\n\n")

        // Demographics
        sb.append("$name\n")
        if (dob.isNotEmpty()) sb.append("DOB: $dob")
        if (gender.isNotEmpty()) sb.append(" | $gender")
        sb.append("\n\n")

        // Critical: Allergies (always show first)
        val allergies = patient.optJSONArray("allergies")
        sb.append("⚠️ ALLERGIES\n")
        if (allergies != null && allergies.length() > 0) {
            for (i in 0 until minOf(allergies.length(), 5)) {
                // Handle both string and JSONObject formats
                val allergyName = try {
                    allergies.getString(i)
                } catch (e: Exception) {
                    try {
                        allergies.getJSONObject(i).optString("name", "")
                    } catch (e2: Exception) { "" }
                }
                if (allergyName.isNotBlank()) {
                    sb.append("  • $allergyName\n")
                }
            }
            if (allergies.length() > 5) sb.append("  (+${allergies.length() - 5} more)\n")
        } else {
            sb.append("  No known allergies\n")
        }
        sb.append("\n")

        // Active Conditions
        val conditions = patient.optJSONArray("conditions")
        sb.append("📋 ACTIVE CONDITIONS\n")
        if (conditions != null && conditions.length() > 0) {
            var activeCount = 0
            for (i in 0 until minOf(conditions.length(), 5)) {
                // Handle both JSONObject and String array formats
                val condName = try {
                    val cond = conditions.getJSONObject(i)
                    cond.optString("name", "")
                } catch (e: Exception) {
                    conditions.optString(i, "")
                }
                val status = try {
                    conditions.getJSONObject(i).optString("status", "")
                } catch (e: Exception) { "" }

                if (condName.isNotEmpty()) {
                    sb.append("  • $condName")
                    if (status.isNotEmpty()) sb.append(" [$status]")
                    sb.append("\n")
                    activeCount++
                }
            }
            if (conditions.length() > 5) sb.append("  (+${conditions.length() - 5} more)\n")
            if (activeCount == 0) sb.append("  None recorded\n")
        } else {
            sb.append("  None recorded\n")
        }
        sb.append("\n")

        // Current Medications
        val meds = patient.optJSONArray("medications")
        sb.append("💊 CURRENT MEDICATIONS\n")
        if (meds != null && meds.length() > 0) {
            for (i in 0 until minOf(meds.length(), 5)) {
                // Handle both string and JSONObject formats
                val medName = try {
                    meds.getString(i)
                } catch (e: Exception) {
                    try {
                        meds.getJSONObject(i).optString("name", "")
                    } catch (e2: Exception) { "" }
                }
                if (medName.isNotBlank()) {
                    sb.append("  • $medName\n")
                }
            }
            if (meds.length() > 5) sb.append("  (+${meds.length() - 5} more)\n")
        } else {
            sb.append("  None recorded\n")
        }
        sb.append("\n")

        // Recent Vitals (just the key ones)
        val vitals = patient.optJSONArray("vitals")
        sb.append("📊 RECENT VITALS\n")
        if (vitals != null && vitals.length() > 0) {
            for (i in 0 until minOf(vitals.length(), 4)) {
                val v = vitals.getJSONObject(i)
                sb.append("  • ${v.optString("name")}: ${v.optString("value")}${v.optString("unit")}\n")
            }
        } else {
            sb.append("  None recorded\n")
        }

        showDataOverlay("Patient Summary", sb.toString())
        statusText.text = "Patient Summary"
        transcriptText.text = "Key info for $name"
        Log.d(TAG, "Showing quick patient summary for $name")
    }

    /**
     * Initialize Text-to-Speech for hands-free patient information
     * Allows clinicians to hear patient summary while walking to the room
     * Supports multi-language TTS (English, Spanish, Mandarin, Portuguese)
     */
    private fun initTextToSpeech() {
        try {
            // Try with specific Pico TTS engine first (available on Vuzix)
            textToSpeech = TextToSpeech(this, { status ->
                if (status == TextToSpeech.SUCCESS) {
                    Log.d(TAG, "TTS: Initialization succeeded with Pico")
                    updateTtsLanguage()
                } else {
                    Log.e(TAG, "TTS: Pico init failed with status $status, trying default...")
                    // Try default engine
                    initDefaultTts()
                }
            }, "com.svox.pico")
        } catch (e: Exception) {
            Log.e(TAG, "TTS: Exception during Pico init: ${e.message}")
            initDefaultTts()
        }
    }

    private fun initDefaultTts() {
        try {
            textToSpeech = TextToSpeech(this) { status ->
                if (status == TextToSpeech.SUCCESS) {
                    Log.d(TAG, "TTS: Default engine succeeded")
                    updateTtsLanguage()
                } else {
                    Log.e(TAG, "TTS: Default init failed with status $status")
                    isTtsReady = false
                    // Try to reinitialize after a delay
                    android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({
                        retryTtsInit()
                    }, 3000)
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "TTS: Default init exception: ${e.message}")
            isTtsReady = false
        }
    }

    private fun retryTtsInit() {
        Log.d(TAG, "TTS: Retrying initialization...")
        try {
            // List available TTS engines
            val engines = textToSpeech?.engines
            Log.d(TAG, "TTS: Available engines: ${engines?.map { it.name }}")

            textToSpeech = TextToSpeech(this) { status ->
                if (status == TextToSpeech.SUCCESS) {
                    Log.d(TAG, "TTS: Retry succeeded")
                    updateTtsLanguage()
                } else {
                    Log.e(TAG, "TTS: Retry failed with status $status")
                    isTtsReady = false
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "TTS: Retry exception: ${e.message}")
        }
    }

    /**
     * Update TTS language to match current app language
     */
    private fun updateTtsLanguage() {
        val result = textToSpeech?.setLanguage(currentLocale)
        if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
            Log.e(TAG, "TTS: Language ${currentLocale.displayLanguage} not supported, falling back to US English")
            textToSpeech?.setLanguage(Locale.US)
            isTtsReady = true
        } else {
            isTtsReady = true
            Log.d(TAG, "TTS: Language set to ${currentLocale.displayLanguage}")
        }
        // Set slightly slower speech rate for medical info clarity
        textToSpeech?.setSpeechRate(0.9f)
    }

    /**
     * Speak text aloud using Text-to-Speech
     */
    private fun speak(text: String, queueMode: Int = TextToSpeech.QUEUE_FLUSH) {
        if (isTtsReady && textToSpeech != null) {
            try {
                textToSpeech?.speak(text, queueMode, null, "mdx_tts_${System.currentTimeMillis()}")
            } catch (e: Exception) {
                Log.e(TAG, "TTS speak error: ${e.message}")
                // Fall back to server-side TTS
                speakViaServer(text)
            }
        } else {
            Log.w(TAG, "TTS not ready - using server-side TTS")
            // Fall back to server-side TTS
            speakViaServer(text)
        }
    }

    /**
     * Use server-side TTS when local TTS is not available (e.g., Vuzix)
     */
    private fun speakViaServer(text: String) {
        Thread {
            try {
                val json = JSONObject().apply {
                    put("text", text)
                    put("language", "en")
                }
                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/tts/speak")
                    .post(json.toString().toRequestBody("application/json".toMediaType()))
                    .build()

                httpClient.newCall(request).execute().use { response ->
                    val body = response.body?.string()
                    val result = JSONObject(body ?: "{}")

                    if (result.optBoolean("success", false)) {
                        val audioBase64 = result.optString("audio_base64", "")
                        if (audioBase64.isNotEmpty()) {
                            playBase64Audio(audioBase64)
                            return@use
                        }
                    }
                    // Server TTS failed - show text instead
                    runOnUiThread {
                        showDataOverlay("Patient Summary", text)
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Server TTS error: ${e.message}")
                runOnUiThread {
                    showDataOverlay("Patient Summary", text)
                }
            }
        }.start()
    }

    /**
     * Play base64-encoded audio (MP3)
     */
    private fun playBase64Audio(base64Audio: String) {
        try {
            val audioBytes = android.util.Base64.decode(base64Audio, android.util.Base64.DEFAULT)

            // Save to temp file
            val tempFile = java.io.File.createTempFile("tts_", ".mp3", cacheDir)
            tempFile.writeBytes(audioBytes)

            // Play using MediaPlayer
            val mediaPlayer = android.media.MediaPlayer()
            mediaPlayer.setDataSource(tempFile.absolutePath)
            mediaPlayer.setOnCompletionListener {
                it.release()
                tempFile.delete()
            }
            mediaPlayer.prepare()
            mediaPlayer.start()

            Log.d(TAG, "Playing server TTS audio (${audioBytes.size} bytes)")
        } catch (e: Exception) {
            Log.e(TAG, "Error playing audio: ${e.message}")
        }
    }

    /**
     * Stop any ongoing speech
     */
    private fun stopSpeaking() {
        textToSpeech?.stop()
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // MULTI-LANGUAGE SUPPORT - Language switching functions
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Get localized message for TTS feedback
     */
    private fun getLocalizedMessage(key: String): String? {
        return ttsMessages[key]?.get(currentLanguage)
    }

    /**
     * Switch app language (affects speech recognition and TTS)
     * @param languageCode One of: "en", "es", "zh", "pt", "ru"
     */
    private fun switchLanguage(languageCode: String) {
        currentLanguage = languageCode
        currentLocale = when (languageCode) {
            LANG_SPANISH -> Locale("es", "ES")
            LANG_MANDARIN -> Locale.SIMPLIFIED_CHINESE
            LANG_PORTUGUESE -> Locale("pt", "BR")
            LANG_RUSSIAN -> Locale("ru", "RU")
            else -> Locale.US
        }

        // Save preference
        cachePrefs.edit().putString(PREF_LANGUAGE, languageCode).apply()

        // Update TTS language
        updateTtsLanguage()

        // Provide feedback in the NEW language
        val languageName = when (languageCode) {
            LANG_SPANISH -> "español"
            LANG_MANDARIN -> "中文"
            LANG_PORTUGUESE -> "português"
            LANG_RUSSIAN -> "русский"
            else -> "English"
        }

        val feedback = when (languageCode) {
            LANG_SPANISH -> "Idioma cambiado a español"
            LANG_MANDARIN -> "语言已切换为中文"
            LANG_PORTUGUESE -> "Idioma alterado para português"
            LANG_RUSSIAN -> "Язык изменён на русский"
            else -> "Language changed to English"
        }

        statusText.text = "Language: $languageName"
        transcriptText.text = feedback
        speakFeedback(feedback)

        Log.d(TAG, "Language switched to $languageName ($languageCode)")
    }

    /**
     * Load saved language preference
     */
    private fun loadLanguagePreference() {
        currentLanguage = cachePrefs.getString(PREF_LANGUAGE, LANG_ENGLISH) ?: LANG_ENGLISH
        currentLocale = when (currentLanguage) {
            LANG_SPANISH -> Locale("es", "ES")
            LANG_MANDARIN -> Locale.SIMPLIFIED_CHINESE
            LANG_PORTUGUESE -> Locale("pt", "BR")
            LANG_RUSSIAN -> Locale("ru", "RU")
            else -> Locale.US
        }
        Log.d(TAG, "Loaded language preference: $currentLanguage")
    }

    /**
     * Load server URL from SharedPreferences and configure API/WebSocket endpoints
     * For Vuzix: Ensure the server is reachable on the same network
     */
    private fun loadServerUrl() {
        val savedUrl = cachePrefs.getString(PREF_SERVER_URL, null)
        if (savedUrl != null) {
            setServerUrl(savedUrl)
            Log.d(TAG, "Loaded saved server URL: $savedUrl")
        } else {
            // Use default and log device info for debugging
            setServerUrl(DEFAULT_SERVER_URL)
            Log.d(TAG, "Using default server URL: $DEFAULT_SERVER_URL")
            Log.d(TAG, "Device: ${android.os.Build.MANUFACTURER} ${android.os.Build.MODEL}")

            // Vuzix-specific guidance
            if (android.os.Build.MANUFACTURER.contains("Vuzix", ignoreCase = true)) {
                Log.w(TAG, "Vuzix device detected! Ensure:")
                Log.w(TAG, "  1. Mac running ehr-proxy is on same WiFi as Vuzix glasses")
                Log.w(TAG, "  2. Check Mac IP with: ifconfig | grep 'inet ' | grep -v 127.0.0.1")
                Log.w(TAG, "  3. Update server URL via Settings or use: adb shell")
            }
        }
    }

    /**
     * Save server URL to SharedPreferences
     */
    private fun saveServerUrl(url: String) {
        cachePrefs.edit().putString(PREF_SERVER_URL, url).apply()
        setServerUrl(url)
        Log.d(TAG, "Server URL saved: $url")
    }

    /**
     * Strip accents from text for fuzzy matching
     * Handles Spanish accents: á→a, é→e, í→i, ó→o, ú→u, ñ→n
     */
    private fun stripAccents(text: String): String {
        return text
            .replace('á', 'a').replace('à', 'a').replace('ä', 'a')
            .replace('é', 'e').replace('è', 'e').replace('ë', 'e')
            .replace('í', 'i').replace('ì', 'i').replace('ï', 'i')
            .replace('ó', 'o').replace('ò', 'o').replace('ö', 'o')
            .replace('ú', 'u').replace('ù', 'u').replace('ü', 'u')
            .replace('ñ', 'n')
            .replace('Á', 'A').replace('À', 'A').replace('Ä', 'A')
            .replace('É', 'E').replace('È', 'E').replace('Ë', 'E')
            .replace('Í', 'I').replace('Ì', 'I').replace('Ï', 'I')
            .replace('Ó', 'O').replace('Ò', 'O').replace('Ö', 'O')
            .replace('Ú', 'U').replace('Ù', 'U').replace('Ü', 'U')
            .replace('Ñ', 'N')
    }

    /**
     * Translate non-English command to English for processing
     * Supports Spanish (with accent-insensitive matching) and Russian
     * Returns the English equivalent or the original if not found
     */
    private fun translateCommand(transcript: String): String {
        val lower = transcript.lowercase()

        // Handle Spanish translations
        if (currentLanguage == LANG_SPANISH) {
            val lowerNoAccents = stripAccents(lower)  // For fuzzy matching

            // Check for Spanish command matches (with and without accents)
            for ((spanish, english) in spanishCommands) {
                val spanishNoAccents = stripAccents(spanish)
                if (lower.contains(spanish) || lowerNoAccents.contains(spanishNoAccents)) {
                    return if (lower.contains(spanish)) {
                        lower.replace(spanish, english)
                    } else {
                        lowerNoAccents.replace(spanishNoAccents, english)
                    }
                }
            }

            // Check section aliases for Spanish
            for ((section, aliases) in spanishSectionAliases) {
                for (alias in aliases) {
                    val aliasNoAccents = stripAccents(alias)
                    if (lower.contains(alias) || lowerNoAccents.contains(aliasNoAccents)) {
                        return if (lower.contains(alias)) {
                            lower.replace(alias, section)
                        } else {
                            lowerNoAccents.replace(aliasNoAccents, section)
                        }
                    }
                }
            }
        }

        // Handle Russian translations
        if (currentLanguage == LANG_RUSSIAN) {
            // Check for Russian command matches
            for ((russian, english) in russianCommands) {
                if (lower.contains(russian)) {
                    return lower.replace(russian, english)
                }
            }

            // Check section aliases for Russian
            for ((section, aliases) in russianSectionAliases) {
                for (alias in aliases) {
                    if (lower.contains(alias)) {
                        return lower.replace(alias, section)
                    }
                }
            }
        }

        return transcript
    }

    /**
     * Show available language options
     */
    private fun showLanguageOptions() {
        val content = StringBuilder()
        content.append("═══ LANGUAGE OPTIONS ═══\n\n")
        content.append("Say:\n\n")
        content.append("• \"Switch to English\"\n")
        content.append("• \"Cambiar a español\"\n")
        content.append("• \"Переключить на русский\"\n")
        content.append("• \"切换到中文\"\n")
        content.append("• \"Mudar para português\"\n\n")
        content.append("Or say:\n")
        content.append("• \"Language English\"\n")
        content.append("• \"Language Spanish\"\n")
        content.append("• \"Language Russian\"\n")
        content.append("• \"Language Chinese\"\n")
        content.append("• \"Language Portuguese\"\n\n")
        content.append("Current: ${currentLocale.displayLanguage}")

        showDataOverlay("Language Settings", content.toString())
    }

    /**
     * Speak patient summary aloud - hands-free briefing while walking to patient
     * Creates a natural, conversational summary of key patient information
     */
    private fun speakPatientSummary() {
        val patient = currentPatientData
        if (patient == null) {
            speak("No patient loaded. Say load patient first.")
            return
        }

        val name = patient.optString("name", "Unknown patient")
        val dob = patient.optString("date_of_birth", "")
        val gender = patient.optString("gender", "")

        val speechBuilder = StringBuilder()

        // Start with patient identification
        speechBuilder.append("Patient summary for $name. ")
        if (gender.isNotEmpty()) {
            speechBuilder.append("${gender}. ")
        }
        if (dob.isNotEmpty()) {
            speechBuilder.append("Date of birth: ${formatDateForSpeech(dob)}. ")
        }

        // Critical: Allergies first (safety)
        val allergies = patient.optJSONArray("allergies")
        if (allergies != null && allergies.length() > 0) {
            speechBuilder.append("Alert: Patient has ${allergies.length()} known ${if (allergies.length() == 1) "allergy" else "allergies"}. ")
            for (i in 0 until minOf(allergies.length(), 3)) {
                // Handle both string and JSONObject formats
                val allergyName = try {
                    allergies.getString(i)
                } catch (e: Exception) {
                    try {
                        allergies.getJSONObject(i).optString("name", "")
                    } catch (e2: Exception) { "" }
                }
                if (allergyName.isNotBlank()) {
                    speechBuilder.append("$allergyName. ")
                }
            }
            if (allergies.length() > 3) {
                speechBuilder.append("And ${allergies.length() - 3} more. ")
            }
        } else {
            speechBuilder.append("No known allergies. ")
        }

        // Active Conditions
        val conditions = patient.optJSONArray("conditions")
        if (conditions != null && conditions.length() > 0) {
            speechBuilder.append("Active conditions: ")
            for (i in 0 until minOf(conditions.length(), 3)) {
                // Handle both string array and JSONObject array
                val condName = try {
                    val cond = conditions.getJSONObject(i)
                    cond.optString("name", "")
                } catch (e: Exception) {
                    conditions.optString(i, "")
                }
                if (condName.isNotEmpty()) {
                    speechBuilder.append("$condName. ")
                }
            }
            if (conditions.length() > 3) {
                speechBuilder.append("Plus ${conditions.length() - 3} more. ")
            }
        }

        // Current Medications (brief)
        val meds = patient.optJSONArray("medications")
        if (meds != null && meds.length() > 0) {
            speechBuilder.append("On ${meds.length()} ${if (meds.length() == 1) "medication" else "medications"}. ")
            // Only read top 2 for brevity
            for (i in 0 until minOf(meds.length(), 2)) {
                val medName = try {
                    meds.getString(i)
                } catch (e: Exception) {
                    try {
                        meds.getJSONObject(i).optString("name", "")
                    } catch (e2: Exception) { "" }
                }
                if (medName.isNotBlank()) {
                    speechBuilder.append("$medName. ")
                }
            }
        }

        // Recent Vitals (key ones)
        val vitals = patient.optJSONArray("vitals")
        if (vitals != null && vitals.length() > 0) {
            speechBuilder.append("Recent vitals: ")
            for (i in 0 until minOf(vitals.length(), 3)) {
                val v = vitals.getJSONObject(i)
                val vitalName = v.optString("name", "")
                val vitalValue = v.optString("value", "")
                val vitalUnit = v.optString("unit", "")
                if (vitalName.isNotEmpty() && vitalValue.isNotEmpty()) {
                    speechBuilder.append("${formatVitalNameForSpeech(vitalName)}: $vitalValue $vitalUnit. ")
                }
            }
        }

        speechBuilder.append("End of summary.")

        // Always try to speak (uses server-side TTS fallback if local TTS unavailable)
        speak(speechBuilder.toString())
        Log.d(TAG, "Speaking patient summary for $name")

        // Also show visual summary
        try {
            showQuickPatientSummary()
        } catch (e: Exception) {
            Log.e(TAG, "Error showing visual summary: ${e.message}")
        }
    }

    /**
     * Format date string for natural speech (e.g., "1990-09-15" -> "September 15th, 1990")
     */
    private fun formatDateForSpeech(dateStr: String): String {
        return try {
            val parts = dateStr.split("-")
            if (parts.size == 3) {
                val months = listOf("January", "February", "March", "April", "May", "June",
                    "July", "August", "September", "October", "November", "December")
                val month = months.getOrElse(parts[1].toInt() - 1) { parts[1] }
                val day = parts[2].toInt()
                val daySuffix = when {
                    day in 11..13 -> "th"
                    day % 10 == 1 -> "st"
                    day % 10 == 2 -> "nd"
                    day % 10 == 3 -> "rd"
                    else -> "th"
                }
                "$month $day$daySuffix, ${parts[0]}"
            } else {
                dateStr
            }
        } catch (e: Exception) {
            dateStr
        }
    }

    /**
     * Format vital names for natural speech
     */
    private fun formatVitalNameForSpeech(name: String): String {
        return when {
            name.contains("BP", ignoreCase = true) || name.contains("Blood Pressure", ignoreCase = true) -> "Blood pressure"
            name.contains("HR", ignoreCase = true) || name.contains("Heart Rate", ignoreCase = true) -> "Heart rate"
            name.contains("Temp", ignoreCase = true) -> "Temperature"
            name.contains("SpO2", ignoreCase = true) || name.contains("O2 Sat", ignoreCase = true) -> "Oxygen saturation"
            name.contains("RR", ignoreCase = true) || name.contains("Resp", ignoreCase = true) -> "Respiratory rate"
            name.contains("BMI", ignoreCase = true) -> "B M I"
            else -> name
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // HANDOFF REPORT - SBAR format for shift handoffs
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Generate and display SBAR handoff report for current patient
     * SBAR = Situation, Background, Assessment, Recommendation
     */
    private fun generateHandoffReport() {
        val patient = currentPatientData
        if (patient == null) {
            speakFeedback("No patient loaded. Load a patient first for handoff report.")
            return
        }

        val name = patient.optString("name", "Unknown")
        val dob = patient.optString("date_of_birth", "")
        val gender = patient.optString("gender", "").uppercase()
        val patientId = patient.optString("patient_id", "")

        val content = StringBuilder()
        content.append("═══════════════════════════════════\n")
        content.append("📋 SBAR HANDOFF REPORT\n")
        content.append("═══════════════════════════════════\n\n")

        // Header with patient info
        content.append("👤 $name")
        if (gender.isNotEmpty()) content.append(" ($gender)")
        if (dob.isNotEmpty()) content.append(" DOB: $dob")
        content.append("\n")
        if (patientId.isNotEmpty()) content.append("MRN: $patientId\n")
        content.append("\n")

        // S - SITUATION
        content.append("▸ S - SITUATION\n")
        content.append("───────────────────────────────────\n")
        val conditions = patient.optJSONArray("conditions")
        if (conditions != null && conditions.length() > 0) {
            // Handle both JSONObject and String array formats
            val primaryCondition = try {
                conditions.getJSONObject(0).optString("name", "")
            } catch (e: Exception) {
                conditions.optString(0, "")
            }
            content.append("Primary: $primaryCondition\n")
            if (conditions.length() > 1) {
                content.append("+ ${conditions.length() - 1} other active problems\n")
            }
        } else {
            content.append("No active problems documented\n")
        }

        // Check for critical vitals
        val criticalVitals = patient.optJSONArray("critical_vitals")
        if (criticalVitals != null && criticalVitals.length() > 0) {
            content.append("⚠️ CRITICAL: ")
            for (i in 0 until criticalVitals.length()) {
                val cv = criticalVitals.getJSONObject(i)
                content.append("${cv.optString("name")}: ${cv.optString("value")} ")
            }
            content.append("\n")
        }
        content.append("\n")

        // B - BACKGROUND
        content.append("▸ B - BACKGROUND\n")
        content.append("───────────────────────────────────\n")

        // Allergies (critical for handoff)
        val allergies = patient.optJSONArray("allergies")
        if (allergies != null && allergies.length() > 0) {
            content.append("🚨 Allergies: ")
            for (i in 0 until minOf(allergies.length(), 4)) {
                if (i > 0) content.append(", ")
                content.append(allergies.getString(i))
            }
            if (allergies.length() > 4) content.append(" +${allergies.length() - 4} more")
            content.append("\n")
        } else {
            content.append("Allergies: NKDA\n")
        }

        // Current medications
        val meds = patient.optJSONArray("medications")
        if (meds != null && meds.length() > 0) {
            content.append("💊 Meds: ${meds.length()} active\n")
            for (i in 0 until minOf(meds.length(), 3)) {
                content.append("  • ${meds.getString(i)}\n")
            }
            if (meds.length() > 3) content.append("  + ${meds.length() - 3} more\n")
        }

        // Relevant history
        if (conditions != null && conditions.length() > 1) {
            content.append("Hx: ")
            for (i in 1 until minOf(conditions.length(), 4)) {
                val condName = try {
                    val cond = conditions.getJSONObject(i)
                    cond.optString("name", "")
                } catch (e: Exception) {
                    conditions.optString(i, "")
                }
                if (i > 1) content.append(", ")
                content.append(condName)
            }
            content.append("\n")
        }
        content.append("\n")

        // A - ASSESSMENT
        content.append("▸ A - ASSESSMENT\n")
        content.append("───────────────────────────────────\n")

        // Current vitals
        val vitals = patient.optJSONArray("vitals")
        if (vitals != null && vitals.length() > 0) {
            content.append("Vitals:\n")
            for (i in 0 until minOf(vitals.length(), 6)) {
                val v = vitals.getJSONObject(i)
                val vName = v.optString("name", "")
                val vValue = v.optString("value", "")
                val vUnit = v.optString("unit", "")
                val interp = v.optString("interpretation", "")
                val flag = when (interp) {
                    "HH", "LL" -> "‼️"
                    "H" -> "↑"
                    "L" -> "↓"
                    else -> ""
                }
                content.append("  $vName: $vValue $vUnit $flag\n")
            }
        }

        // Recent/pending labs
        val labs = patient.optJSONArray("labs")
        if (labs != null && labs.length() > 0) {
            content.append("Recent Labs:\n")
            for (i in 0 until minOf(labs.length(), 4)) {
                val lab = labs.getJSONObject(i)
                val labName = lab.optString("name", "")
                val labValue = lab.optString("value", "")
                val labUnit = lab.optString("unit", "")
                content.append("  $labName: $labValue $labUnit\n")
            }
        }
        content.append("\n")

        // R - RECOMMENDATION
        content.append("▸ R - RECOMMENDATION\n")
        content.append("───────────────────────────────────\n")

        // Include pending orders if any
        if (orderQueue.isNotEmpty()) {
            content.append("Pending Orders:\n")
            for (order in orderQueue.take(5)) {
                content.append("  • ${order.displayName}\n")
            }
            if (orderQueue.size > 5) {
                content.append("  + ${orderQueue.size - 5} more\n")
            }
        }

        // Care plans
        val carePlans = patient.optJSONArray("care_plans")
        if (carePlans != null && carePlans.length() > 0) {
            content.append("Active Care Plans:\n")
            for (i in 0 until minOf(carePlans.length(), 2)) {
                val plan = carePlans.getJSONObject(i)
                content.append("  • ${plan.optString("title", "Care Plan")}\n")
            }
        }

        // Include encounter time if timer was running
        val elapsedSeconds = getElapsedSeconds()
        if (elapsedSeconds > 0) {
            val mins = elapsedSeconds / 60
            val secs = elapsedSeconds % 60
            content.append("\n⏱️ Encounter time: ${mins}m ${secs}s\n")
        }

        content.append("\n───────────────────────────────────\n")
        content.append("Report generated: ${java.text.SimpleDateFormat("HH:mm", java.util.Locale.US).format(java.util.Date())}")

        showDataOverlay("SBAR Handoff", content.toString())
        speakFeedback("Handoff report ready for $name")
    }

    /**
     * Speak the SBAR handoff report aloud
     */
    private fun speakHandoffReport() {
        val patient = currentPatientData
        if (patient == null) {
            speak("No patient loaded for handoff.")
            return
        }

        val name = patient.optString("name", "Unknown")
        val speech = StringBuilder()

        // S - Situation
        speech.append("SBAR handoff for $name. ")
        speech.append("Situation: ")
        val conditions = patient.optJSONArray("conditions")
        if (conditions != null && conditions.length() > 0) {
            val primary = try {
                conditions.getJSONObject(0).optString("name", "")
            } catch (e: Exception) {
                conditions.optString(0, "")
            }
            speech.append("Primary problem is $primary. ")
        }

        // Check critical
        val criticalVitals = patient.optJSONArray("critical_vitals")
        if (criticalVitals != null && criticalVitals.length() > 0) {
            speech.append("Alert: Patient has critical vitals. ")
        }

        // B - Background
        speech.append("Background: ")
        val allergies = patient.optJSONArray("allergies")
        if (allergies != null && allergies.length() > 0) {
            speech.append("Allergies include ${allergies.getString(0)}. ")
        } else {
            speech.append("No known drug allergies. ")
        }

        val meds = patient.optJSONArray("medications")
        if (meds != null && meds.length() > 0) {
            speech.append("On ${meds.length()} medications. ")
        }

        // A - Assessment
        speech.append("Assessment: ")
        val vitals = patient.optJSONArray("vitals")
        if (vitals != null && vitals.length() > 0) {
            for (i in 0 until minOf(vitals.length(), 3)) {
                val v = vitals.getJSONObject(i)
                speech.append("${formatVitalNameForSpeech(v.optString("name", ""))}: ${v.optString("value", "")}. ")
            }
        }

        // R - Recommendation
        speech.append("Recommendation: ")
        if (orderQueue.isNotEmpty()) {
            speech.append("${orderQueue.size} pending orders. ")
        }
        speech.append("Continue current plan. ")

        speech.append("End of handoff.")

        // Show visual report too
        generateHandoffReport()

        // Speak
        speak(speech.toString())
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // DISCHARGE SUMMARY - Patient discharge instructions
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Generate and display discharge summary with instructions
     */
    private fun generateDischargeSummary() {
        val patient = currentPatientData
        if (patient == null) {
            speakFeedback("No patient loaded. Load a patient first for discharge summary.")
            return
        }

        val name = patient.optString("name", "Unknown")
        val dob = patient.optString("date_of_birth", "")
        val patientId = patient.optString("patient_id", "")

        val content = StringBuilder()
        content.append("═══════════════════════════════════\n")
        content.append("📄 DISCHARGE SUMMARY\n")
        content.append("═══════════════════════════════════\n\n")

        // Header
        content.append("👤 $name")
        if (dob.isNotEmpty()) content.append(" | DOB: $dob")
        content.append("\n")
        if (patientId.isNotEmpty()) content.append("MRN: $patientId\n")
        content.append("Date: ${java.text.SimpleDateFormat("MM/dd/yyyy", java.util.Locale.US).format(java.util.Date())}\n")
        content.append("\n")

        // DIAGNOSIS
        content.append("▸ DIAGNOSIS\n")
        content.append("───────────────────────────────────\n")
        val conditions = patient.optJSONArray("conditions")
        if (conditions != null && conditions.length() > 0) {
            for (i in 0 until minOf(conditions.length(), 5)) {
                val condName = try {
                    val cond = conditions.getJSONObject(i)
                    cond.optString("name", "")
                } catch (e: Exception) {
                    conditions.optString(i, "")
                }
                content.append("• $condName\n")
            }
        } else {
            content.append("• See provider notes\n")
        }
        content.append("\n")

        // MEDICATIONS
        content.append("▸ MEDICATIONS TO TAKE\n")
        content.append("───────────────────────────────────\n")
        val meds = patient.optJSONArray("medications")
        if (meds != null && meds.length() > 0) {
            for (i in 0 until meds.length()) {
                content.append("💊 ${meds.getString(i)}\n")
            }
        } else {
            content.append("• No medications prescribed\n")
        }

        // Include pending orders as new prescriptions
        val newMeds = orderQueue.filter { it.type == OrderType.MEDICATION }
        if (newMeds.isNotEmpty()) {
            content.append("\n📋 NEW PRESCRIPTIONS:\n")
            for (med in newMeds) {
                content.append("💊 ${med.displayName}\n")
            }
        }
        content.append("\n")

        // ALLERGIES WARNING
        val allergies = patient.optJSONArray("allergies")
        if (allergies != null && allergies.length() > 0) {
            content.append("▸ ⚠️ ALLERGIES\n")
            content.append("───────────────────────────────────\n")
            for (i in 0 until allergies.length()) {
                content.append("🚫 ${allergies.getString(i)}\n")
            }
            content.append("\n")
        }

        // FOLLOW-UP INSTRUCTIONS
        content.append("▸ FOLLOW-UP\n")
        content.append("───────────────────────────────────\n")
        val carePlans = patient.optJSONArray("care_plans")
        if (carePlans != null && carePlans.length() > 0) {
            for (i in 0 until minOf(carePlans.length(), 3)) {
                val plan = carePlans.getJSONObject(i)
                content.append("• ${plan.optString("title", "Follow care plan")}\n")
            }
        }

        // Pending labs/imaging as follow-up
        val pendingLabs = orderQueue.filter { it.type == OrderType.LAB }
        val pendingImaging = orderQueue.filter { it.type == OrderType.IMAGING }
        if (pendingLabs.isNotEmpty()) {
            content.append("• Complete lab work: ${pendingLabs.joinToString(", ") { it.displayName }}\n")
        }
        if (pendingImaging.isNotEmpty()) {
            content.append("• Complete imaging: ${pendingImaging.joinToString(", ") { it.displayName }}\n")
        }

        // Default follow-up
        content.append("• Follow up with your provider as directed\n")
        content.append("• Call if symptoms worsen\n")
        content.append("\n")

        // RETURN PRECAUTIONS
        content.append("▸ WHEN TO SEEK CARE\n")
        content.append("───────────────────────────────────\n")
        content.append("Return to ER or call 911 if:\n")
        content.append("• Difficulty breathing\n")
        content.append("• Chest pain\n")
        content.append("• Severe pain not relieved by medication\n")
        content.append("• High fever (>101.5°F)\n")
        content.append("• Confusion or altered mental status\n")
        content.append("• Signs of infection (redness, swelling, pus)\n")
        content.append("\n")

        // ACTIVITY & DIET
        content.append("▸ ACTIVITY & DIET\n")
        content.append("───────────────────────────────────\n")
        content.append("• Resume normal activities as tolerated\n")
        content.append("• Stay hydrated\n")
        content.append("• Follow dietary restrictions if prescribed\n")
        content.append("\n")

        content.append("───────────────────────────────────\n")
        content.append("Questions? Call your provider's office\n")
        content.append("Generated: ${java.text.SimpleDateFormat("HH:mm", java.util.Locale.US).format(java.util.Date())}")

        showDataOverlay("Discharge Summary", content.toString())
        speakFeedback("Discharge summary ready for $name")
    }

    /**
     * Speak discharge instructions aloud for patient education
     */
    private fun speakDischargeInstructions() {
        val patient = currentPatientData
        if (patient == null) {
            speak("No patient loaded for discharge instructions.")
            return
        }

        val name = patient.optString("name", "Unknown")
        val speech = StringBuilder()

        speech.append("Discharge instructions for $name. ")

        // Diagnosis
        val conditions = patient.optJSONArray("conditions")
        if (conditions != null && conditions.length() > 0) {
            val primary = try {
                conditions.getJSONObject(0).optString("name", "")
            } catch (e: Exception) {
                conditions.optString(0, "")
            }
            speech.append("You were seen for $primary. ")
        }

        // Medications
        val meds = patient.optJSONArray("medications")
        if (meds != null && meds.length() > 0) {
            speech.append("Continue taking your ${meds.length()} medications as prescribed. ")
        }

        // New prescriptions
        val newMedsSpeech = orderQueue.filter { it.type == OrderType.MEDICATION }
        if (newMedsSpeech.isNotEmpty()) {
            speech.append("You have ${newMedsSpeech.size} new prescriptions. ")
        }

        // Allergies reminder
        val allergies = patient.optJSONArray("allergies")
        if (allergies != null && allergies.length() > 0) {
            speech.append("Remember, you are allergic to ${allergies.getString(0)}. ")
        }

        // Follow-up
        val pendingLabsSpeech = orderQueue.filter { it.type == OrderType.LAB }
        if (pendingLabsSpeech.isNotEmpty()) {
            speech.append("You need to complete lab work. ")
        }

        speech.append("Follow up with your provider as directed. ")
        speech.append("Return to the emergency room if you have difficulty breathing, chest pain, or your symptoms get worse. ")
        speech.append("End of discharge instructions.")

        // Show visual too
        generateDischargeSummary()

        // Speak
        speak(speech.toString())
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // PROCEDURE CHECKLISTS - Safety workflows for common procedures
    // ═══════════════════════════════════════════════════════════════════════════

    private data class ProcedureChecklist(
        val name: String,
        val category: String,
        val items: List<String>,
        val timeoutItems: List<String> = emptyList(),
        val signOutItems: List<String> = emptyList()
    )

    private val procedureChecklists = mapOf(
        "timeout" to ProcedureChecklist(
            name = "Universal Protocol Timeout",
            category = "surgical",
            items = listOf(
                "Correct patient identity confirmed",
                "Correct procedure confirmed",
                "Correct site marked and visible",
                "Patient consent signed",
                "Relevant images displayed",
                "Allergies reviewed",
                "Antibiotics given (if applicable)",
                "VTE prophylaxis addressed",
                "All team members introduced"
            )
        ),
        "central line" to ProcedureChecklist(
            name = "Central Line Insertion",
            category = "procedure",
            items = listOf(
                "Hand hygiene performed",
                "Sterile gown and gloves",
                "Full barrier precautions",
                "Chlorhexidine skin prep",
                "Sterile drape placement",
                "Ultrasound guidance available",
                "Lidocaine for local anesthesia",
                "Confirm catheter type and size",
                "Flush all lumens"
            ),
            signOutItems = listOf(
                "Placement confirmed by aspiration",
                "Catheter secured",
                "Sterile dressing applied",
                "Chest X-ray ordered (if applicable)",
                "Document insertion site and attempts"
            )
        ),
        "intubation" to ProcedureChecklist(
            name = "Intubation Checklist",
            category = "airway",
            items = listOf(
                "Equipment check: laryngoscope, ETT, stylet",
                "Suction available and working",
                "Bag-valve-mask ready",
                "Capnography available",
                "IV access confirmed",
                "Medications drawn: sedation, paralytic",
                "Backup airway available (LMA, cric kit)",
                "Patient positioned (sniffing position)",
                "Pre-oxygenation complete"
            ),
            signOutItems = listOf(
                "ETT placement confirmed by capnography",
                "Bilateral breath sounds confirmed",
                "ETT secured at appropriate depth",
                "Ventilator settings ordered",
                "Chest X-ray ordered",
                "Sedation drip started"
            )
        ),
        "lumbar puncture" to ProcedureChecklist(
            name = "Lumbar Puncture",
            category = "procedure",
            items = listOf(
                "Consent obtained",
                "Coagulation status checked",
                "Platelet count adequate (>50k)",
                "No anticoagulants or held appropriately",
                "Sterile field prepared",
                "Local anesthesia ready",
                "Spinal needle and manometer available",
                "Collection tubes labeled",
                "Patient positioned (lateral or sitting)"
            ),
            signOutItems = listOf(
                "Opening pressure documented",
                "Appropriate tubes collected",
                "Closing pressure documented",
                "Site dressed",
                "Patient instructed to lie flat"
            )
        ),
        "blood transfusion" to ProcedureChecklist(
            name = "Blood Transfusion Safety",
            category = "transfusion",
            items = listOf(
                "Consent for transfusion obtained",
                "Type and screen on file",
                "Two-nurse verification at bedside",
                "Patient ID band matches blood product",
                "Blood product type matches order",
                "Expiration date checked",
                "IV access adequate (18g or larger)",
                "Baseline vital signs documented",
                "Emergency medications available"
            ),
            signOutItems = listOf(
                "Transfusion start time documented",
                "Vital signs at 15 minutes",
                "Monitor for transfusion reaction",
                "Vital signs at completion",
                "Total volume and duration documented"
            )
        ),
        "sedation" to ProcedureChecklist(
            name = "Procedural Sedation",
            category = "sedation",
            items = listOf(
                "NPO status confirmed",
                "Airway assessment completed",
                "ASA classification documented",
                "Consent obtained",
                "IV access confirmed",
                "Monitoring equipment ready",
                "Oxygen and suction available",
                "Reversal agents available",
                "Crash cart nearby",
                "Recovery plan in place"
            )
        )
    )

    private val activeChecklistItems = mutableMapOf<String, MutableSet<Int>>()
    private var currentChecklist: String? = null

    /**
     * Show available procedure checklists
     */
    private fun showProcedureChecklists() {
        val content = StringBuilder()
        content.append("═══════════════════════════════════\n")
        content.append("📋 PROCEDURE CHECKLISTS\n")
        content.append("═══════════════════════════════════\n\n")
        content.append("Say \"start [checklist] checklist\" to begin:\n\n")

        procedureChecklists.forEach { (key, checklist) ->
            val emoji = when (checklist.category) {
                "surgical" -> "🔪"
                "airway" -> "🫁"
                "transfusion" -> "🩸"
                "sedation" -> "💉"
                else -> "📋"
            }
            content.append("$emoji $key - ${checklist.name}\n")
        }

        content.append("\n───────────────────────────────────\n")
        content.append("Examples:\n")
        content.append("• \"Start timeout checklist\"\n")
        content.append("• \"Start central line checklist\"\n")
        content.append("• \"Start intubation checklist\"")

        showDataOverlay("Procedure Checklists", content.toString())
        speakFeedback("${procedureChecklists.size} procedure checklists available")
    }

    /**
     * Start a specific procedure checklist
     */
    private fun startProcedureChecklist(checklistName: String) {
        val key = checklistName.lowercase().trim()
        val checklist = procedureChecklists[key]
            ?: procedureChecklists.entries.find { it.value.name.lowercase().contains(key) }?.value

        if (checklist == null) {
            speakFeedback("Checklist not found. Say 'show checklists' to see available options.")
            return
        }

        currentChecklist = procedureChecklists.entries.find { it.value == checklist }?.key
        activeChecklistItems[currentChecklist!!] = mutableSetOf()

        displayChecklist(checklist)
        speakFeedback("${checklist.name} checklist started. ${checklist.items.size} items to verify.")
    }

    /**
     * Display current checklist state
     */
    private fun displayChecklist(checklist: ProcedureChecklist) {
        val content = StringBuilder()
        val key = currentChecklist ?: return
        val checked = activeChecklistItems[key] ?: mutableSetOf()

        content.append("═══════════════════════════════════\n")
        content.append("📋 ${checklist.name.uppercase()}\n")
        content.append("═══════════════════════════════════\n\n")

        content.append("▸ PRE-PROCEDURE\n")
        content.append("───────────────────────────────────\n")
        checklist.items.forEachIndexed { index, item ->
            val checkMark = if (checked.contains(index)) "✅" else "⬜"
            content.append("$checkMark ${index + 1}. $item\n")
        }

        if (checklist.signOutItems.isNotEmpty()) {
            content.append("\n▸ POST-PROCEDURE\n")
            content.append("───────────────────────────────────\n")
            val offset = checklist.items.size
            checklist.signOutItems.forEachIndexed { index, item ->
                val checkMark = if (checked.contains(offset + index)) "✅" else "⬜"
                content.append("$checkMark ${offset + index + 1}. $item\n")
            }
        }

        val totalItems = checklist.items.size + checklist.signOutItems.size
        val completedCount = checked.size
        val progress = (completedCount * 100) / totalItems

        content.append("\n───────────────────────────────────\n")
        content.append("Progress: $completedCount/$totalItems ($progress%)\n")
        content.append("Say \"check [number]\" or \"check all\"")

        showDataOverlay("Checklist", content.toString())
    }

    /**
     * Check off an item in the current checklist
     */
    private fun checkChecklistItem(itemNumber: Int) {
        val key = currentChecklist
        if (key == null) {
            speakFeedback("No active checklist. Say 'start timeout checklist' to begin.")
            return
        }

        val checklist = procedureChecklists[key] ?: return
        val totalItems = checklist.items.size + checklist.signOutItems.size
        val index = itemNumber - 1

        if (index < 0 || index >= totalItems) {
            speakFeedback("Invalid item number. Valid range is 1 to $totalItems.")
            return
        }

        val checked = activeChecklistItems.getOrPut(key) { mutableSetOf() }

        if (checked.contains(index)) {
            checked.remove(index)
            speakFeedback("Item $itemNumber unchecked")
        } else {
            checked.add(index)
            val remaining = totalItems - checked.size
            if (remaining == 0) {
                speakFeedback("All items complete! Checklist verified.")
            } else {
                speakFeedback("Item $itemNumber checked. $remaining remaining.")
            }
        }

        displayChecklist(checklist)
    }

    /**
     * Check all items in current checklist
     */
    private fun checkAllChecklistItems() {
        val key = currentChecklist
        if (key == null) {
            speakFeedback("No active checklist.")
            return
        }

        val checklist = procedureChecklists[key] ?: return
        val totalItems = checklist.items.size + checklist.signOutItems.size
        val checked = activeChecklistItems.getOrPut(key) { mutableSetOf() }

        for (i in 0 until totalItems) {
            checked.add(i)
        }

        displayChecklist(checklist)
        speakFeedback("All ${totalItems} items checked. Checklist complete.")
    }

    /**
     * Read the current checklist aloud
     */
    private fun readChecklist() {
        val key = currentChecklist
        if (key == null) {
            speakFeedback("No active checklist.")
            return
        }

        val checklist = procedureChecklists[key] ?: return
        val checked = activeChecklistItems[key] ?: mutableSetOf()
        val speech = StringBuilder()

        speech.append("${checklist.name}. ")
        checklist.items.forEachIndexed { index, item ->
            val status = if (checked.contains(index)) "checked" else "not checked"
            speech.append("Item ${index + 1}: $item. $status. ")
        }

        val remaining = checklist.items.size - checked.count { it < checklist.items.size }
        speech.append("$remaining items remaining in pre-procedure.")

        speak(speech.toString())
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // CLINICAL REMINDERS - Preventive care prompts based on patient data
    // ═══════════════════════════════════════════════════════════════════════════

    private data class ClinicalReminder(
        val category: String,
        val reminder: String,
        val priority: String, // high, medium, low
        val source: String
    )

    /**
     * Generate clinical reminders based on patient data
     */
    private fun generateClinicalReminders() {
        val patient = currentPatientData
        if (patient == null) {
            speakFeedback("No patient loaded. Load a patient first.")
            return
        }

        val name = patient.optString("name", "Unknown")
        val dob = patient.optString("date_of_birth", "")
        val gender = patient.optString("gender", "").lowercase()
        val conditions = patient.optJSONArray("conditions")
        val meds = patient.optJSONArray("medications")
        val immunizations = patient.optJSONArray("immunizations")
        val labs = patient.optJSONArray("labs")

        val reminders = mutableListOf<ClinicalReminder>()

        // Calculate age
        val age = calculateAgeFromDob(dob)

        // Age-based screening reminders
        if (age >= 50) {
            reminders.add(ClinicalReminder("screening", "Colonoscopy due if not done in 10 years", "medium", "USPSTF"))
        }
        if (age >= 45) {
            reminders.add(ClinicalReminder("screening", "Diabetes screening (A1c or FPG) if not done", "medium", "ADA"))
        }
        if (age >= 40) {
            reminders.add(ClinicalReminder("screening", "Lipid panel due if not done in 5 years", "low", "ACC/AHA"))
        }
        if (gender == "female" && age >= 40) {
            reminders.add(ClinicalReminder("screening", "Mammogram due if not done in 1-2 years", "medium", "USPSTF"))
        }
        if (gender == "female" && age in 21..65) {
            reminders.add(ClinicalReminder("screening", "Pap smear due if not done in 3 years", "medium", "USPSTF"))
        }
        if (age >= 65) {
            reminders.add(ClinicalReminder("screening", "DEXA scan for osteoporosis screening", "low", "USPSTF"))
            reminders.add(ClinicalReminder("vaccine", "Pneumococcal vaccine (PCV20 or PPSV23)", "medium", "CDC"))
            reminders.add(ClinicalReminder("vaccine", "Shingrix (2-dose series) if not received", "medium", "CDC"))
        }

        // Condition-based reminders
        if (conditions != null) {
            for (i in 0 until conditions.length()) {
                val condition = try {
                    conditions.getJSONObject(i).optString("name", "").lowercase()
                } catch (e: Exception) {
                    conditions.optString(i, "").lowercase()
                }

                if (condition.contains("diabetes") || condition.contains("a1c")) {
                    reminders.add(ClinicalReminder("monitoring", "A1c check due if >3 months", "high", "ADA"))
                    reminders.add(ClinicalReminder("monitoring", "Annual eye exam for diabetic retinopathy", "medium", "ADA"))
                    reminders.add(ClinicalReminder("monitoring", "Annual foot exam", "medium", "ADA"))
                    reminders.add(ClinicalReminder("monitoring", "Annual urine microalbumin", "medium", "ADA"))
                }
                if (condition.contains("hypertension") || condition.contains("htn")) {
                    reminders.add(ClinicalReminder("monitoring", "Blood pressure goal <130/80", "high", "ACC/AHA"))
                    reminders.add(ClinicalReminder("monitoring", "Annual BMP for electrolytes/kidney function", "medium", "JNC"))
                }
                if (condition.contains("heart failure") || condition.contains("chf")) {
                    reminders.add(ClinicalReminder("monitoring", "Daily weight monitoring", "high", "ACC/AHA"))
                    reminders.add(ClinicalReminder("monitoring", "BNP/proBNP if symptoms change", "medium", "ACC/AHA"))
                    reminders.add(ClinicalReminder("medication", "Verify on GDMT (BB, ACEi/ARB/ARNI, MRA, SGLT2i)", "high", "ACC/AHA"))
                }
                if (condition.contains("copd")) {
                    reminders.add(ClinicalReminder("vaccine", "Annual influenza vaccine", "high", "CDC"))
                    reminders.add(ClinicalReminder("vaccine", "Pneumococcal vaccine", "high", "CDC"))
                    reminders.add(ClinicalReminder("monitoring", "Pulmonary function test annually", "medium", "GOLD"))
                }
                if (condition.contains("afib") || condition.contains("atrial fibrillation")) {
                    reminders.add(ClinicalReminder("monitoring", "CHADS2-VASc score for anticoagulation", "high", "ACC/AHA"))
                    reminders.add(ClinicalReminder("monitoring", "Rate control goal HR <110", "medium", "ACC/AHA"))
                }
                if (condition.contains("ckd") || condition.contains("kidney")) {
                    reminders.add(ClinicalReminder("monitoring", "GFR and urine albumin every 3-6 months", "high", "KDIGO"))
                    reminders.add(ClinicalReminder("medication", "Review nephrotoxic medications", "high", "KDIGO"))
                }
            }
        }

        // Medication-based reminders
        if (meds != null) {
            for (i in 0 until meds.length()) {
                val med = meds.getString(i).lowercase()

                if (med.contains("warfarin") || med.contains("coumadin")) {
                    reminders.add(ClinicalReminder("monitoring", "INR check due if >4 weeks", "high", "Pharmacy"))
                }
                if (med.contains("metformin")) {
                    reminders.add(ClinicalReminder("monitoring", "Annual B12 level", "low", "ADA"))
                }
                if (med.contains("statin")) {
                    reminders.add(ClinicalReminder("monitoring", "Lipid panel in 4-12 weeks if new", "medium", "ACC/AHA"))
                }
                if (med.contains("lithium")) {
                    reminders.add(ClinicalReminder("monitoring", "Lithium level, TSH, creatinine every 6 months", "high", "APA"))
                }
                if (med.contains("amiodarone")) {
                    reminders.add(ClinicalReminder("monitoring", "TSH, LFTs, PFTs every 6 months", "high", "ACC/AHA"))
                }
            }
        }

        // Universal reminders
        reminders.add(ClinicalReminder("vaccine", "Annual influenza vaccine", "medium", "CDC"))

        // Display reminders
        displayClinicalReminders(name, age, reminders)
    }

    private fun calculateAgeFromDob(dob: String): Int {
        return try {
            val parts = dob.split("-")
            if (parts.size >= 1) {
                val birthYear = parts[0].toInt()
                val currentYear = java.util.Calendar.getInstance().get(java.util.Calendar.YEAR)
                currentYear - birthYear
            } else 0
        } catch (e: Exception) { 0 }
    }

    private fun displayClinicalReminders(patientName: String, age: Int, reminders: List<ClinicalReminder>) {
        val content = StringBuilder()
        content.append("═══════════════════════════════════\n")
        content.append("🔔 CLINICAL REMINDERS\n")
        content.append("═══════════════════════════════════\n\n")
        content.append("👤 $patientName")
        if (age > 0) content.append(" (${age}yo)")
        content.append("\n\n")

        val highPriority = reminders.filter { it.priority == "high" }
        val mediumPriority = reminders.filter { it.priority == "medium" }
        val lowPriority = reminders.filter { it.priority == "low" }

        if (highPriority.isNotEmpty()) {
            content.append("▸ ⚠️ HIGH PRIORITY\n")
            content.append("───────────────────────────────────\n")
            highPriority.forEach { r ->
                val icon = when (r.category) {
                    "vaccine" -> "💉"
                    "screening" -> "🔍"
                    "monitoring" -> "📊"
                    "medication" -> "💊"
                    else -> "•"
                }
                content.append("$icon ${r.reminder}\n")
                content.append("   [${r.source}]\n")
            }
            content.append("\n")
        }

        if (mediumPriority.isNotEmpty()) {
            content.append("▸ 📋 RECOMMENDED\n")
            content.append("───────────────────────────────────\n")
            mediumPriority.forEach { r ->
                val icon = when (r.category) {
                    "vaccine" -> "💉"
                    "screening" -> "🔍"
                    "monitoring" -> "📊"
                    "medication" -> "💊"
                    else -> "•"
                }
                content.append("$icon ${r.reminder}\n")
            }
            content.append("\n")
        }

        if (lowPriority.isNotEmpty()) {
            content.append("▸ 📝 CONSIDER\n")
            content.append("───────────────────────────────────\n")
            lowPriority.forEach { r ->
                content.append("• ${r.reminder}\n")
            }
        }

        content.append("\n───────────────────────────────────\n")
        content.append("${reminders.size} reminders generated")

        showDataOverlay("Clinical Reminders", content.toString())

        val highCount = highPriority.size
        if (highCount > 0) {
            speakFeedback("$highCount high priority reminders for $patientName")
        } else {
            speakFeedback("${reminders.size} clinical reminders generated")
        }
    }

    /**
     * Speak high-priority reminders aloud
     */
    private fun speakClinicalReminders() {
        val patient = currentPatientData
        if (patient == null) {
            speak("No patient loaded.")
            return
        }

        // Regenerate and speak
        generateClinicalReminders()
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // MEDICATION RECONCILIATION - Compare home meds vs current meds
    // ═══════════════════════════════════════════════════════════════════════════

    private var homeMedications = mutableListOf<String>()

    /**
     * Start medication reconciliation process
     */
    private fun startMedReconciliation() {
        val patient = currentPatientData
        if (patient == null) {
            speakFeedback("No patient loaded. Load a patient first.")
            return
        }

        val name = patient.optString("name", "Unknown")
        val currentMeds = patient.optJSONArray("medications")

        val content = StringBuilder()
        content.append("═══════════════════════════════════\n")
        content.append("💊 MEDICATION RECONCILIATION\n")
        content.append("═══════════════════════════════════\n\n")
        content.append("👤 $name\n\n")

        content.append("▸ CURRENT MEDICATIONS (EHR)\n")
        content.append("───────────────────────────────────\n")
        if (currentMeds != null && currentMeds.length() > 0) {
            for (i in 0 until currentMeds.length()) {
                content.append("💊 ${currentMeds.getString(i)}\n")
            }
        } else {
            content.append("• No medications on file\n")
        }
        content.append("\n")

        content.append("▸ HOME MEDICATIONS (Patient Report)\n")
        content.append("───────────────────────────────────\n")
        if (homeMedications.isNotEmpty()) {
            homeMedications.forEachIndexed { index, med ->
                content.append("${index + 1}. $med\n")
            }
        } else {
            content.append("• None recorded yet\n")
            content.append("\nSay \"add home med [medication]\" to add\n")
        }

        content.append("\n───────────────────────────────────\n")
        content.append("Commands:\n")
        content.append("• \"Add home med [name]\" - Add medication\n")
        content.append("• \"Remove home med [#]\" - Remove by number\n")
        content.append("• \"Compare meds\" - Show discrepancies\n")
        content.append("• \"Clear home meds\" - Start over")

        showDataOverlay("Med Reconciliation", content.toString())
        speakFeedback("Medication reconciliation started for $name")
    }

    /**
     * Add a home medication
     */
    private fun addHomeMedication(medication: String) {
        homeMedications.add(medication.trim())
        speakFeedback("Added ${medication.trim()}. ${homeMedications.size} home medications.")
        startMedReconciliation() // Refresh display
    }

    /**
     * Remove a home medication by index
     */
    private fun removeHomeMedication(index: Int) {
        if (index in 1..homeMedications.size) {
            val removed = homeMedications.removeAt(index - 1)
            speakFeedback("Removed $removed")
            startMedReconciliation() // Refresh display
        } else {
            speakFeedback("Invalid medication number")
        }
    }

    /**
     * Compare home meds vs EHR meds and show discrepancies
     */
    private fun compareMedications() {
        val patient = currentPatientData
        if (patient == null) {
            speakFeedback("No patient loaded.")
            return
        }

        val name = patient.optString("name", "Unknown")
        val currentMeds = patient.optJSONArray("medications")
        val ehrMedList = mutableListOf<String>()

        if (currentMeds != null) {
            for (i in 0 until currentMeds.length()) {
                ehrMedList.add(currentMeds.getString(i).lowercase())
            }
        }

        val homeMedLower = homeMedications.map { it.lowercase() }

        // Find discrepancies
        val onlyInEhr = ehrMedList.filter { ehrMed ->
            homeMedLower.none { home -> ehrMed.contains(home) || home.contains(ehrMed) }
        }
        val onlyAtHome = homeMedications.filter { homeMed ->
            ehrMedList.none { ehr -> ehr.contains(homeMed.lowercase()) || homeMed.lowercase().contains(ehr) }
        }
        val matched = homeMedications.filter { homeMed ->
            ehrMedList.any { ehr -> ehr.contains(homeMed.lowercase()) || homeMed.lowercase().contains(ehr) }
        }

        val content = StringBuilder()
        content.append("═══════════════════════════════════\n")
        content.append("⚖️ MED RECONCILIATION RESULTS\n")
        content.append("═══════════════════════════════════\n\n")
        content.append("👤 $name\n\n")

        if (matched.isNotEmpty()) {
            content.append("▸ ✅ CONFIRMED (Match)\n")
            content.append("───────────────────────────────────\n")
            matched.forEach { content.append("• $it\n") }
            content.append("\n")
        }

        if (onlyInEhr.isNotEmpty()) {
            content.append("▸ ⚠️ IN EHR ONLY (Verify with patient)\n")
            content.append("───────────────────────────────────\n")
            onlyInEhr.forEach { content.append("• $it\n") }
            content.append("\n")
        }

        if (onlyAtHome.isNotEmpty()) {
            content.append("▸ 🆕 HOME ONLY (Add to EHR?)\n")
            content.append("───────────────────────────────────\n")
            onlyAtHome.forEach { content.append("• $it\n") }
            content.append("\n")
        }

        val discrepancies = onlyInEhr.size + onlyAtHome.size
        content.append("───────────────────────────────────\n")
        if (discrepancies == 0) {
            content.append("✅ No discrepancies found!")
        } else {
            content.append("⚠️ $discrepancies discrepancies to reconcile")
        }

        showDataOverlay("Med Comparison", content.toString())

        if (discrepancies > 0) {
            speakFeedback("$discrepancies medication discrepancies found")
        } else {
            speakFeedback("Medications reconciled. No discrepancies.")
        }
    }

    /**
     * Clear home medications list
     */
    private fun clearHomeMedications() {
        homeMedications.clear()
        speakFeedback("Home medications cleared")
        startMedReconciliation()
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // REFERRAL TRACKING - Track specialist referrals
    // ═══════════════════════════════════════════════════════════════════════════

    private data class Referral(
        val specialty: String,
        val reason: String,
        val urgency: String, // routine, urgent, stat
        val status: String, // pending, scheduled, completed
        val date: String,
        val notes: String = ""
    )

    private val patientReferrals = mutableListOf<Referral>()

    private val commonSpecialties = listOf(
        "cardiology", "pulmonology", "gastroenterology", "neurology",
        "orthopedics", "dermatology", "endocrinology", "nephrology",
        "rheumatology", "oncology", "urology", "psychiatry",
        "ophthalmology", "ENT", "physical therapy", "pain management"
    )

    /**
     * Show referral tracking panel
     */
    private fun showReferrals() {
        val patient = currentPatientData
        val name = patient?.optString("name", "Unknown") ?: "Unknown"

        val content = StringBuilder()
        content.append("═══════════════════════════════════\n")
        content.append("📤 REFERRAL TRACKING\n")
        content.append("═══════════════════════════════════\n\n")
        content.append("👤 $name\n\n")

        if (patientReferrals.isEmpty()) {
            content.append("No active referrals.\n\n")
            content.append("Say \"refer to [specialty] for [reason]\"\n")
            content.append("Example: \"Refer to cardiology for chest pain\"\n")
        } else {
            val pending = patientReferrals.filter { it.status == "pending" }
            val scheduled = patientReferrals.filter { it.status == "scheduled" }
            val completed = patientReferrals.filter { it.status == "completed" }

            if (pending.isNotEmpty()) {
                content.append("▸ ⏳ PENDING (${pending.size})\n")
                content.append("───────────────────────────────────\n")
                pending.forEachIndexed { i, ref ->
                    val urgencyIcon = when (ref.urgency) {
                        "stat" -> "🔴"
                        "urgent" -> "🟡"
                        else -> "🟢"
                    }
                    content.append("${i + 1}. $urgencyIcon ${ref.specialty.uppercase()}\n")
                    content.append("   Reason: ${ref.reason}\n")
                    content.append("   Created: ${ref.date}\n")
                }
                content.append("\n")
            }

            if (scheduled.isNotEmpty()) {
                content.append("▸ 📅 SCHEDULED (${scheduled.size})\n")
                content.append("───────────────────────────────────\n")
                scheduled.forEach { ref ->
                    content.append("• ${ref.specialty}: ${ref.reason}\n")
                }
                content.append("\n")
            }

            if (completed.isNotEmpty()) {
                content.append("▸ ✅ COMPLETED (${completed.size})\n")
                content.append("───────────────────────────────────\n")
                completed.forEach { ref ->
                    content.append("• ${ref.specialty}: ${ref.reason}\n")
                }
            }
        }

        content.append("\n───────────────────────────────────\n")
        content.append("Commands:\n")
        content.append("• \"Refer to [specialty] for [reason]\"\n")
        content.append("• \"Urgent referral to [specialty]\"\n")
        content.append("• \"Mark referral [#] scheduled\"\n")
        content.append("• \"Mark referral [#] complete\"")

        showDataOverlay("Referrals", content.toString())

        val pendingCount = patientReferrals.count { it.status == "pending" }
        if (pendingCount > 0) {
            speakFeedback("$pendingCount pending referrals")
        }
    }

    /**
     * Create a new referral
     */
    private fun createReferral(specialty: String, reason: String, urgency: String = "routine") {
        val matchedSpecialty = commonSpecialties.find { it.contains(specialty.lowercase()) }
            ?: specialty.lowercase().replaceFirstChar { it.uppercase() }

        val today = java.text.SimpleDateFormat("MM/dd/yyyy", java.util.Locale.US).format(java.util.Date())

        val referral = Referral(
            specialty = matchedSpecialty,
            reason = reason,
            urgency = urgency,
            status = "pending",
            date = today
        )

        patientReferrals.add(referral)

        val urgencyText = if (urgency != "routine") " ($urgency)" else ""
        speakFeedback("Referral to $matchedSpecialty created$urgencyText")
        showReferrals()
    }

    /**
     * Update referral status
     */
    private fun updateReferralStatus(index: Int, newStatus: String) {
        if (index in 1..patientReferrals.size) {
            val referral = patientReferrals[index - 1]
            patientReferrals[index - 1] = referral.copy(status = newStatus)
            speakFeedback("Referral to ${referral.specialty} marked as $newStatus")
            showReferrals()
        } else {
            speakFeedback("Invalid referral number")
        }
    }

    /**
     * Clear all referrals
     */
    private fun clearReferrals() {
        patientReferrals.clear()
        speakFeedback("All referrals cleared")
        showReferrals()
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // NOTE VERSIONING - Track changes to notes with version history
    // ═══════════════════════════════════════════════════════════════════════════

    private data class NoteVersion(
        val version: Int,
        val content: String,
        val timestamp: Long,
        val changeType: String, // "created", "edited", "section_update", "signed"
        val changeDescription: String
    )

    private val noteVersionHistory = mutableListOf<NoteVersion>()
    private var currentNoteVersion = 0

    /**
     * Save a new version of the note
     */
    private fun saveNoteVersion(content: String, changeType: String, description: String) {
        currentNoteVersion++
        val version = NoteVersion(
            version = currentNoteVersion,
            content = content,
            timestamp = System.currentTimeMillis(),
            changeType = changeType,
            changeDescription = description
        )
        noteVersionHistory.add(version)

        // Keep only last 20 versions to manage memory
        if (noteVersionHistory.size > 20) {
            noteVersionHistory.removeAt(0)
        }
    }

    /**
     * Get the current note version number
     */
    private fun getCurrentNoteVersion(): Int = currentNoteVersion

    /**
     * Show note version history
     */
    private fun showNoteVersionHistory() {
        if (noteVersionHistory.isEmpty()) {
            speakFeedback("No version history available")
            return
        }

        val content = StringBuilder()
        content.append("═══════════════════════════════════\n")
        content.append("📜 NOTE VERSION HISTORY\n")
        content.append("═══════════════════════════════════\n\n")
        content.append("Total versions: ${noteVersionHistory.size}\n")
        content.append("Current version: v$currentNoteVersion\n\n")

        noteVersionHistory.reversed().take(10).forEachIndexed { index, version ->
            val timeAgo = getTimeAgo(version.timestamp)
            val icon = when (version.changeType) {
                "created" -> "🆕"
                "edited" -> "✏️"
                "section_update" -> "📝"
                "signed" -> "✅"
                "restored" -> "🔄"
                else -> "📋"
            }
            content.append("$icon v${version.version} - $timeAgo\n")
            content.append("   ${version.changeDescription}\n")
            if (index < noteVersionHistory.size - 1) content.append("\n")
        }

        content.append("\n───────────────────────────────────\n")
        content.append("Commands:\n")
        content.append("• \"Restore version [#]\" - Restore to version\n")
        content.append("• \"Compare versions\" - Show diff\n")
        content.append("• \"Clear history\" - Clear version history")

        showDataOverlay("Version History", content.toString())
        speakFeedback("${noteVersionHistory.size} versions in history")
    }

    /**
     * Restore a previous version of the note
     */
    private fun restoreNoteVersion(versionNumber: Int) {
        val version = noteVersionHistory.find { it.version == versionNumber }
        if (version == null) {
            speakFeedback("Version $versionNumber not found")
            return
        }

        // Save current state before restoring
        val currentContent = lastGeneratedNote?.toString() ?: ""
        saveNoteVersion(currentContent, "restored", "Before restoring to v$versionNumber")

        // Restore the old version
        try {
            lastGeneratedNote = org.json.JSONObject().apply {
                put("content", version.content)
                put("restored_from", versionNumber)
                put("restored_at", System.currentTimeMillis())
            }

            // Save the restoration as a new version
            saveNoteVersion(version.content, "restored", "Restored from v$versionNumber")

            speakFeedback("Restored to version $versionNumber")
            showNoteWithSaveOption("Restored Note (v$versionNumber)", version.content)
        } catch (e: Exception) {
            speakFeedback("Error restoring version")
        }
    }

    /**
     * Compare two versions of the note
     */
    private fun compareNoteVersions() {
        if (noteVersionHistory.size < 2) {
            speakFeedback("Need at least 2 versions to compare")
            return
        }

        val current = noteVersionHistory.last()
        val previous = noteVersionHistory[noteVersionHistory.size - 2]

        val currentLines = current.content.lines()
        val previousLines = previous.content.lines()

        val content = StringBuilder()
        content.append("═══════════════════════════════════\n")
        content.append("⚖️ VERSION COMPARISON\n")
        content.append("═══════════════════════════════════\n\n")
        content.append("Comparing v${previous.version} → v${current.version}\n\n")

        // Simple diff - show added and removed lines
        val added = currentLines.filter { it !in previousLines }
        val removed = previousLines.filter { it !in currentLines }

        if (added.isEmpty() && removed.isEmpty()) {
            content.append("No differences found.\n")
        } else {
            if (removed.isNotEmpty()) {
                content.append("▸ REMOVED (${removed.size} lines)\n")
                content.append("───────────────────────────────────\n")
                removed.take(5).forEach { line ->
                    content.append("- ${line.take(50)}...\n")
                }
                if (removed.size > 5) content.append("  ...and ${removed.size - 5} more\n")
                content.append("\n")
            }

            if (added.isNotEmpty()) {
                content.append("▸ ADDED (${added.size} lines)\n")
                content.append("───────────────────────────────────\n")
                added.take(5).forEach { line ->
                    content.append("+ ${line.take(50)}...\n")
                }
                if (added.size > 5) content.append("  ...and ${added.size - 5} more\n")
            }
        }

        content.append("\n───────────────────────────────────\n")
        content.append("v${previous.version}: ${previous.changeDescription}\n")
        content.append("v${current.version}: ${current.changeDescription}")

        showDataOverlay("Version Diff", content.toString())
    }

    /**
     * Clear version history
     */
    private fun clearNoteVersionHistory() {
        noteVersionHistory.clear()
        currentNoteVersion = 0
        speakFeedback("Version history cleared")
    }

    /**
     * Initialize version tracking for a new note
     */
    private fun initNoteVersioning(noteContent: String) {
        noteVersionHistory.clear()
        currentNoteVersion = 0
        saveNoteVersion(noteContent, "created", "Initial note created")
    }

    /**
     * Track section edits
     */
    private fun trackNoteEdit(section: String, action: String) {
        val content = lastGeneratedNote?.optString("content", "") ?: ""
        saveNoteVersion(content, "section_update", "$action in $section section")
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // DATA ENCRYPTION AT REST - Secure local storage of PHI
    // ═══════════════════════════════════════════════════════════════════════════

    private var encryptedPrefs: android.content.SharedPreferences? = null
    private var isEncryptionEnabled = false

    /**
     * Initialize encrypted storage using Android Keystore
     */
    private fun initializeEncryptedStorage() {
        try {
            // Use AndroidX Security library for EncryptedSharedPreferences
            val masterKey = androidx.security.crypto.MasterKey.Builder(this)
                .setKeyScheme(androidx.security.crypto.MasterKey.KeyScheme.AES256_GCM)
                .build()

            encryptedPrefs = androidx.security.crypto.EncryptedSharedPreferences.create(
                this,
                "mdx_vision_encrypted_prefs",
                masterKey,
                androidx.security.crypto.EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
                androidx.security.crypto.EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
            )

            isEncryptionEnabled = true
            android.util.Log.d("MDxVision", "Encrypted storage initialized successfully")
        } catch (e: Exception) {
            android.util.Log.e("MDxVision", "Failed to initialize encrypted storage: ${e.message}")
            // Fall back to regular SharedPreferences
            encryptedPrefs = getSharedPreferences("mdx_vision_prefs", MODE_PRIVATE)
            isEncryptionEnabled = false
        }
    }

    /**
     * Securely store sensitive patient data
     */
    private fun secureStorePatientData(patientId: String, data: String) {
        val prefs = encryptedPrefs ?: return
        prefs.edit().apply {
            putString("patient_$patientId", data)
            putLong("patient_${patientId}_timestamp", System.currentTimeMillis())
            apply()
        }
    }

    /**
     * Securely retrieve patient data
     */
    private fun secureRetrievePatientData(patientId: String): String? {
        val prefs = encryptedPrefs ?: return null
        return prefs.getString("patient_$patientId", null)
    }

    /**
     * Securely store notes
     */
    private fun secureStoreNote(noteId: String, noteContent: String) {
        val prefs = encryptedPrefs ?: return
        prefs.edit().apply {
            putString("note_$noteId", noteContent)
            putLong("note_${noteId}_timestamp", System.currentTimeMillis())
            apply()
        }
    }

    /**
     * Securely retrieve notes
     */
    private fun secureRetrieveNote(noteId: String): String? {
        val prefs = encryptedPrefs ?: return null
        return prefs.getString("note_$noteId", null)
    }

    /**
     * Securely store draft notes (offline mode)
     */
    private fun secureStoreDraft(draftId: String, content: String) {
        val prefs = encryptedPrefs ?: return
        val drafts = prefs.getStringSet("draft_ids", mutableSetOf())?.toMutableSet() ?: mutableSetOf()
        drafts.add(draftId)
        prefs.edit().apply {
            putString("draft_$draftId", content)
            putStringSet("draft_ids", drafts)
            apply()
        }
    }

    /**
     * Get all draft IDs
     */
    private fun getSecureDraftIds(): Set<String> {
        val prefs = encryptedPrefs ?: return emptySet()
        return prefs.getStringSet("draft_ids", emptySet()) ?: emptySet()
    }

    /**
     * Securely store user credentials/tokens
     */
    private fun secureStoreCredential(key: String, value: String) {
        val prefs = encryptedPrefs ?: return
        prefs.edit().putString("credential_$key", value).apply()
    }

    /**
     * Securely retrieve credentials
     */
    private fun secureRetrieveCredential(key: String): String? {
        val prefs = encryptedPrefs ?: return null
        return prefs.getString("credential_$key", null)
    }

    /**
     * Securely wipe all stored data (for logout or device wipe)
     */
    private fun secureWipeAllData() {
        val prefs = encryptedPrefs ?: return
        prefs.edit().clear().apply()
        speakFeedback("All encrypted data securely wiped")
    }

    /**
     * Check encryption status
     */
    private fun showEncryptionStatus() {
        val content = StringBuilder()
        content.append("═══════════════════════════════════\n")
        content.append("🔐 DATA ENCRYPTION STATUS\n")
        content.append("═══════════════════════════════════\n\n")

        if (isEncryptionEnabled) {
            content.append("✅ Encryption: ENABLED\n")
            content.append("🔑 Algorithm: AES-256-GCM\n")
            content.append("🔒 Key Storage: Android Keystore\n")
            content.append("📱 Key Protection: Hardware-backed (if available)\n\n")

            content.append("▸ PROTECTED DATA\n")
            content.append("───────────────────────────────────\n")
            content.append("• Patient demographics\n")
            content.append("• Clinical notes\n")
            content.append("• Draft notes\n")
            content.append("• User credentials\n")
            content.append("• Session tokens\n")
            content.append("• Audit logs\n\n")

            val prefs = encryptedPrefs
            if (prefs != null) {
                val patientCount = prefs.all.keys.count { it.startsWith("patient_") && !it.contains("timestamp") }
                val noteCount = prefs.all.keys.count { it.startsWith("note_") && !it.contains("timestamp") }
                val draftCount = getSecureDraftIds().size

                content.append("▸ STORED ITEMS\n")
                content.append("───────────────────────────────────\n")
                content.append("Cached patients: $patientCount\n")
                content.append("Saved notes: $noteCount\n")
                content.append("Draft notes: $draftCount\n")
            }
        } else {
            content.append("⚠️ Encryption: DISABLED\n")
            content.append("Using standard SharedPreferences\n\n")
            content.append("Reason: Device may not support\n")
            content.append("hardware-backed encryption\n")
        }

        content.append("\n───────────────────────────────────\n")
        content.append("HIPAA Compliant: ${if (isEncryptionEnabled) "YES" else "PARTIAL"}")

        showDataOverlay("Encryption Status", content.toString())
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // SPECIALTY TEMPLATES - Voice command helpers
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Show list of available specialty templates
     */
    private fun showSpecialtyTemplates() {
        val content = StringBuilder()
        content.append("🏥 SPECIALTY TEMPLATES\n")
        content.append("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n")

        // Group templates by category
        val categories = mapOf(
            "Cardiology" to listOf("cardiology_chest_pain", "cardiology_heart_failure", "cardiology_afib"),
            "Orthopedics" to listOf("ortho_joint_pain", "ortho_fracture"),
            "Neurology" to listOf("neuro_headache", "neuro_stroke"),
            "GI" to listOf("gi_abdominal_pain", "gi_gerd"),
            "Pulmonology" to listOf("pulm_copd", "pulm_asthma"),
            "Psychiatry" to listOf("psych_depression", "psych_anxiety"),
            "Emergency" to listOf("ed_trauma", "ed_sepsis")
        )

        categories.forEach { (category, templateKeys) ->
            content.append("▸ $category\n")
            templateKeys.forEach { key ->
                val template = builtInTemplates[key]
                if (template != null) {
                    val shortName = template.name.substringAfter(" - ")
                    content.append("   • $shortName\n")
                }
            }
            content.append("\n")
        }

        content.append("───────────────────────────────────\n")
        content.append("Say: \"Use cardiology chest pain template\"\n")
        content.append("     \"Apply neuro headache template\"")

        showDataOverlay("Specialty Templates", content.toString())
        speakFeedback("14 specialty templates available. Say use followed by template name.")
    }

    /**
     * Extract template key from voice command
     */
    private fun extractSpecialtyTemplateKey(command: String): String? {
        val lower = command.lowercase()

        // Map spoken phrases to template keys
        val mappings = mapOf(
            // Cardiology
            "cardiology chest pain" to "cardiology_chest_pain",
            "chest pain" to "cardiology_chest_pain",
            "cardiology heart failure" to "cardiology_heart_failure",
            "heart failure" to "cardiology_heart_failure",
            "chf" to "cardiology_heart_failure",
            "cardiology afib" to "cardiology_afib",
            "afib" to "cardiology_afib",
            "atrial fibrillation" to "cardiology_afib",
            // Orthopedics
            "ortho joint pain" to "ortho_joint_pain",
            "joint pain" to "ortho_joint_pain",
            "ortho fracture" to "ortho_fracture",
            "fracture" to "ortho_fracture",
            // Neurology
            "neuro headache" to "neuro_headache",
            "headache" to "neuro_headache",
            "migraine" to "neuro_headache",
            "neuro stroke" to "neuro_stroke",
            "stroke" to "neuro_stroke",
            "cva" to "neuro_stroke",
            // GI
            "gi abdominal pain" to "gi_abdominal_pain",
            "abdominal pain" to "gi_abdominal_pain",
            "belly pain" to "gi_abdominal_pain",
            "gi gerd" to "gi_gerd",
            "gerd" to "gi_gerd",
            "acid reflux" to "gi_gerd",
            // Pulmonology
            "pulm copd" to "pulm_copd",
            "copd" to "pulm_copd",
            "pulm asthma" to "pulm_asthma",
            "asthma" to "pulm_asthma",
            // Psychiatry
            "psych depression" to "psych_depression",
            "depression" to "psych_depression",
            "psych anxiety" to "psych_anxiety",
            "anxiety" to "psych_anxiety",
            // Emergency
            "ed trauma" to "ed_trauma",
            "trauma" to "ed_trauma",
            "ed sepsis" to "ed_sepsis",
            "sepsis" to "ed_sepsis"
        )

        // Find matching template
        for ((phrase, key) in mappings) {
            if (lower.contains(phrase)) {
                return key
            }
        }
        return null
    }

    /**
     * Apply a specialty template to the current note
     */
    private fun applySpecialtyTemplate(templateKey: String) {
        val template = builtInTemplates[templateKey]
        if (template == null) {
            speakFeedback("Template not found")
            return
        }

        // Apply template - substitute patient data
        var content = template.content

        currentPatientData?.let { patient ->
            content = content.replace("{{patient_name}}", patient.optString("name", "Patient"))
            content = content.replace("{{age}}", patient.optString("age", ""))
            content = content.replace("{{gender}}", patient.optString("gender", ""))
            content = content.replace("{{mrn}}", patient.optString("mrn", ""))
            content = content.replace("{{dob}}", patient.optString("dob", ""))
            content = content.replace("{{date}}", java.text.SimpleDateFormat("yyyy-MM-dd", java.util.Locale.US).format(java.util.Date()))
        }

        // Store as current note
        val noteJson = org.json.JSONObject()
        noteJson.put("content", content as Any)
        noteJson.put("note_type", template.noteType as Any)
        noteJson.put("template", templateKey as Any)
        noteJson.put("generated_at", System.currentTimeMillis() as Any)
        lastGeneratedNote = noteJson
        currentNoteType = template.noteType

        // Initialize version tracking
        initNoteVersioning(content)

        // Display the template
        val displayContent = StringBuilder()
        displayContent.append("📋 ${template.name}\n")
        displayContent.append("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n")
        displayContent.append(content.toString())

        showDataOverlay("Specialty Template Applied", displayContent.toString())
        speakFeedback("${template.category} template applied. You can edit sections by voice.")
    }

    private fun saveCurrentNote() {
        // Show sign-off confirmation dialog before saving
        showSignOffConfirmation()
    }

    private fun showSignOffConfirmation() {
        val note = lastGeneratedNote
        if (note == null) {
            Toast.makeText(this, "No note to save. Generate a note first.", Toast.LENGTH_SHORT).show()
            return
        }

        val patientName = currentPatientData?.optString("name") ?: "Unknown Patient"
        val noteType = note.optString("note_type", currentNoteType)
        val wasEdited = isNoteEditing
        val editedLabel = if (wasEdited) " (edited)" else ""

        // Build confirmation dialog
        val dialogView = android.widget.LinearLayout(this).apply {
            orientation = android.widget.LinearLayout.VERTICAL
            setPadding(48, 32, 48, 16)
        }

        // Header
        val headerText = TextView(this).apply {
            text = "📋 Sign Off & Save Note"
            textSize = 20f
            setTextColor(0xFF10B981.toInt())
            setPadding(0, 0, 0, 24)
        }
        dialogView.addView(headerText)

        // Patient info
        val patientText = TextView(this).apply {
            text = "Patient: $patientName"
            textSize = 16f
            setTextColor(0xFF1F2937.toInt())
            setPadding(0, 0, 0, 8)
        }
        dialogView.addView(patientText)

        // Note type
        val noteTypeText = TextView(this).apply {
            text = "Note Type: $noteType$editedLabel"
            textSize = 16f
            setTextColor(0xFF1F2937.toInt())
            setPadding(0, 0, 0, 8)
        }
        dialogView.addView(noteTypeText)

        // Clinician
        val clinicianText = TextView(this).apply {
            text = "Signed by: $clinicianName"
            textSize = 16f
            setTextColor(0xFF1F2937.toInt())
            setPadding(0, 0, 0, 16)
        }
        dialogView.addView(clinicianText)

        // Confirmation checkbox
        val confirmCheckbox = android.widget.CheckBox(this).apply {
            text = "I confirm this clinical note is accurate and complete"
            textSize = 14f
            setTextColor(0xFF374151.toInt())
            setPadding(0, 8, 0, 8)
        }
        dialogView.addView(confirmCheckbox)

        // Disclaimer
        val disclaimerText = TextView(this).apply {
            text = "This note will be saved to the patient's medical record."
            textSize = 12f
            setTextColor(0xFF6B7280.toInt())
            setPadding(0, 16, 0, 0)
        }
        dialogView.addView(disclaimerText)

        val dialog = android.app.AlertDialog.Builder(this)
            .setView(dialogView)
            .setPositiveButton("Sign & Save", null)  // Set to null initially to prevent auto-dismiss
            .setNegativeButton("Cancel") { d, _ -> d.dismiss() }
            .create()

        dialog.setOnShowListener {
            val signButton = dialog.getButton(android.app.AlertDialog.BUTTON_POSITIVE)
            signButton.isEnabled = false  // Disable until checkbox is checked

            confirmCheckbox.setOnCheckedChangeListener { _, isChecked ->
                signButton.isEnabled = isChecked
            }

            signButton.setOnClickListener {
                if (confirmCheckbox.isChecked) {
                    dialog.dismiss()
                    performNoteSave()
                } else {
                    Toast.makeText(this, "Please confirm the note is accurate", Toast.LENGTH_SHORT).show()
                }
            }
        }

        dialog.show()
    }

    private fun performNoteSave() {
        val note = lastGeneratedNote
        val transcript = lastNoteTranscript
        val patientId = currentPatientData?.optString("patient_id") ?: TEST_PATIENT_ID
        val patientName = currentPatientData?.optString("name") ?: "Unknown Patient"

        if (note == null) {
            Toast.makeText(this, "No note to save. Generate a note first.", Toast.LENGTH_SHORT).show()
            return
        }

        // Use edited content if available, otherwise use original
        val noteContent = editableNoteContent ?: note.optString("display_text", "")
        val wasEdited = isNoteEditing
        val signedAt = java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", java.util.Locale.US).format(java.util.Date())
        val summary = note.optString("summary", "")

        // Check if offline - save as draft immediately
        if (!isNetworkAvailable()) {
            val draftId = saveDraftNote(
                patientId = patientId,
                patientName = patientName,
                noteType = currentNoteType,
                displayText = noteContent,
                summary = summary,
                transcript = transcript ?: "",
                wasEdited = wasEdited,
                signedBy = clinicianName,
                signedAt = signedAt
            )

            Toast.makeText(this, "Offline - Note saved as draft: $draftId", Toast.LENGTH_LONG).show()
            statusText.text = "Draft saved (offline)"
            transcriptText.text = "Will sync when online"
            speakFeedback("Note saved as offline draft")
            clearAfterSave()
            return
        }

        statusText.text = "Saving note..."
        transcriptText.text = if (wasEdited) "Saving edited note..." else "Uploading to EHR"

        Thread {
            try {
                val json = JSONObject().apply {
                    put("patient_id", patientId)
                    put("note_type", currentNoteType)
                    put("display_text", noteContent)
                    put("summary", summary)
                    put("transcript", transcript ?: "")
                    put("timestamp", note.optString("timestamp", ""))
                    put("was_edited", wasEdited)
                    put("signed_by", clinicianName)
                    put("signed_at", signedAt)
                }

                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/notes/save")
                    .post(json.toString().toRequestBody("application/json".toMediaType()))
                    .build()

                httpClient.newCall(request).enqueue(object : Callback {
                    override fun onFailure(call: Call, e: IOException) {
                        Log.e(TAG, "Save note error: ${e.message}")
                        runOnUiThread {
                            // Save as draft on network failure
                            val draftId = saveDraftNote(
                                patientId = patientId,
                                patientName = patientName,
                                noteType = currentNoteType,
                                displayText = noteContent,
                                summary = summary,
                                transcript = transcript ?: "",
                                wasEdited = wasEdited,
                                signedBy = clinicianName,
                                signedAt = signedAt
                            )
                            Toast.makeText(this@MainActivity, "Save failed - saved as draft: $draftId", Toast.LENGTH_LONG).show()
                            statusText.text = "Saved as draft"
                            transcriptText.text = "Will retry when online"
                            speakFeedback("Save failed. Note saved as draft.")
                            clearAfterSave()
                        }
                    }

                    override fun onResponse(call: Call, response: Response) {
                        val body = response.body?.string()
                        Log.d(TAG, "Save response: $body")

                        runOnUiThread {
                            try {
                                val result = JSONObject(body ?: "{}")
                                val success = result.optBoolean("success", false)
                                val noteId = result.optString("note_id", "")

                                if (success) {
                                    val editMsg = if (wasEdited) " (edited)" else ""
                                    Toast.makeText(this@MainActivity, "Note saved$editMsg! ID: $noteId", Toast.LENGTH_LONG).show()
                                    statusText.text = "Note saved"
                                    transcriptText.text = "ID: $noteId"
                                    lastSavedNoteId = noteId  // Store for push-to-EHR
                                    clearAfterSave()
                                    speakFeedback("Note saved successfully. Say push note to send to EHR.")
                                } else {
                                    val message = result.optString("message", "Save failed")
                                    Toast.makeText(this@MainActivity, message, Toast.LENGTH_SHORT).show()
                                    statusText.text = "MDx Vision"
                                    speakFeedback("Failed to save note")
                                }
                            } catch (e: Exception) {
                                Toast.makeText(this@MainActivity, "Save response error", Toast.LENGTH_SHORT).show()
                            }
                        }
                    }
                })
            } catch (e: Exception) {
                Log.e(TAG, "Failed to save note: ${e.message}")
                runOnUiThread {
                    // Save as draft on exception
                    val draftId = saveDraftNote(
                        patientId = patientId,
                        patientName = patientName,
                        noteType = currentNoteType,
                        displayText = noteContent,
                        summary = summary,
                        transcript = transcript ?: "",
                        wasEdited = wasEdited,
                        signedBy = clinicianName,
                        signedAt = signedAt
                    )
                    Toast.makeText(this@MainActivity, "Error - saved as draft: $draftId", Toast.LENGTH_LONG).show()
                    statusText.text = "Saved as draft"
                    speakFeedback("Error occurred. Note saved as draft.")
                    clearAfterSave()
                }
            }
        }.start()
    }

    private fun clearAfterSave() {
        lastGeneratedNote = null
        lastNoteTranscript = null
        editableNoteContent = null
        noteEditText = null
        isNoteEditing = false
        hideDataOverlay()
    }

    private fun fetchPatientByMrn(mrn: String) {
        statusText.text = "Looking up MRN..."
        transcriptText.text = "Scanning: $mrn"

        Thread {
            try {
                val encodedMrn = java.net.URLEncoder.encode(mrn, "UTF-8")
                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/patient/mrn/$encodedMrn")
                    .get()
                    .build()

                httpClient.newCall(request).enqueue(object : Callback {
                    override fun onFailure(call: Call, e: IOException) {
                        Log.e(TAG, "MRN lookup error: ${e.message}")
                        runOnUiThread {
                            showDataOverlay("Lookup Failed", "Error: ${e.message}")
                        }
                    }

                    override fun onResponse(call: Call, response: Response) {
                        val body = response.body?.string()
                        Log.d(TAG, "MRN lookup response: $body")

                        runOnUiThread {
                            if (response.code == 200) {
                                try {
                                    val patient = JSONObject(body ?: "{}")
                                    currentPatientData = patient

                                    // Cache by patient ID for offline access
                                    val patientId = patient.optString("patient_id", "")
                                    val patientName = patient.optString("name", "Unknown")
                                    if (patientId.isNotEmpty()) {
                                        cachePatientData(patientId, body ?: "{}")
                                        // Add to patient history for quick access
                                        addToPatientHistory(patientId, patientName)
                                    }

                                    showPatientDataOverlay(patient)
                                    notifyHudPatientUpdate()  // Update Vuzix HUD
                                } catch (e: Exception) {
                                    showDataOverlay("Patient Found", body ?: "No response")
                                }
                            } else {
                                showDataOverlay("Not Found", "No patient with MRN: $mrn")
                            }
                        }
                    }
                })
            } catch (e: Exception) {
                Log.e(TAG, "MRN lookup failed: ${e.message}")
                runOnUiThread {
                    showDataOverlay("Error", "MRN lookup failed: ${e.message}")
                }
            }
        }.start()
    }

    // Store current patient data for section views
    private var currentPatientData: JSONObject? = null

    // Store last saved note ID for push-to-EHR feature
    private var lastSavedNoteId: String? = null

    private fun fetchPatientData(patientId: String, forceOnline: Boolean = false) {
        Log.d(TAG, "Fetching patient: $patientId")

        // Check if offline - use cache
        if (!forceOnline && !isNetworkAvailable()) {
            val cached = getCachedPatient(patientId)
            if (cached != null) {
                currentPatientData = cached
                val name = cached.optString("name", "Unknown")
                val displayText = cached.optString("display_text", "No data")
                showDataOverlay("📴 OFFLINE: $name", displayText + "\n\n⚠️ Showing cached data")
                statusText.text = "Offline Mode"
                transcriptText.text = "Using cached data"
                // Speech feedback and safety warnings even when offline
                speakFeedback("Patient $name loaded from cache")
                speakCriticalVitalAlerts(cached)  // Vitals first (most urgent)
                speakAllergyWarnings(cached)
                speakCriticalLabAlerts(cached)
                speakMedicationInteractions(cached)
                speakLabTrends(cached)
                speakVitalTrends(cached)  // Trends last
                return
            } else {
                statusText.text = "Offline - No cache"
                transcriptText.text = "Connect to network"
                Toast.makeText(this, "No cached data for this patient", Toast.LENGTH_SHORT).show()
                return
            }
        }

        statusText.text = "Loading patient..."
        transcriptText.text = "Connecting to EHR"

        // Use quick endpoint for Samsung (returns minimal data instantly)
        val urlStr = "$EHR_PROXY_URL/api/v1/patient/$patientId/quick"

        // Use pure Java networking (Samsung blocks OkHttp large responses)
        Thread {
            try {
                val url = java.net.URL(urlStr)
                val conn = url.openConnection() as java.net.HttpURLConnection
                conn.requestMethod = "GET"
                conn.connectTimeout = 30000
                conn.readTimeout = 60000
                conn.setRequestProperty("Accept", "application/json")
                conn.setRequestProperty("User-Agent", "MDxVision/1.0")

                val responseCode = conn.responseCode
                val body = if (responseCode == 200) {
                    conn.inputStream.bufferedReader().use { it.readText() }
                } else {
                    conn.errorStream?.bufferedReader()?.use { it.readText() }
                }
                conn.disconnect()

                runOnUiThread {
                    if (responseCode == 200 && body != null) {
                        try {
                            val patient = JSONObject(body)
                            currentPatientData = patient
                            cachePatientData(patientId, body)
                            val name = patient.optString("name", "Unknown")
                            addToPatientHistory(patientId, name)
                            showPatientDataOverlay(patient)
                            speakFeedback("Patient $name loaded")
                            speakCriticalVitalAlerts(patient)
                            speakAllergyWarnings(patient)
                            speakCriticalLabAlerts(patient)
                            speakMedicationInteractions(patient)
                            speakLabTrends(patient)
                            speakVitalTrends(patient)
                            notifyHudPatientUpdate()  // Update Vuzix HUD
                            fetchPreVisitPrep(patientId)  // Jarvis: Proactive AI briefing (Feature #92)
                        } catch (e: Exception) {
                            showDataOverlay("Parse Error", body)
                            speakFeedback("Error loading patient")
                        }
                    } else {
                        statusText.text = "HTTP Error: $responseCode"
                        transcriptText.text = body ?: "No response"
                    }
                }
            } catch (e: Exception) {
                runOnUiThread {
                    val cached = getCachedPatient(patientId)
                    if (cached != null) {
                        currentPatientData = cached
                        val name = cached.optString("name", "Unknown")
                        val displayText = cached.optString("display_text", "No data")
                        showDataOverlay("📴 CACHED: $name", displayText + "\n\n⚠️ Network error")
                        speakFeedback("Patient $name loaded from cache")
                        speakCriticalVitalAlerts(cached)
                        speakAllergyWarnings(cached)
                        speakCriticalLabAlerts(cached)
                    } else {
                        statusText.text = "Connection failed"
                        transcriptText.text = "Error: ${e.message}"
                        speakFeedback("Failed to load patient")
                    }
                }
            }
        }.start()
    }

    private fun testNetworkConnection() {
        Thread {
            try {
                runOnUiThread {
                    statusText.text = "Connecting..."
                    transcriptText.text = "Testing network..."
                }

                val url = java.net.URL("$EHR_PROXY_URL/ping")
                val conn = url.openConnection() as java.net.HttpURLConnection
                conn.connectTimeout = 10000
                conn.readTimeout = 10000
                conn.requestMethod = "GET"

                val code = conn.responseCode
                conn.inputStream.bufferedReader().use { it.readText() }
                conn.disconnect()

                runOnUiThread {
                    if (code == 200) {
                        // Network works, load patient
                        fetchPatientData(TEST_PATIENT_ID)
                    } else {
                        statusText.text = "Network error"
                        transcriptText.text = "HTTP $code"
                    }
                }
            } catch (e: Exception) {
                runOnUiThread {
                    statusText.text = "Offline"
                    transcriptText.text = "Cannot reach server"
                }
            }
        }.start()
    }

    private fun isVuzixDevice(): Boolean {
        val manufacturer = android.os.Build.MANUFACTURER.lowercase()
        val model = android.os.Build.MODEL.lowercase()
        return manufacturer.contains("vuzix") || model.contains("blade")
    }

    // ============ Pre-Visit Prep Alert (Feature #92 - Jarvis Wave 1) ============

    /**
     * Fetch proactive AI briefing when loading a patient
     * Returns care gaps, critical values, and suggested actions
     * Speaks the summary via TTS for hands-free operation
     */
    private fun fetchPreVisitPrep(patientId: String) {
        Log.d(TAG, "Fetching pre-visit prep for patient: $patientId")

        Thread {
            try {
                val url = java.net.URL("$EHR_PROXY_URL/api/v1/patient/$patientId/prep")
                val conn = url.openConnection() as java.net.HttpURLConnection
                conn.requestMethod = "GET"
                conn.connectTimeout = 30000
                conn.readTimeout = 60000
                conn.setRequestProperty("Accept", "application/json")

                val responseCode = conn.responseCode
                val body = if (responseCode == 200) {
                    conn.inputStream.bufferedReader().use { it.readText() }
                } else {
                    null
                }
                conn.disconnect()

                if (responseCode == 200 && body != null) {
                    runOnUiThread {
                        try {
                            val prep = JSONObject(body)
                            displayPreVisitPrep(prep)
                        } catch (e: Exception) {
                            Log.e(TAG, "Error parsing pre-visit prep: ${e.message}")
                        }
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error fetching pre-visit prep: ${e.message}")
            }
        }.start()
    }

    /**
     * Display and speak the pre-visit prep alert
     */
    private fun displayPreVisitPrep(prep: JSONObject) {
        val spokenSummary = prep.optString("spoken_summary", "")
        val displaySummary = prep.optString("display_summary", "")
        val alerts = prep.optJSONArray("alerts")
        val quickActions = prep.optJSONArray("quick_actions")

        // Log for debugging
        Log.d(TAG, "Pre-visit prep: $displaySummary")
        Log.d(TAG, "Alerts count: ${alerts?.length() ?: 0}")

        // Check if there are any high-priority alerts
        var hasCritical = false
        if (alerts != null) {
            for (i in 0 until alerts.length()) {
                val alert = alerts.getJSONObject(i)
                if (alert.optString("priority") == "high") {
                    hasCritical = true
                    break
                }
            }
        }

        // Speak the summary via TTS (proactive Jarvis-like behavior)
        // Critical alerts are spoken immediately (bypasses speech feedback toggle)
        if (spokenSummary.isNotEmpty()) {
            if (hasCritical) {
                // Critical alerts always spoken
                textToSpeech?.speak(spokenSummary, TextToSpeech.QUEUE_ADD, null, "prep_alert")
            } else if (isSpeechFeedbackEnabled) {
                // Non-critical only if speech feedback enabled
                textToSpeech?.speak(spokenSummary, TextToSpeech.QUEUE_ADD, null, "prep_alert")
            }
        }

        // Update HUD with prep summary if available
        if (displaySummary.isNotEmpty() && isVuzixDevice()) {
            val intent = Intent(VuzixHudService.ACTION_UPDATE_PATIENT).apply {
                putExtra("prep_summary", displaySummary)
            }
            LocalBroadcastManager.getInstance(this).sendBroadcast(intent)
        }

        // Show quick actions in a toast for now (could be overlay later)
        if (quickActions != null && quickActions.length() > 0) {
            val actions = mutableListOf<String>()
            for (i in 0 until quickActions.length()) {
                actions.add(quickActions.getString(i))
            }
            Log.d(TAG, "Quick actions: ${actions.joinToString(", ")}")
        }
    }

    // ============ Chief Complaint Workflows (Feature #94 - Jarvis Wave 1) ============

    /**
     * Detect chief complaint from patient conditions or ambient text
     * and suggest relevant workups/orders
     */
    private fun fetchChiefComplaintWorkflow(patientId: String, ambientText: String? = null) {
        Log.d(TAG, "Fetching chief complaint workflow for patient: $patientId")

        Thread {
            try {
                var urlStr = "$EHR_PROXY_URL/api/v1/patient/$patientId/workflow"
                if (!ambientText.isNullOrEmpty()) {
                    urlStr += "?ambient_text=${java.net.URLEncoder.encode(ambientText, "UTF-8")}"
                }

                val url = java.net.URL(urlStr)
                val conn = url.openConnection() as java.net.HttpURLConnection
                conn.requestMethod = "GET"
                conn.connectTimeout = 30000
                conn.readTimeout = 60000
                conn.setRequestProperty("Accept", "application/json")

                val responseCode = conn.responseCode
                val body = if (responseCode == 200) {
                    conn.inputStream.bufferedReader().use { it.readText() }
                } else {
                    null
                }
                conn.disconnect()

                if (responseCode == 200 && body != null) {
                    runOnUiThread {
                        try {
                            val workflow = JSONObject(body)
                            displayChiefComplaintWorkflow(workflow)
                        } catch (e: Exception) {
                            Log.e(TAG, "Error parsing workflow: ${e.message}")
                        }
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error fetching workflow: ${e.message}")
            }
        }.start()
    }

    /**
     * Suggest workflow based on ambient text (no patient context required)
     */
    private fun suggestWorkflowFromText(text: String) {
        Log.d(TAG, "Suggesting workflow from text: ${text.take(50)}...")

        Thread {
            try {
                val url = java.net.URL("$EHR_PROXY_URL/api/v1/workflow/suggest")
                val conn = url.openConnection() as java.net.HttpURLConnection
                conn.requestMethod = "POST"
                conn.connectTimeout = 15000
                conn.readTimeout = 30000
                conn.setRequestProperty("Content-Type", "application/json")
                conn.setRequestProperty("Accept", "application/json")
                conn.doOutput = true

                val payload = JSONObject().apply {
                    put("text", text)
                }
                conn.outputStream.bufferedWriter().use { it.write(payload.toString()) }

                val responseCode = conn.responseCode
                val body = if (responseCode == 200) {
                    conn.inputStream.bufferedReader().use { it.readText() }
                } else {
                    null
                }
                conn.disconnect()

                if (responseCode == 200 && body != null) {
                    runOnUiThread {
                        try {
                            val result = JSONObject(body)
                            val spokenSummary = result.optString("spoken_summary", "")
                            if (spokenSummary.isNotEmpty()) {
                                // Speak the suggestion
                                textToSpeech?.speak(spokenSummary, TextToSpeech.QUEUE_ADD, null, "workflow_suggest")
                            }

                            // Show suggestions if any
                            val suggestions = result.optJSONArray("suggestions")
                            if (suggestions != null && suggestions.length() > 0) {
                                displayWorkflowSuggestions(suggestions)
                            }
                        } catch (e: Exception) {
                            Log.e(TAG, "Error parsing workflow suggestion: ${e.message}")
                        }
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error suggesting workflow: ${e.message}")
            }
        }.start()
    }

    /**
     * Display chief complaint workflow suggestions
     */
    private fun displayChiefComplaintWorkflow(workflow: JSONObject) {
        val spokenSummary = workflow.optString("spoken_summary", "")
        val displaySummary = workflow.optString("display_summary", "")
        val suggestions = workflow.optJSONArray("suggestions")
        val detectedComplaints = workflow.optJSONArray("detected_complaints")

        // Log for debugging
        val complaintsStr = detectedComplaints?.let { arr ->
            (0 until arr.length()).map { arr.getString(it) }.joinToString(", ")
        } ?: "none"
        Log.d(TAG, "Chief complaint workflow: detected=$complaintsStr")

        // Speak the summary if there are suggestions
        if (suggestions != null && suggestions.length() > 0 && spokenSummary.isNotEmpty()) {
            textToSpeech?.speak(spokenSummary, TextToSpeech.QUEUE_ADD, null, "workflow_alert")
        }

        // Show overlay with suggestions
        if (displaySummary.isNotEmpty()) {
            showDataOverlay("📋 SUGGESTED WORKUPS", displaySummary)
        }
    }

    /**
     * Display workflow suggestions from array
     */
    private fun displayWorkflowSuggestions(suggestions: JSONArray) {
        val sb = StringBuilder()
        sb.append("📋 SUGGESTED WORKUPS\n")
        sb.append("${"─".repeat(30)}\n\n")

        for (i in 0 until minOf(suggestions.length(), 3)) {
            val s = suggestions.getJSONObject(i)
            val complaint = s.optString("chief_complaint", "")
            val orderSetName = s.optString("order_set_name", "")
            val voiceCommand = s.optString("voice_command", "")
            val orders = s.optJSONArray("suggested_orders")

            sb.append("🔹 ${complaint.replaceFirstChar { it.uppercase() }}\n")
            sb.append("   → $orderSetName\n")
            if (orders != null && orders.length() > 0) {
                val orderList = (0 until minOf(orders.length(), 4)).map { orders.getString(it) }
                sb.append("   Orders: ${orderList.joinToString(", ")}\n")
            }
            sb.append("   Voice: \"$voiceCommand\"\n\n")
        }

        showDataOverlay("SUGGESTED WORKUPS", sb.toString())
    }

    // ============ Indirect Commands (Feature #96 - Jarvis Wave 1) ============

    /**
     * Parse natural language and execute the inferred action.
     * Examples: "check that potassium" -> show labs with potassium filter
     *           "what's his blood pressure" -> show vitals with BP filter
     */
    private fun parseAndExecuteIndirectCommand(text: String) {
        if (text.isBlank()) {
            speakFeedback("Please tell me what you'd like to see.")
            return
        }

        // Send to backend for parsing
        val url = "$EHR_PROXY_URL/api/v1/commands/parse?text=${java.net.URLEncoder.encode(text, "UTF-8")}"
        val request = Request.Builder()
            .url(url)
            .header("X-Device-ID", deviceId)
            .post("".toRequestBody("application/json".toMediaType()))
            .build()

        httpClient.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                runOnUiThread {
                    Log.e(TAG, "Indirect command parse failed", e)
                    speakFeedback("Sorry, couldn't understand that command.")
                }
            }

            override fun onResponse(call: Call, response: Response) {
                response.use { resp ->
                    if (resp.isSuccessful) {
                        val body = resp.body?.string()
                        if (body != null) {
                            val json = JSONObject(body)
                            runOnUiThread { executeIndirectCommand(json) }
                        }
                    } else {
                        runOnUiThread {
                            speakFeedback("Couldn't parse that command.")
                        }
                    }
                }
            }
        })

        Log.d(TAG, "Indirect command sent for parsing: $text")
    }

    /**
     * Execute the parsed indirect command by calling the appropriate action.
     */
    private fun executeIndirectCommand(result: JSONObject) {
        val action = result.optString("action", "unknown")
        val parameters = result.optJSONObject("parameters") ?: JSONObject()
        val spokenConfirmation = result.optString("spoken_confirmation", "")
        val confidence = result.optString("confidence", "low")
        val specificItem = parameters.optString("specific_item", "")

        Log.d(TAG, "Executing indirect command: action=$action, item=$specificItem, confidence=$confidence")

        // Speak the confirmation
        if (spokenConfirmation.isNotBlank()) {
            speakFeedback(spokenConfirmation)
        }

        // Check if patient is loaded for patient-specific actions
        val patientId = currentPatientData?.optString("id") ?: currentPatientData?.optString("patient_id")
        val needsPatient = action in listOf("show_labs", "show_vitals", "show_meds", "show_allergies",
            "show_conditions", "show_procedures", "show_care_plans", "show_notes", "show_immunizations")

        if (needsPatient && (patientId.isNullOrEmpty())) {
            speakFeedback("No patient loaded. Load a patient first.")
            return
        }

        // Execute based on action
        when (action) {
            "show_labs" -> {
                // If there's a specific lab, try to highlight it
                if (specificItem.isNotEmpty()) {
                    fetchLabsWithFilter(patientId!!, specificItem)
                } else {
                    fetchPatientSection("labs")
                }
            }
            "show_vitals" -> {
                if (specificItem.isNotEmpty()) {
                    fetchVitalsWithFilter(patientId!!, specificItem)
                } else {
                    fetchPatientSection("vitals")
                }
            }
            "show_meds" -> {
                fetchPatientSection("medications")
            }
            "show_allergies" -> {
                fetchPatientSection("allergies")
            }
            "show_conditions" -> {
                fetchPatientSection("conditions")
            }
            "show_procedures" -> {
                fetchPatientSection("procedures")
            }
            "show_patient" -> {
                if (currentPatientData != null) {
                    showQuickPatientSummary()
                } else {
                    speakFeedback("No patient loaded.")
                }
            }
            "show_care_plans" -> {
                fetchPatientSection("care_plans")
            }
            "show_notes" -> {
                fetchPatientSection("clinical_notes")
            }
            "show_immunizations" -> {
                fetchPatientSection("immunizations")
            }
            "unknown" -> {
                speakFeedback("I couldn't understand that. Try 'show labs' or 'check vitals'.")
            }
            else -> {
                speakFeedback("Action '$action' is not yet supported.")
            }
        }
    }

    /**
     * Fetch labs and filter/highlight a specific item.
     */
    private fun fetchLabsWithFilter(patientId: String, filterItem: String) {
        val url = "$EHR_PROXY_URL/api/v1/patient/$patientId/labs"
        val request = Request.Builder()
            .url(url)
            .header("X-Device-ID", deviceId)
            .build()

        httpClient.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                runOnUiThread {
                    Log.e(TAG, "Labs fetch failed", e)
                    speakFeedback("Couldn't fetch labs.")
                }
            }

            override fun onResponse(call: Call, response: Response) {
                response.use { resp ->
                    if (resp.isSuccessful) {
                        val body = resp.body?.string()
                        if (body != null) {
                            val data = JSONObject(body)
                            runOnUiThread { displayFilteredLabs(data, filterItem) }
                        }
                    } else {
                        runOnUiThread {
                            speakFeedback("Error fetching labs.")
                        }
                    }
                }
            }
        })
    }

    /**
     * Display labs with a specific item highlighted.
     */
    private fun displayFilteredLabs(data: JSONObject, filterItem: String) {
        val labs = data.optJSONArray("labs") ?: JSONArray()
        val filterLower = filterItem.lowercase()

        val sb = StringBuilder()
        sb.append("🔬 LABS")
        if (filterItem.isNotEmpty()) {
            sb.append(" - Filtered: ${filterItem.replaceFirstChar { it.uppercase() }}")
        }
        sb.append("\n${"─".repeat(30)}\n\n")

        var foundMatch = false
        var matchedValue = ""
        var matchedDate = ""

        // First pass: find and highlight matching items
        for (i in 0 until labs.length()) {
            val lab = labs.getJSONObject(i)
            val name = lab.optString("name", lab.optString("display", "Unknown"))
            val value = lab.optString("value", "")
            val unit = lab.optString("unit", "")
            val date = lab.optString("date", "")

            val nameLower = name.lowercase()
            val isMatch = filterLower in nameLower ||
                    INDIRECT_LAB_ALIASES.any { (alias, canonical) ->
                        alias == filterLower && canonical.lowercase() in nameLower
                    }

            if (isMatch) {
                foundMatch = true
                matchedValue = "$value $unit".trim()
                matchedDate = date.take(10)
                sb.append("⭐ $name: $value $unit\n")
                sb.append("   Date: $date\n\n")

                // Speak the result
                val spokenResult = "$name is $value $unit, from $matchedDate"
                speakFeedback(spokenResult)
            } else {
                // Show other labs in dimmer format (just first 5)
                if (i < 5 && !foundMatch) {
                    sb.append("• $name: $value $unit\n")
                }
            }
        }

        if (!foundMatch) {
            sb.append("\n⚠️ No results found for '$filterItem'\n")
            speakFeedback("No results found for $filterItem")
        }

        showDataOverlay("LAB RESULTS", sb.toString())
    }

    /**
     * Fetch vitals and filter/highlight a specific item.
     */
    private fun fetchVitalsWithFilter(patientId: String, filterItem: String) {
        val url = "$EHR_PROXY_URL/api/v1/patient/$patientId/vitals"
        val request = Request.Builder()
            .url(url)
            .header("X-Device-ID", deviceId)
            .build()

        httpClient.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                runOnUiThread {
                    Log.e(TAG, "Vitals fetch failed", e)
                    speakFeedback("Couldn't fetch vitals.")
                }
            }

            override fun onResponse(call: Call, response: Response) {
                response.use { resp ->
                    if (resp.isSuccessful) {
                        val body = resp.body?.string()
                        if (body != null) {
                            val data = JSONObject(body)
                            runOnUiThread { displayFilteredVitals(data, filterItem) }
                        }
                    } else {
                        runOnUiThread {
                            speakFeedback("Error fetching vitals.")
                        }
                    }
                }
            }
        })
    }

    /**
     * Display vitals with a specific item highlighted.
     */
    private fun displayFilteredVitals(data: JSONObject, filterItem: String) {
        val vitals = data.optJSONArray("vitals") ?: JSONArray()
        val filterLower = filterItem.lowercase()

        val sb = StringBuilder()
        sb.append("❤️ VITALS")
        if (filterItem.isNotEmpty()) {
            sb.append(" - Filtered: ${filterItem.replaceFirstChar { it.uppercase() }}")
        }
        sb.append("\n${"─".repeat(30)}\n\n")

        var foundMatch = false

        for (i in 0 until vitals.length()) {
            val vital = vitals.getJSONObject(i)
            val name = vital.optString("name", vital.optString("display", "Unknown"))
            val value = vital.optString("value", "")
            val unit = vital.optString("unit", "")
            val date = vital.optString("date", "")

            val nameLower = name.lowercase()
            val isMatch = filterLower in nameLower ||
                    INDIRECT_VITAL_ALIASES.any { (alias, canonical) ->
                        alias == filterLower && canonical.lowercase() in nameLower
                    }

            if (isMatch) {
                foundMatch = true
                sb.append("⭐ $name: $value $unit\n")
                sb.append("   Date: $date\n\n")

                // Speak the result
                val spokenResult = "$name is $value $unit"
                speakFeedback(spokenResult)
            } else if (i < 5 && !foundMatch) {
                sb.append("• $name: $value $unit\n")
            }
        }

        if (!foundMatch) {
            sb.append("\n⚠️ No results found for '$filterItem'\n")
            speakFeedback("No results found for $filterItem")
        }

        showDataOverlay("VITAL SIGNS", sb.toString())
    }

    // Alias mappings for indirect commands
    private val INDIRECT_LAB_ALIASES = mapOf(
        "k" to "potassium", "k+" to "potassium",
        "na" to "sodium", "na+" to "sodium",
        "creat" to "creatinine",
        "hgb" to "hemoglobin", "hb" to "hemoglobin",
        "hct" to "hematocrit",
        "trop" to "troponin",
        "plt" to "platelets"
    )

    private val INDIRECT_VITAL_ALIASES = mapOf(
        "bp" to "blood pressure", "pressure" to "blood pressure",
        "hr" to "heart rate", "pulse" to "heart rate",
        "temp" to "temperature",
        "rr" to "respiratory rate",
        "spo2" to "oxygen saturation", "o2 sat" to "oxygen saturation", "sat" to "oxygen saturation",
        "wt" to "weight",
        "ht" to "height"
    )

    // ============ Vuzix HUD Methods (Feature #73) ============

    private fun startVuzixHudService() {
        val intent = Intent(this, VuzixHudService::class.java)
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
            startForegroundService(intent)
        } else {
            startService(intent)
        }
        Log.d(TAG, "Vuzix HUD service started")
    }

    private fun stopVuzixHudService() {
        val intent = Intent(this, VuzixHudService::class.java)
        stopService(intent)
        Log.d(TAG, "Vuzix HUD service stopped")
    }

    private fun notifyHudPatientUpdate() {
        if (!isVuzixDevice()) return

        val patientData = currentPatientData ?: return
        val intent = Intent(VuzixHudService.ACTION_UPDATE_PATIENT).apply {
            putExtra(VuzixHudService.EXTRA_PATIENT_DATA, patientData.toString())
        }
        LocalBroadcastManager.getInstance(this).sendBroadcast(intent)
        Log.d(TAG, "Notified HUD of patient update")
    }

    private fun sendHudCommand(action: String) {
        if (!isVuzixDevice()) {
            speakFeedback("HUD only available on Vuzix glasses")
            return
        }

        val intent = Intent(action)
        LocalBroadcastManager.getInstance(this).sendBroadcast(intent)

        val commandName = action.substringAfterLast("_").lowercase()
        speakFeedback("HUD $commandName")
    }

    // ============ Gesture Control Methods (Feature #75) ============

    /**
     * Initialize head gesture detector for Vuzix Blade 2
     * Detects: nod (yes/confirm), shake (no/cancel), double nod (toggle HUD)
     */
    private fun initializeGestureControl() {
        headGestureDetector = HeadGestureDetector(this, object : HeadGestureDetector.GestureListener {
            override fun onHeadNod() {
                runOnUiThread { handleGestureConfirm() }
            }

            override fun onHeadShake() {
                runOnUiThread { handleGestureCancel() }
            }

            override fun onDoubleNod() {
                runOnUiThread { sendHudCommand(VuzixHudService.ACTION_TOGGLE) }
            }

            override fun onWink() {
                runOnUiThread { handleWinkSelect() }
            }
        })
        headGestureDetector?.initialize()
        Log.d(TAG, "Gesture control initialized")
    }

    /**
     * Start gesture monitoring - call in onResume
     */
    private fun startGestureMonitoring() {
        if (!isVuzixDevice() || !isGestureControlEnabled) return
        headGestureDetector?.startDetection()
        Log.d(TAG, "Gesture monitoring started")
    }

    /**
     * Stop gesture monitoring - call in onPause
     */
    private fun stopGestureMonitoring() {
        headGestureDetector?.stopDetection()
        Log.d(TAG, "Gesture monitoring stopped")
    }

    /**
     * Handle head nod gesture - confirm active dialog/action
     */
    private fun handleGestureConfirm() {
        updateLastActivity()

        // Check for pending order confirmation
        if (pendingConfirmationOrder != null) {
            Log.d(TAG, "Gesture confirm: confirming pending order")
            confirmPendingOrder()
            return
        }

        // Check for pending billing claim confirmation
        if (isAwaitingClaimConfirmation) {
            Log.d(TAG, "Gesture confirm: confirming billing claim")
            confirmClaimSubmission()
            return
        }

        // Check for worklist navigation - select current patient
        if (worklistPatients.isNotEmpty()) {
            val currentIndex = worklistPosition
            if (currentIndex in worklistPatients.indices) {
                val patient = worklistPatients[currentIndex]
                speakFeedback("Loading patient ${currentIndex + 1}")
                fetchPatientData(patient.patientId)
                return
            }
        }

        // Default feedback
        speakFeedback("Nod confirmed")
    }

    /**
     * Handle head shake gesture - cancel active dialog/action
     */
    private fun handleGestureCancel() {
        updateLastActivity()

        // Check for pending order confirmation
        if (pendingConfirmationOrder != null) {
            Log.d(TAG, "Gesture cancel: rejecting pending order")
            rejectPendingOrder()
            return
        }

        // Check for pending billing claim confirmation
        if (isAwaitingClaimConfirmation) {
            Log.d(TAG, "Gesture cancel: cancelling billing claim")
            isAwaitingClaimConfirmation = false
            speakFeedback("Claim cancelled")
            return
        }

        // Close any open overlay
        if (dataOverlay?.visibility == android.view.View.VISIBLE) {
            hideDataOverlay()
            speakFeedback("Dismissed")
            return
        }

        // Default feedback
        speakFeedback("Shake cancelled")
    }

    /**
     * Handle wink gesture (quick head micro-tilt) - quick select/dismiss
     * Feature #76 - Faster and subtler than full nod
     */
    private fun handleWinkSelect() {
        updateLastActivity()

        // Check for pending alerts to dismiss
        if (dataOverlay?.visibility == android.view.View.VISIBLE) {
            hideDataOverlay()
            speakFeedback("Dismissed")
            return
        }

        // Quick select from worklist
        if (worklistPatients.isNotEmpty()) {
            val currentIndex = worklistPosition
            if (currentIndex in worklistPatients.indices) {
                val patient = worklistPatients[currentIndex]
                speakFeedback("Loading ${patient.name.split(" ").firstOrNull() ?: "patient"}")
                fetchPatientData(patient.patientId)
                return
            }
        }

        // Default feedback
        speakFeedback("Wink")
    }

    /**
     * Enable gesture control via voice command
     */
    private fun enableGestureControl() {
        isGestureControlEnabled = true
        headGestureDetector?.enable()
        speakFeedback("Gesture control enabled. Nod to confirm, shake to cancel.")
    }

    /**
     * Disable gesture control via voice command
     */
    private fun disableGestureControl() {
        isGestureControlEnabled = false
        headGestureDetector?.disable()
        speakFeedback("Gesture control disabled")
    }

    /**
     * Report gesture control status via voice command
     */
    private fun speakGestureStatus() {
        val status = headGestureDetector?.getStatusDescription()
            ?: if (isGestureControlEnabled) "Gesture control enabled" else "Gesture control disabled"
        speakFeedback(status)
    }

    /**
     * Enable wink detection via voice command
     */
    private fun enableWinkDetection() {
        headGestureDetector?.enableWink()
        speakFeedback("Wink detection enabled. Quick head dip to select.")
    }

    /**
     * Disable wink detection via voice command
     */
    private fun disableWinkDetection() {
        headGestureDetector?.disableWink()
        speakFeedback("Wink detection disabled")
    }

    /**
     * Report wink detection status via voice command
     */
    private fun speakWinkStatus() {
        val status = headGestureDetector?.getWinkStatusDescription() ?: "Wink detection status unknown"
        speakFeedback(status)
    }

    // ============ Offline Cache Methods ============

    private fun isNetworkAvailable(): Boolean {
        val connectivityManager = getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val network = connectivityManager.activeNetwork ?: return false
        val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return false
        return capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
    }

    private fun cachePatientData(patientId: String, patientJson: String) {
        cachePrefs.edit().apply {
            putString("$CACHE_PREFIX$patientId", patientJson)
            putLong("$CACHE_PREFIX$patientId$CACHE_TIMESTAMP_SUFFIX", System.currentTimeMillis())
            apply()
        }
        Log.d(TAG, "Cached patient data: $patientId")
    }

    private fun getCachedPatient(patientId: String): JSONObject? {
        val cached = cachePrefs.getString("$CACHE_PREFIX$patientId", null) ?: return null
        val timestamp = cachePrefs.getLong("$CACHE_PREFIX$patientId$CACHE_TIMESTAMP_SUFFIX", 0)

        // Check if cache is expired
        if (System.currentTimeMillis() - timestamp > CACHE_MAX_AGE_MS) {
            Log.d(TAG, "Cache expired for patient: $patientId")
            return null
        }

        return try {
            JSONObject(cached)
        } catch (e: Exception) {
            Log.e(TAG, "Failed to parse cached patient: ${e.message}")
            null
        }
    }

    private fun getCachedPatientIds(): List<String> {
        return cachePrefs.all.keys
            .filter { it.startsWith(CACHE_PREFIX) && !it.endsWith(CACHE_TIMESTAMP_SUFFIX) }
            .map { it.removePrefix(CACHE_PREFIX) }
    }

    private fun clearCache() {
        cachePrefs.edit().clear().apply()
        Toast.makeText(this, "Patient cache cleared", Toast.LENGTH_SHORT).show()
        Log.d(TAG, "Cache cleared")
    }

    // ============ Session Timeout Methods (HIPAA Compliance) ============

    /**
     * Update last activity timestamp. Call this on any user interaction.
     */
    private fun updateLastActivity() {
        lastActivityTime = System.currentTimeMillis()
    }

    /**
     * Start the session timeout checker.
     * Runs periodically to check if session should be locked.
     */
    private fun startSessionTimeoutChecker() {
        sessionCheckHandler = android.os.Handler(android.os.Looper.getMainLooper())
        sessionCheckRunnable = object : Runnable {
            override fun run() {
                checkSessionTimeout()
                sessionCheckHandler?.postDelayed(this, SESSION_CHECK_INTERVAL_MS)
            }
        }
        sessionCheckHandler?.postDelayed(sessionCheckRunnable!!, SESSION_CHECK_INTERVAL_MS)
        Log.d(TAG, "Session timeout checker started (${sessionTimeoutMinutes} min timeout)")
    }

    /**
     * Stop the session timeout checker.
     */
    private fun stopSessionTimeoutChecker() {
        sessionCheckRunnable?.let { sessionCheckHandler?.removeCallbacks(it) }
        sessionCheckHandler = null
        sessionCheckRunnable = null
        Log.d(TAG, "Session timeout checker stopped")
    }

    /**
     * Check if session has timed out and lock if needed.
     */
    private fun checkSessionTimeout() {
        if (isSessionLocked) return

        val elapsed = System.currentTimeMillis() - lastActivityTime
        val timeoutMs = sessionTimeoutMinutes * 60 * 1000L

        if (elapsed >= timeoutMs) {
            Log.d(TAG, "Session timeout - locking after ${elapsed / 1000}s inactivity")
            lockSession()
        }
    }

    /**
     * Lock the session - hide PHI and show lock screen.
     * If device is paired, requires TOTP to unlock (not just tap/voice).
     */
    private fun lockSession() {
        if (isSessionLocked) return

        isSessionLocked = true
        Log.d(TAG, "Session locked for HIPAA compliance")

        // Invalidate session token on lock
        if (isDevicePaired) {
            sessionToken = null
            cachePrefs.edit().remove(PREF_SESSION_TOKEN).apply()
        }

        // Stop any active transcription
        if (isLiveTranscribing) {
            stopLiveTranscription()
        }

        // Stop TTS
        textToSpeech?.stop()

        // Hide any data overlays
        hideDataOverlay()
        hideLiveTranscriptionOverlay()

        // Show appropriate lock screen
        if (isDevicePaired) {
            // Paired device: require TOTP to unlock
            showTotpLockScreen()
        } else {
            // Unpaired device: simple lock (tap/voice to unlock)
            showLockScreenOverlay()
        }

        // Update status
        statusText.text = "Session Locked"
        transcriptText.text = if (isDevicePaired) "Say your 6-digit code to unlock" else "Tap or say 'unlock' to continue"
        patientDataText.text = ""

        // Speak lock notification
        speakFeedback("Session locked due to inactivity")
    }

    /**
     * Unlock the session.
     */
    private fun unlockSession() {
        if (!isSessionLocked) return

        isSessionLocked = false
        updateLastActivity()

        // Hide lock screen
        hideLockScreenOverlay()

        // Restore status
        statusText.text = "Session Unlocked"
        transcriptText.text = "Ready for commands"

        // Speak unlock confirmation
        speakFeedback("Session unlocked")

        Log.d(TAG, "Session unlocked")
    }

    /**
     * Show the lock screen overlay.
     */
    private fun showLockScreenOverlay() {
        if (lockScreenOverlay != null) return

        val rootView = findViewById<android.view.ViewGroup>(android.R.id.content)

        lockScreenOverlay = android.widget.FrameLayout(this).apply {
            setBackgroundColor(0xF0121212.toInt())
            isClickable = true
            isFocusable = true

            setOnClickListener {
                unlockSession()
            }
        }

        val lockContent = android.widget.LinearLayout(this).apply {
            orientation = android.widget.LinearLayout.VERTICAL
            gravity = android.view.Gravity.CENTER
            setPadding(48, 48, 48, 48)
        }

        // Lock icon
        val lockIcon = TextView(this).apply {
            text = "🔒"
            textSize = 72f
            gravity = android.view.Gravity.CENTER
        }

        // Lock message
        val lockMessage = TextView(this).apply {
            text = "Session Locked"
            textSize = 28f
            setTextColor(0xFFFFFFFF.toInt())
            gravity = android.view.Gravity.CENTER
            setPadding(0, 24, 0, 16)
        }

        // HIPAA message
        val hipaaMessage = TextView(this).apply {
            text = "For HIPAA compliance, this session\nwas locked due to inactivity."
            textSize = 16f
            setTextColor(0xFFAAAAAA.toInt())
            gravity = android.view.Gravity.CENTER
            setPadding(0, 0, 0, 32)
        }

        // Unlock instruction
        val unlockInstruction = TextView(this).apply {
            text = "Tap anywhere or say \"unlock\" to continue"
            textSize = 14f
            setTextColor(0xFF4CAF50.toInt())
            gravity = android.view.Gravity.CENTER
        }

        // Timeout info
        val timeoutInfo = TextView(this).apply {
            text = "Timeout: ${sessionTimeoutMinutes} minutes"
            textSize = 12f
            setTextColor(0xFF666666.toInt())
            gravity = android.view.Gravity.CENTER
            setPadding(0, 48, 0, 0)
        }

        lockContent.addView(lockIcon)
        lockContent.addView(lockMessage)
        lockContent.addView(hipaaMessage)
        lockContent.addView(unlockInstruction)
        lockContent.addView(timeoutInfo)

        val contentParams = android.widget.FrameLayout.LayoutParams(
            android.widget.FrameLayout.LayoutParams.WRAP_CONTENT,
            android.widget.FrameLayout.LayoutParams.WRAP_CONTENT
        ).apply {
            gravity = android.view.Gravity.CENTER
        }

        lockScreenOverlay?.addView(lockContent, contentParams)

        val overlayParams = android.widget.FrameLayout.LayoutParams(
            android.widget.FrameLayout.LayoutParams.MATCH_PARENT,
            android.widget.FrameLayout.LayoutParams.MATCH_PARENT
        )

        rootView.addView(lockScreenOverlay, overlayParams)
        Log.d(TAG, "Lock screen overlay shown")
    }

    /**
     * Hide the lock screen overlay.
     */
    private fun hideLockScreenOverlay() {
        lockScreenOverlay?.let {
            val rootView = findViewById<android.view.ViewGroup>(android.R.id.content)
            rootView.removeView(it)
            lockScreenOverlay = null
            Log.d(TAG, "Lock screen overlay hidden")
        }
    }

    /**
     * Set session timeout duration in minutes.
     */
    private fun setSessionTimeout(minutes: Int) {
        sessionTimeoutMinutes = minutes.coerceIn(1, 60)
        cachePrefs.edit().putInt(PREF_SESSION_TIMEOUT, sessionTimeoutMinutes).apply()
        Toast.makeText(this, "Session timeout set to $sessionTimeoutMinutes minutes", Toast.LENGTH_SHORT).show()
        speakFeedback("Session timeout set to $sessionTimeoutMinutes minutes")
        Log.d(TAG, "Session timeout set to $sessionTimeoutMinutes minutes")
    }

    /**
     * Load session timeout setting from preferences.
     */
    private fun loadSessionTimeoutSetting() {
        sessionTimeoutMinutes = cachePrefs.getInt(PREF_SESSION_TIMEOUT, DEFAULT_SESSION_TIMEOUT_MINUTES)
        Log.d(TAG, "Loaded session timeout: $sessionTimeoutMinutes minutes")
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // DEVICE AUTHENTICATION (TOTP + QR Pairing + Proximity Lock)
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Initialize device authentication - load saved auth state.
     * Called during onCreate.
     */
    private fun initializeDeviceAuth() {
        // Generate unique device ID if not exists
        deviceId = cachePrefs.getString(PREF_DEVICE_ID, "") ?: ""
        if (deviceId.isEmpty()) {
            deviceId = java.util.UUID.randomUUID().toString()
            cachePrefs.edit().putString(PREF_DEVICE_ID, deviceId).apply()
            Log.d(TAG, "Generated new device ID: $deviceId")
        }

        // Load auth state
        sessionToken = cachePrefs.getString(PREF_SESSION_TOKEN, null)
        clinicianId = cachePrefs.getString(PREF_CLINICIAN_ID, null)
        isDevicePaired = cachePrefs.getBoolean(PREF_DEVICE_PAIRED, false)
        isVoiceprintEnrolled = cachePrefs.getBoolean(PREF_VOICEPRINT_ENROLLED, false)

        // Feature #77: Start continuous auth monitoring if voiceprint enrolled
        if (isVoiceprintEnrolled) {
            startContinuousAuthMonitor()
        }

        Log.d(TAG, "Device auth initialized - paired: $isDevicePaired, hasSession: ${sessionToken != null}")

        // Initialize proximity sensor for auto-lock
        initializeProximitySensor()

        // Check device status with backend
        if (isDevicePaired && sessionToken != null) {
            verifySessionWithBackend()
        }
    }

    /**
     * Start device pairing - launch QR scanner.
     */
    private fun startDevicePairing() {
        speakFeedback("Starting device pairing. Please scan the QR code from your dashboard.")
        val intent = Intent(this, QrPairingActivity::class.java)
        startActivityForResult(intent, QR_SCAN_REQUEST_CODE)
    }

    /**
     * Complete device pairing after QR scan.
     */
    private fun completePairing(token: String, apiUrl: String?) {
        Log.d(TAG, "Completing pairing with token: $token")
        statusText.text = "Pairing device..."

        Thread {
            try {
                val requestBody = JSONObject().apply {
                    put("token", token)
                    put("device_id", deviceId)
                    put("device_name", "MDx Vision Glasses")
                    put("device_type", android.os.Build.MODEL)
                }

                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/auth/device/pair")
                    .post(requestBody.toString().toRequestBody("application/json".toMediaType()))
                    .build()

                val response = httpClient.newCall(request).execute()
                val responseBody = response.body?.string() ?: "{}"
                val result = JSONObject(responseBody)

                runOnUiThread {
                    if (result.optBoolean("success", false)) {
                        val clinicianName = result.optString("clinician_name", "Clinician")
                        clinicianId = result.optString("clinician_id", "")
                        isDevicePaired = true

                        // Save pairing state
                        cachePrefs.edit()
                            .putBoolean(PREF_DEVICE_PAIRED, true)
                            .putString(PREF_CLINICIAN_ID, clinicianId)
                            .apply()

                        statusText.text = "Device paired to: $clinicianName"
                        speakFeedback("Device paired successfully to $clinicianName. Please set up your authenticator app, then say your 6-digit code to unlock.")
                        Toast.makeText(this, "Paired to: $clinicianName", Toast.LENGTH_LONG).show()

                        // Now require TOTP to unlock
                        showTotpLockScreen()

                    } else {
                        val error = result.optString("error", "Pairing failed")
                        statusText.text = "Pairing failed"
                        speakFeedback("Pairing failed: $error")
                        Toast.makeText(this, error, Toast.LENGTH_LONG).show()
                    }
                }

            } catch (e: Exception) {
                Log.e(TAG, "Pairing error: ${e.message}")
                runOnUiThread {
                    statusText.text = "Pairing error"
                    speakFeedback("Network error during pairing. Please try again.")
                    Toast.makeText(this, "Network error: ${e.message}", Toast.LENGTH_SHORT).show()
                }
            }
        }.start()
    }

    /**
     * Show TOTP lock screen - requires voice code to unlock.
     */
    private fun showTotpLockScreen() {
        isSessionLocked = true
        isAwaitingTotpCode = true
        totpDigitBuffer.clear()

        // Hide any data overlays
        hideDataOverlay()
        hideLiveTranscriptionOverlay()

        // Show TOTP lock screen
        val rootView = findViewById<android.view.ViewGroup>(android.R.id.content)

        lockScreenOverlay = android.widget.FrameLayout(this).apply {
            setBackgroundColor(0xF0121212.toInt())
            isClickable = true
            isFocusable = true
        }

        val lockContent = android.widget.LinearLayout(this).apply {
            orientation = android.widget.LinearLayout.VERTICAL
            gravity = android.view.Gravity.CENTER
            setPadding(48, 48, 48, 48)
        }

        // Lock icon
        val lockIcon = TextView(this).apply {
            text = "🔐"
            textSize = 64f
            gravity = android.view.Gravity.CENTER
        }

        // Lock message
        val lockMessage = TextView(this).apply {
            text = "Voice Unlock Required"
            textSize = 28f
            setTextColor(0xFFFFFFFF.toInt())
            gravity = android.view.Gravity.CENTER
            setPadding(0, 24, 0, 16)
        }

        // Instructions
        val instructions = TextView(this).apply {
            text = "Say your 6-digit code from your authenticator app\n(e.g., \"4 7 2 9 1 5\")"
            textSize = 16f
            setTextColor(0xFFAAAAAA.toInt())
            gravity = android.view.Gravity.CENTER
            setPadding(0, 0, 0, 24)
        }

        // Code display (shows entered digits)
        val codeDisplay = TextView(this).apply {
            id = android.R.id.text1  // Use a known ID for updating
            text = "● ● ● ● ● ●"
            textSize = 32f
            setTextColor(0xFF4CAF50.toInt())
            gravity = android.view.Gravity.CENTER
            typeface = android.graphics.Typeface.MONOSPACE
            letterSpacing = 0.3f
        }

        // Pairing button for new devices
        val pairButton = android.widget.Button(this).apply {
            text = "Pair New Device"
            setOnClickListener { startDevicePairing() }
            visibility = if (isDevicePaired) android.view.View.GONE else android.view.View.VISIBLE
        }

        lockContent.addView(lockIcon)
        lockContent.addView(lockMessage)
        lockContent.addView(instructions)
        lockContent.addView(codeDisplay)
        if (!isDevicePaired) {
            lockContent.addView(pairButton)
        }

        val contentParams = android.widget.FrameLayout.LayoutParams(
            android.widget.FrameLayout.LayoutParams.WRAP_CONTENT,
            android.widget.FrameLayout.LayoutParams.WRAP_CONTENT
        ).apply {
            gravity = android.view.Gravity.CENTER
        }

        lockScreenOverlay?.addView(lockContent, contentParams)

        val overlayParams = android.widget.FrameLayout.LayoutParams(
            android.widget.FrameLayout.LayoutParams.MATCH_PARENT,
            android.widget.FrameLayout.LayoutParams.MATCH_PARENT
        )

        rootView.addView(lockScreenOverlay, overlayParams)

        // Start listening for voice
        startVoiceRecognition()

        Log.d(TAG, "TOTP lock screen shown")
    }

    /**
     * Process spoken digits for TOTP code entry.
     * Called from voice recognition when awaiting TOTP.
     */
    private fun processTotpVoiceInput(spokenText: String) {
        val lower = spokenText.lowercase().trim()

        // Map spoken words to digits
        val digitMap = mapOf(
            "zero" to "0", "oh" to "0", "o" to "0",
            "one" to "1", "won" to "1",
            "two" to "2", "to" to "2", "too" to "2",
            "three" to "3", "tree" to "3",
            "four" to "4", "for" to "4", "fore" to "4",
            "five" to "5",
            "six" to "6", "sex" to "6",
            "seven" to "7",
            "eight" to "8", "ate" to "8",
            "nine" to "9", "niner" to "9"
        )

        // Extract digits from spoken text
        val words = lower.split(" ", ",", "-", ".")
        for (word in words) {
            val cleaned = word.filter { it.isLetterOrDigit() }

            // Check if it's a direct digit
            if (cleaned.length == 1 && cleaned[0].isDigit()) {
                totpDigitBuffer.append(cleaned)
            }
            // Check if it's a spoken digit word
            else if (digitMap.containsKey(cleaned)) {
                totpDigitBuffer.append(digitMap[cleaned])
            }
            // Check if it contains multiple digits (e.g., "472")
            else {
                for (char in cleaned) {
                    if (char.isDigit()) {
                        totpDigitBuffer.append(char)
                    }
                }
            }
        }

        // Update display
        updateTotpDisplay()

        // Check if we have 6 digits
        if (totpDigitBuffer.length >= 6) {
            val code = totpDigitBuffer.substring(0, 6)
            totpDigitBuffer.clear()
            verifyTotpCode(code)
        } else if (totpDigitBuffer.length > 0) {
            // Keep listening
            startVoiceRecognition()
        }
    }

    /**
     * Update the TOTP code display with entered digits.
     */
    private fun updateTotpDisplay() {
        lockScreenOverlay?.findViewById<TextView>(android.R.id.text1)?.let { display ->
            val entered = totpDigitBuffer.toString()
            val displayText = StringBuilder()
            for (i in 0 until 6) {
                if (i < entered.length) {
                    displayText.append(entered[i])
                } else {
                    displayText.append("●")
                }
                if (i < 5) displayText.append(" ")
            }
            display.text = displayText.toString()
        }
    }

    /**
     * Verify TOTP code with backend.
     */
    private fun verifyTotpCode(code: String) {
        Log.d(TAG, "Verifying TOTP code: $code")
        speakFeedback("Verifying code")

        Thread {
            try {
                val requestBody = JSONObject().apply {
                    put("device_id", deviceId)
                    put("totp_code", code)
                }

                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/auth/device/unlock")
                    .post(requestBody.toString().toRequestBody("application/json".toMediaType()))
                    .build()

                val response = httpClient.newCall(request).execute()
                val responseBody = response.body?.string() ?: "{}"
                val result = JSONObject(responseBody)

                runOnUiThread {
                    if (result.optBoolean("success", false)) {
                        // Save session token
                        sessionToken = result.optString("session_token", "")
                        val clinicianName = result.optString("clinician_name", "Clinician")

                        cachePrefs.edit()
                            .putString(PREF_SESSION_TOKEN, sessionToken)
                            .apply()

                        // Unlock session
                        isAwaitingTotpCode = false
                        isSessionLocked = false
                        hideLockScreenOverlay()
                        updateLastActivity()

                        statusText.text = "Welcome, $clinicianName"
                        speakFeedback("Welcome, $clinicianName. Session unlocked.")
                        Toast.makeText(this, "Session unlocked", Toast.LENGTH_SHORT).show()

                        Log.d(TAG, "TOTP verified - session unlocked")

                    } else {
                        val error = result.optString("error", "Invalid code")
                        speakFeedback("Invalid code. Please try again.")
                        Toast.makeText(this, error, Toast.LENGTH_SHORT).show()
                        totpDigitBuffer.clear()
                        updateTotpDisplay()
                        startVoiceRecognition()
                    }
                }

            } catch (e: Exception) {
                Log.e(TAG, "TOTP verification error: ${e.message}")
                runOnUiThread {
                    speakFeedback("Network error. Please try again.")
                    totpDigitBuffer.clear()
                    updateTotpDisplay()
                    startVoiceRecognition()
                }
            }
        }.start()
    }

    /**
     * Verify session with backend (check if still valid).
     */
    private fun verifySessionWithBackend() {
        Thread {
            try {
                val requestBody = JSONObject().apply {
                    put("device_id", deviceId)
                    put("session_token", sessionToken)
                }

                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/auth/device/verify-session")
                    .post(requestBody.toString().toRequestBody("application/json".toMediaType()))
                    .build()

                val response = httpClient.newCall(request).execute()
                val responseBody = response.body?.string() ?: "{}"
                val result = JSONObject(responseBody)

                runOnUiThread {
                    if (result.optBoolean("valid", false)) {
                        Log.d(TAG, "Session verified with backend")
                        isSessionLocked = false
                    } else {
                        Log.d(TAG, "Session invalid - requiring TOTP")
                        sessionToken = null
                        cachePrefs.edit().remove(PREF_SESSION_TOKEN).apply()
                        showTotpLockScreen()
                    }
                }

            } catch (e: Exception) {
                Log.e(TAG, "Session verify error: ${e.message}")
                // On network error, allow offline use if previously verified
            }
        }.start()
    }

    /**
     * Initialize proximity sensor for auto-lock when glasses removed.
     */
    private fun initializeProximitySensor() {
        sensorManager = getSystemService(Context.SENSOR_SERVICE) as android.hardware.SensorManager
        proximitySensor = sensorManager?.getDefaultSensor(android.hardware.Sensor.TYPE_PROXIMITY)

        if (proximitySensor != null) {
            Log.d(TAG, "Proximity sensor available - enabling auto-lock")
        } else {
            Log.w(TAG, "No proximity sensor - auto-lock disabled")
        }
    }

    /**
     * Proximity sensor listener for auto-lock.
     */
    private val proximitySensorListener = object : android.hardware.SensorEventListener {
        override fun onSensorChanged(event: android.hardware.SensorEvent) {
            if (event.sensor.type == android.hardware.Sensor.TYPE_PROXIMITY) {
                val distance = event.values[0]
                val maxRange = event.sensor.maximumRange

                // Object close = glasses on face, far = glasses removed
                val wasOnFace = isGlassesOnFace
                isGlassesOnFace = distance < maxRange

                if (wasOnFace && !isGlassesOnFace) {
                    // Glasses removed - auto-lock after short delay
                    Log.d(TAG, "Proximity: Glasses removed - locking in 3 seconds")
                    android.os.Handler(mainLooper).postDelayed({
                        if (!isGlassesOnFace && !isSessionLocked) {
                            lockSession()
                            speakFeedback("Session locked. Glasses removed.")
                        }
                    }, 3000)
                } else if (!wasOnFace && isGlassesOnFace) {
                    Log.d(TAG, "Proximity: Glasses back on face")
                }
            }
        }

        override fun onAccuracyChanged(sensor: android.hardware.Sensor, accuracy: Int) {}
    }

    /**
     * Start proximity sensor monitoring.
     */
    private fun startProximityMonitoring() {
        proximitySensor?.let { sensor ->
            sensorManager?.registerListener(
                proximitySensorListener,
                sensor,
                android.hardware.SensorManager.SENSOR_DELAY_NORMAL
            )
            Log.d(TAG, "Proximity monitoring started")
        }
    }

    /**
     * Stop proximity sensor monitoring.
     */
    private fun stopProximityMonitoring() {
        sensorManager?.unregisterListener(proximitySensorListener)
        Log.d(TAG, "Proximity monitoring stopped")
    }

    /**
     * Check if device should show TOTP lock on startup.
     */
    private fun shouldRequireTotpOnStartup(): Boolean {
        // Require TOTP if:
        // 1. Device is paired but no valid session
        // 2. Device is not paired (show pairing option)
        return isDevicePaired && sessionToken == null
    }

    /**
     * Remote wipe - clear all local data.
     * Called when backend signals device is wiped.
     */
    private fun performLocalWipe() {
        Log.w(TAG, "Performing local data wipe")

        // Clear all cached data
        cachePrefs.edit().clear().apply()

        // Reset state
        deviceId = ""
        sessionToken = null
        clinicianId = null
        isDevicePaired = false
        isVoiceprintEnrolled = false
        currentPatientData = null

        // Show message
        runOnUiThread {
            Toast.makeText(this, "Device wiped by administrator", Toast.LENGTH_LONG).show()
            speakFeedback("Device has been remotely wiped. Please contact your administrator.")

            // Re-initialize with new device ID
            initializeDeviceAuth()
            showTotpLockScreen()
        }
    }

    /**
     * Show device authentication status.
     */
    private fun showDeviceStatus() {
        val status = StringBuilder("Device Authentication Status:\n\n")

        status.append("Device ID: ${deviceId.take(8)}...\n")
        status.append("Paired: ${if (isDevicePaired) "Yes" else "No"}\n")
        status.append("Session: ${if (sessionToken != null) "Active" else "Locked"}\n")
        status.append("Voiceprint: ${if (isVoiceprintEnrolled) "Enrolled" else "Not enrolled"}\n")
        status.append("Proximity Lock: ${if (proximitySensor != null) "Enabled" else "Disabled"}\n")

        if (!isDevicePaired) {
            status.append("\nSay 'pair device' to set up authentication.")
        }

        patientDataText.text = status.toString()
        speakFeedback("Device ${if (isDevicePaired) "is paired and ${if (sessionToken != null) "session is active" else "requires unlock"}" else "is not paired"}")

        Log.d(TAG, "Device status displayed")
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // VOICEPRINT ENROLLMENT & VERIFICATION (Speaker Recognition)
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Start voiceprint enrollment process.
     * Fetches enrollment phrases from backend, then prompts user to record each phrase.
     */
    private fun startVoiceprintEnrollment() {
        if (!isDevicePaired) {
            speakFeedback("Please pair your device first before enrolling voiceprint.")
            return
        }

        speakFeedback("Starting voiceprint enrollment. Please wait.")
        statusText.text = "Loading enrollment phrases..."

        Thread {
            try {
                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/auth/voiceprint/phrases")
                    .get()
                    .build()

                val response = httpClient.newCall(request).execute()
                val responseBody = response.body?.string() ?: "{}"
                val result = JSONObject(responseBody)

                val phrasesArray = result.optJSONArray("phrases") ?: org.json.JSONArray()
                val phrases = mutableListOf<String>()
                for (i in 0 until phrasesArray.length()) {
                    phrases.add(phrasesArray.getString(i))
                }

                runOnUiThread {
                    if (phrases.isNotEmpty()) {
                        voiceprintEnrollmentPhrases = phrases
                        voiceprintRecordingIndex = 0
                        voiceprintAudioSamples.clear()
                        showVoiceprintEnrollmentUI()
                    } else {
                        statusText.text = "Failed to load phrases"
                        speakFeedback("Failed to load enrollment phrases. Please try again.")
                    }
                }

            } catch (e: Exception) {
                Log.e(TAG, "Error fetching enrollment phrases: ${e.message}")
                runOnUiThread {
                    statusText.text = "Enrollment error"
                    speakFeedback("Network error. Please try again.")
                }
            }
        }.start()
    }

    /**
     * Show voiceprint enrollment UI with phrases to record.
     */
    private fun showVoiceprintEnrollmentUI() {
        isRecordingVoiceprint = true

        val rootView = findViewById<android.view.ViewGroup>(android.R.id.content)

        voiceprintEnrollmentOverlay = android.widget.FrameLayout(this).apply {
            setBackgroundColor(0xF0121212.toInt())
            isClickable = true
            isFocusable = true
        }

        val content = android.widget.LinearLayout(this).apply {
            orientation = android.widget.LinearLayout.VERTICAL
            gravity = android.view.Gravity.CENTER
            setPadding(48, 48, 48, 48)
        }

        // Title
        val title = TextView(this).apply {
            text = "🎤 Voiceprint Enrollment"
            textSize = 28f
            setTextColor(0xFFFFFFFF.toInt())
            gravity = android.view.Gravity.CENTER
        }

        // Progress indicator
        val progress = TextView(this).apply {
            id = android.R.id.text2
            text = "Recording ${voiceprintRecordingIndex + 1} of ${voiceprintEnrollmentPhrases.size}"
            textSize = 16f
            setTextColor(0xFF4CAF50.toInt())
            gravity = android.view.Gravity.CENTER
            setPadding(0, 16, 0, 24)
        }

        // Phrase to speak
        val phraseBox = android.widget.LinearLayout(this).apply {
            orientation = android.widget.LinearLayout.VERTICAL
            setBackgroundColor(0xFF1E1E1E.toInt())
            setPadding(32, 24, 32, 24)
        }

        val phraseLabel = TextView(this).apply {
            text = "Please say:"
            textSize = 14f
            setTextColor(0xFFAAAAAA.toInt())
        }

        val phraseText = TextView(this).apply {
            id = android.R.id.text1
            text = "\"${voiceprintEnrollmentPhrases.getOrNull(voiceprintRecordingIndex) ?: ""}\""
            textSize = 22f
            setTextColor(0xFFFFFFFF.toInt())
            gravity = android.view.Gravity.CENTER
            setPadding(0, 8, 0, 0)
        }

        phraseBox.addView(phraseLabel)
        phraseBox.addView(phraseText)

        // Instructions
        val instructions = TextView(this).apply {
            text = "Speak clearly into the microphone.\nRecording will capture automatically."
            textSize = 14f
            setTextColor(0xFFAAAAAA.toInt())
            gravity = android.view.Gravity.CENTER
            setPadding(0, 24, 0, 24)
        }

        // Recording indicator
        val recordingIndicator = TextView(this).apply {
            id = android.R.id.text1  // Using a different ID for recording status
            text = "🔴 Listening..."
            textSize = 18f
            setTextColor(0xFFE53935.toInt())
            gravity = android.view.Gravity.CENTER
        }

        // Cancel button
        val cancelButton = android.widget.Button(this).apply {
            text = "Cancel"
            setOnClickListener { cancelVoiceprintEnrollment() }
        }

        content.addView(title)
        content.addView(progress)
        content.addView(phraseBox)
        content.addView(instructions)
        content.addView(recordingIndicator)
        content.addView(cancelButton)

        val contentParams = android.widget.FrameLayout.LayoutParams(
            android.widget.FrameLayout.LayoutParams.WRAP_CONTENT,
            android.widget.FrameLayout.LayoutParams.WRAP_CONTENT
        ).apply {
            gravity = android.view.Gravity.CENTER
        }

        voiceprintEnrollmentOverlay?.addView(content, contentParams)

        val overlayParams = android.widget.FrameLayout.LayoutParams(
            android.widget.FrameLayout.LayoutParams.MATCH_PARENT,
            android.widget.FrameLayout.LayoutParams.MATCH_PARENT
        )

        rootView.addView(voiceprintEnrollmentOverlay, overlayParams)

        // Speak the first phrase prompt
        val phrase = voiceprintEnrollmentPhrases.getOrNull(voiceprintRecordingIndex) ?: ""
        speakFeedback("Please say: $phrase")

        // Start recording
        startVoiceprintRecording()

        Log.d(TAG, "Voiceprint enrollment UI shown")
    }

    /**
     * Start recording audio for voiceprint enrollment.
     * Uses MediaRecorder to capture audio, then converts to base64.
     */
    private fun startVoiceprintRecording() {
        // Use the existing voice recognition but capture audio data
        // For simplicity, we'll use a simulated approach here
        // In production, implement proper audio recording with MediaRecorder

        // Start voice recognition to capture the phrase
        startVoiceRecognition()

        // After user speaks, the voice recognition callback will process it
        // We need to modify the voice callback to handle voiceprint mode
        Log.d(TAG, "Voiceprint recording started for phrase ${voiceprintRecordingIndex + 1}")
    }

    /**
     * Process voice input during voiceprint enrollment.
     * Called from the voice recognition callback when isRecordingVoiceprint is true.
     */
    private fun processVoiceprintRecording(spokenText: String, audioBase64: String) {
        if (!isRecordingVoiceprint) return

        Log.d(TAG, "Voiceprint audio captured for phrase ${voiceprintRecordingIndex + 1}")

        // For now, we'll create a simulated audio sample
        // In production, capture actual audio from MediaRecorder
        val simulatedAudio = android.util.Base64.encodeToString(
            spokenText.toByteArray(),
            android.util.Base64.NO_WRAP
        )

        voiceprintAudioSamples.add(if (audioBase64.isNotEmpty()) audioBase64 else simulatedAudio)

        voiceprintRecordingIndex++

        if (voiceprintRecordingIndex < voiceprintEnrollmentPhrases.size) {
            // Update UI for next phrase
            updateVoiceprintEnrollmentUI()

            val nextPhrase = voiceprintEnrollmentPhrases.getOrNull(voiceprintRecordingIndex) ?: ""
            speakFeedback("Good. Now say: $nextPhrase")

            // Continue recording
            android.os.Handler(mainLooper).postDelayed({
                startVoiceprintRecording()
            }, 500)
        } else {
            // All phrases recorded - submit to backend
            submitVoiceprintEnrollment()
        }
    }

    /**
     * Update the voiceprint enrollment UI for the next phrase.
     */
    private fun updateVoiceprintEnrollmentUI() {
        voiceprintEnrollmentOverlay?.let { overlay ->
            overlay.findViewById<TextView>(android.R.id.text1)?.text =
                "\"${voiceprintEnrollmentPhrases.getOrNull(voiceprintRecordingIndex) ?: ""}\""
            overlay.findViewById<TextView>(android.R.id.text2)?.text =
                "Recording ${voiceprintRecordingIndex + 1} of ${voiceprintEnrollmentPhrases.size}"
        }
    }

    /**
     * Submit collected audio samples to backend for voiceprint enrollment.
     */
    private fun submitVoiceprintEnrollment() {
        speakFeedback("Processing voiceprint. Please wait.")

        Thread {
            try {
                val requestBody = JSONObject().apply {
                    put("device_id", deviceId)
                    put("audio_samples", org.json.JSONArray(voiceprintAudioSamples))
                }

                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/auth/voiceprint/enroll")
                    .post(requestBody.toString().toRequestBody("application/json".toMediaType()))
                    .build()

                val response = httpClient.newCall(request).execute()
                val responseBody = response.body?.string() ?: "{}"
                val result = JSONObject(responseBody)

                runOnUiThread {
                    dismissVoiceprintEnrollmentUI()

                    if (result.optBoolean("success", false)) {
                        isVoiceprintEnrolled = true
                        cachePrefs.edit().putBoolean(PREF_VOICEPRINT_ENROLLED, true).apply()

                        val consistency = result.optDouble("consistency_score", 0.0)
                        statusText.text = "Voiceprint enrolled successfully"
                        speakFeedback("Voiceprint enrolled successfully. Your voice will be used for additional security on sensitive operations.")

                        Toast.makeText(this, "✓ Voiceprint enrolled", Toast.LENGTH_LONG).show()
                        Log.d(TAG, "Voiceprint enrolled - consistency: $consistency")
                    } else {
                        val error = result.optString("error", "Enrollment failed")
                        statusText.text = "Voiceprint enrollment failed"
                        speakFeedback("Voiceprint enrollment failed: $error")
                        Toast.makeText(this, "Failed: $error", Toast.LENGTH_LONG).show()
                    }
                }

            } catch (e: Exception) {
                Log.e(TAG, "Voiceprint enrollment error: ${e.message}")
                runOnUiThread {
                    dismissVoiceprintEnrollmentUI()
                    statusText.text = "Enrollment error"
                    speakFeedback("Network error during enrollment. Please try again.")
                }
            }
        }.start()
    }

    /**
     * Cancel voiceprint enrollment.
     */
    private fun cancelVoiceprintEnrollment() {
        isRecordingVoiceprint = false
        voiceprintRecordingIndex = 0
        voiceprintAudioSamples.clear()
        dismissVoiceprintEnrollmentUI()
        speakFeedback("Voiceprint enrollment cancelled.")
        Log.d(TAG, "Voiceprint enrollment cancelled")
    }

    /**
     * Dismiss voiceprint enrollment UI.
     */
    private fun dismissVoiceprintEnrollmentUI() {
        voiceprintEnrollmentOverlay?.let {
            val rootView = findViewById<android.view.ViewGroup>(android.R.id.content)
            rootView.removeView(it)
        }
        voiceprintEnrollmentOverlay = null
        isRecordingVoiceprint = false
    }

    /**
     * Show voiceprint enrollment status.
     */
    private fun showVoiceprintStatus() {
        if (isVoiceprintEnrolled) {
            speakFeedback("Voiceprint is enrolled and active.")
            patientDataText.text = "🎤 Voiceprint Status: Enrolled\n\nYour voice will be verified for sensitive operations like pushing notes to EHR or ordering medications."
        } else {
            speakFeedback("Voiceprint is not enrolled. Say 'enroll my voice' to set up.")
            patientDataText.text = "🎤 Voiceprint Status: Not Enrolled\n\nSay 'enroll my voice' to register your voiceprint for additional security."
        }
    }

    /**
     * Delete voiceprint enrollment.
     */
    private fun deleteVoiceprintEnrollment() {
        if (!isVoiceprintEnrolled) {
            speakFeedback("No voiceprint is enrolled.")
            return
        }

        speakFeedback("Deleting voiceprint. Please wait.")

        Thread {
            try {
                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/auth/voiceprint/$deviceId")
                    .delete()
                    .build()

                val response = httpClient.newCall(request).execute()
                val responseBody = response.body?.string() ?: "{}"
                val result = JSONObject(responseBody)

                runOnUiThread {
                    if (result.optBoolean("success", false)) {
                        isVoiceprintEnrolled = false
                        cachePrefs.edit().putBoolean(PREF_VOICEPRINT_ENROLLED, false).apply()
                        statusText.text = "Voiceprint deleted"
                        speakFeedback("Voiceprint has been deleted.")
                        Toast.makeText(this, "Voiceprint deleted", Toast.LENGTH_SHORT).show()
                    } else {
                        val error = result.optString("error", "Delete failed")
                        speakFeedback("Failed to delete voiceprint: $error")
                    }
                }

            } catch (e: Exception) {
                Log.e(TAG, "Voiceprint delete error: ${e.message}")
                runOnUiThread {
                    speakFeedback("Network error. Please try again.")
                }
            }
        }.start()
    }

    /**
     * Verify voiceprint before sensitive operations.
     * Returns true if verified, false if failed or not enrolled.
     */
    private fun verifyVoiceprintForOperation(operation: String, onResult: (Boolean) -> Unit) {
        if (!isVoiceprintEnrolled) {
            // No voiceprint enrolled - allow operation
            onResult(true)
            return
        }

        speakFeedback("Please verify your identity by speaking.")
        isAwaitingVoiceprintVerify = true
        voiceprintVerifyCallback = onResult

        // Show verification UI
        val rootView = findViewById<android.view.ViewGroup>(android.R.id.content)

        voiceprintEnrollmentOverlay = android.widget.FrameLayout(this).apply {
            setBackgroundColor(0xE0121212.toInt())
            isClickable = true
        }

        val content = android.widget.LinearLayout(this).apply {
            orientation = android.widget.LinearLayout.VERTICAL
            gravity = android.view.Gravity.CENTER
            setPadding(48, 48, 48, 48)
        }

        val icon = TextView(this).apply {
            text = "🎤"
            textSize = 64f
            gravity = android.view.Gravity.CENTER
        }

        val title = TextView(this).apply {
            text = "Voice Verification Required"
            textSize = 24f
            setTextColor(0xFFFFFFFF.toInt())
            gravity = android.view.Gravity.CENTER
            setPadding(0, 16, 0, 8)
        }

        val operationText = TextView(this).apply {
            text = "For: $operation"
            textSize = 16f
            setTextColor(0xFF4CAF50.toInt())
            gravity = android.view.Gravity.CENTER
            setPadding(0, 0, 0, 24)
        }

        val instructions = TextView(this).apply {
            text = "Say anything to verify your voice"
            textSize = 14f
            setTextColor(0xFFAAAAAA.toInt())
            gravity = android.view.Gravity.CENTER
        }

        val cancelButton = android.widget.Button(this).apply {
            text = "Cancel"
            setOnClickListener {
                cancelVoiceprintVerification()
                onResult(false)
            }
        }

        content.addView(icon)
        content.addView(title)
        content.addView(operationText)
        content.addView(instructions)
        content.addView(cancelButton)

        val contentParams = android.widget.FrameLayout.LayoutParams(
            android.widget.FrameLayout.LayoutParams.WRAP_CONTENT,
            android.widget.FrameLayout.LayoutParams.WRAP_CONTENT
        ).apply {
            gravity = android.view.Gravity.CENTER
        }

        voiceprintEnrollmentOverlay?.addView(content, contentParams)

        val overlayParams = android.widget.FrameLayout.LayoutParams(
            android.widget.FrameLayout.LayoutParams.MATCH_PARENT,
            android.widget.FrameLayout.LayoutParams.MATCH_PARENT
        )

        rootView.addView(voiceprintEnrollmentOverlay, overlayParams)

        // Start listening for voice
        startVoiceRecognition()
    }

    /**
     * Process voice verification result.
     * Called from voice recognition when isAwaitingVoiceprintVerify is true.
     */
    private fun processVoiceprintVerification(audioBase64: String) {
        if (!isAwaitingVoiceprintVerify) return

        speakFeedback("Verifying voice...")

        Thread {
            try {
                val requestBody = JSONObject().apply {
                    put("device_id", deviceId)
                    put("audio_sample", audioBase64)
                }

                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/auth/voiceprint/verify")
                    .post(requestBody.toString().toRequestBody("application/json".toMediaType()))
                    .build()

                val response = httpClient.newCall(request).execute()
                val responseBody = response.body?.string() ?: "{}"
                val result = JSONObject(responseBody)

                runOnUiThread {
                    dismissVoiceprintEnrollmentUI()
                    isAwaitingVoiceprintVerify = false

                    val verified = result.optBoolean("verified", false)
                    val confidence = result.optDouble("confidence", 0.0)

                    if (verified) {
                        speakFeedback("Voice verified. Proceeding.")
                        Log.d(TAG, "Voiceprint verified - confidence: $confidence")
                    } else {
                        speakFeedback("Voice verification failed. Access denied.")
                        Log.d(TAG, "Voiceprint verification failed - confidence: $confidence")
                    }

                    voiceprintVerifyCallback?.invoke(verified)
                    voiceprintVerifyCallback = null
                }

            } catch (e: Exception) {
                Log.e(TAG, "Voiceprint verify error: ${e.message}")
                runOnUiThread {
                    dismissVoiceprintEnrollmentUI()
                    isAwaitingVoiceprintVerify = false
                    speakFeedback("Verification error. Operation cancelled.")
                    voiceprintVerifyCallback?.invoke(false)
                    voiceprintVerifyCallback = null
                }
            }
        }.start()
    }

    /**
     * Cancel voiceprint verification.
     */
    private fun cancelVoiceprintVerification() {
        isAwaitingVoiceprintVerify = false
        voiceprintVerifyCallback = null
        dismissVoiceprintEnrollmentUI()
    }

    // ═══════════════════════════════════════════════════════════════════════════════
    // FEATURE #77: CONTINUOUS VOICEPRINT AUTHENTICATION
    // ═══════════════════════════════════════════════════════════════════════════════

    /**
     * Check if voiceprint re-verification is needed for continuous auth.
     * Returns true if verification is current, false if re-verification required.
     */
    private fun isVoiceprintVerificationCurrent(): Boolean {
        if (!isVoiceprintEnrolled) return true  // No voiceprint = skip check

        val elapsed = System.currentTimeMillis() - lastVoiceprintVerification
        return elapsed < reVerifyIntervalMs
    }

    /**
     * Get confidence decay based on time since last verification.
     * Confidence decays at 1% per minute.
     */
    private fun getDecayedConfidence(): Float {
        if (lastVoiceprintVerification == 0L) return 0f

        val elapsedMinutes = (System.currentTimeMillis() - lastVoiceprintVerification) / 60000f
        val decayRate = 0.01f  // 1% per minute
        val decayed = voiceprintConfidence - (elapsedMinutes * decayRate)
        return decayed.coerceIn(0f, 1f)
    }

    /**
     * Check voiceprint verification status from server.
     * Updates local state with server response.
     */
    private fun checkVoiceprintStatusFromServer(callback: ((Boolean) -> Unit)? = null) {
        if (deviceId.isEmpty() || !isDevicePaired) {
            callback?.invoke(true)  // No device = skip check
            return
        }

        Thread {
            try {
                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/auth/voiceprint/$deviceId/check")
                    .get()
                    .build()

                val response = httpClient.newCall(request).execute()
                val responseBody = response.body?.string() ?: "{}"
                val json = JSONObject(responseBody)

                runOnUiThread {
                    if (json.optBoolean("has_session")) {
                        val needsVerification = json.optBoolean("needs_verification", true)
                        val confidence = json.optDouble("confidence", 0.0).toFloat()
                        val secondsUntil = json.optInt("seconds_until_verification", 0)

                        // Update local state
                        voiceprintConfidence = confidence
                        if (secondsUntil > 0) {
                            lastVoiceprintVerification = System.currentTimeMillis() -
                                (reVerifyIntervalMs - (secondsUntil * 1000L))
                        }

                        callback?.invoke(!needsVerification)
                    } else {
                        // No session on server - need verification
                        callback?.invoke(false)
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error checking voiceprint status: ${e.message}")
                runOnUiThread {
                    callback?.invoke(true)  // On error, don't block operations
                }
            }
        }.start()
    }

    /**
     * Perform re-verification and update session.
     * Called when continuous auth check indicates verification needed.
     */
    private fun performVoiceprintReVerification(onResult: (Boolean, Float) -> Unit) {
        speakFeedback("Please verify your voice to continue.")

        // Use existing verify UI
        verifyVoiceprintForOperation("Re-verification") { verified ->
            if (verified) {
                // Session was updated by the verify endpoint
                lastVoiceprintVerification = System.currentTimeMillis()
                voiceprintConfidence = 0.85f  // Default confidence on success

                // Save to prefs
                cachePrefs.edit()
                    .putLong(PREF_LAST_VOICEPRINT_VERIFY, lastVoiceprintVerification)
                    .putFloat(PREF_VOICEPRINT_CONFIDENCE, voiceprintConfidence)
                    .apply()

                onResult(true, voiceprintConfidence)
            } else {
                onResult(false, 0f)
            }
        }
    }

    /**
     * Require fresh voiceprint verification before sensitive operation.
     * Checks continuous auth state and prompts for re-verification if needed.
     */
    private fun requireFreshVoiceprintVerification(onVerified: () -> Unit) {
        // Skip if no voiceprint enrolled
        if (!isVoiceprintEnrolled) {
            onVerified()
            return
        }

        // Check if current verification is still valid
        if (isVoiceprintVerificationCurrent() && getDecayedConfidence() >= 0.60f) {
            onVerified()
            return
        }

        // Need re-verification
        performVoiceprintReVerification { verified, confidence ->
            if (verified) {
                onVerified()
            } else {
                speakFeedback("Voice verification failed. Operation cancelled.")
            }
        }
    }

    /**
     * Start background continuous auth monitoring.
     * Checks verification status periodically during active sessions.
     */
    private fun startContinuousAuthMonitor() {
        if (!isVoiceprintEnrolled) return

        // Load saved state
        lastVoiceprintVerification = cachePrefs.getLong(PREF_LAST_VOICEPRINT_VERIFY, 0L)
        voiceprintConfidence = cachePrefs.getFloat(PREF_VOICEPRINT_CONFIDENCE, 0f)
        reVerifyIntervalMs = cachePrefs.getLong(PREF_REVERIFY_INTERVAL, 5 * 60 * 1000L)

        continuousAuthHandler = android.os.Handler(mainLooper)
        continuousAuthRunnable = object : Runnable {
            override fun run() {
                checkContinuousAuth()
                continuousAuthHandler?.postDelayed(this, CONTINUOUS_AUTH_CHECK_INTERVAL_MS)
            }
        }
        continuousAuthHandler?.postDelayed(continuousAuthRunnable!!, CONTINUOUS_AUTH_CHECK_INTERVAL_MS)

        Log.d(TAG, "Continuous auth monitoring started")
    }

    /**
     * Stop continuous auth monitoring.
     */
    private fun stopContinuousAuthMonitor() {
        continuousAuthRunnable?.let { continuousAuthHandler?.removeCallbacks(it) }
        continuousAuthHandler = null
        continuousAuthRunnable = null
    }

    /**
     * Periodic check for continuous auth during active sessions.
     * Prompts for re-verification when interval expires during transcription.
     */
    private fun checkContinuousAuth() {
        if (!isLiveTranscribing && !isAmbientMode) return
        if (!isVoiceprintEnrolled) return

        val elapsed = System.currentTimeMillis() - lastVoiceprintVerification

        if (elapsed > reVerifyIntervalMs) {
            // Verification expired during active session
            Log.d(TAG, "Continuous auth: verification expired, prompting re-verify")

            // For now, just prompt - could implement passive verification later
            if (elapsed > reVerifyIntervalMs * 2) {
                // Way overdue - interrupt session
                speakFeedback("Please say 'verify me' to continue using MDx Vision.")
            }
        } else {
            // Log confidence decay
            val decayed = getDecayedConfidence()
            Log.d(TAG, "Continuous auth: confidence=$decayed, time until re-verify=${(reVerifyIntervalMs - elapsed) / 1000}s")
        }
    }

    /**
     * Set custom re-verification interval.
     * Voice command: "set verify interval [N] minutes"
     */
    private fun setReVerifyInterval(minutes: Int) {
        if (minutes < 1 || minutes > 60) {
            speakFeedback("Interval must be between 1 and 60 minutes.")
            return
        }

        reVerifyIntervalMs = minutes * 60 * 1000L

        // Save to prefs
        cachePrefs.edit()
            .putLong(PREF_REVERIFY_INTERVAL, reVerifyIntervalMs)
            .apply()

        // Update server
        if (deviceId.isNotEmpty()) {
            Thread {
                try {
                    val request = Request.Builder()
                        .url("$EHR_PROXY_URL/api/v1/auth/voiceprint/$deviceId/interval?interval_seconds=${minutes * 60}")
                        .put(okhttp3.RequestBody.create(null, ""))
                        .build()

                    httpClient.newCall(request).execute()
                    Log.d(TAG, "Re-verify interval updated on server: $minutes minutes")
                } catch (e: Exception) {
                    Log.e(TAG, "Error updating re-verify interval: ${e.message}")
                }
            }.start()
        }

        speakFeedback("Verification interval set to $minutes minutes.")
    }

    /**
     * Show continuous auth verification status.
     * Voice command: "verification status"
     */
    private fun showVerificationStatus() {
        if (!isVoiceprintEnrolled) {
            speakFeedback("Voiceprint not enrolled. No verification required.")
            return
        }

        val elapsed = (System.currentTimeMillis() - lastVoiceprintVerification) / 1000
        val decayed = getDecayedConfidence()
        val timeUntil = maxOf(0L, (reVerifyIntervalMs / 1000) - elapsed)

        val status = buildString {
            append("Verification status. ")
            if (lastVoiceprintVerification > 0L) {
                append("Last verified ${elapsed / 60} minutes ago. ")
                append("Confidence ${(decayed * 100).toInt()} percent. ")
                if (timeUntil > 0) {
                    append("Next verification in ${timeUntil / 60} minutes.")
                } else {
                    append("Re-verification required.")
                }
            } else {
                append("No verification on record. Please say 'verify me' to authenticate.")
            }
        }

        speakFeedback(status)
    }

    /**
     * Handle manual re-verification request.
     * Voice commands: "verify me", "verify my voice"
     */
    private fun handleVerifyMeCommand() {
        if (!isVoiceprintEnrolled) {
            speakFeedback("Voiceprint not enrolled. Say 'enroll my voice' to set up voiceprint authentication.")
            return
        }

        speakFeedback("Starting voice verification.")

        verifyVoiceprintForOperation("Manual verification") { verified ->
            if (verified) {
                lastVoiceprintVerification = System.currentTimeMillis()
                voiceprintConfidence = 0.85f

                // Save to prefs
                cachePrefs.edit()
                    .putLong(PREF_LAST_VOICEPRINT_VERIFY, lastVoiceprintVerification)
                    .putFloat(PREF_VOICEPRINT_CONFIDENCE, voiceprintConfidence)
                    .apply()

                val confidencePercent = (voiceprintConfidence * 100).toInt()
                speakFeedback("Voice verified. Confidence $confidencePercent percent.")
            } else {
                speakFeedback("Voice verification failed.")
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // AI CLINICAL CO-PILOT METHODS (Feature #78)
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Activate copilot mode for conversational AI assistance.
     * Voice commands: "hey copilot", "ask copilot"
     */
    private fun activateCopilotMode() {
        isCopilotActive = true
        speakFeedback("Copilot ready. What's your question?")
        Log.d(TAG, "Copilot mode activated")
    }

    /**
     * Send a question to the clinical copilot.
     * Includes patient context and conversation history.
     */
    private fun sendCopilotQuestion(question: String) {
        if (question.isBlank()) {
            speakFeedback("Please ask a question.")
            return
        }

        lastCopilotQuestion = question
        speakFeedback("Thinking...")

        // Build conversation history for context
        val historyArray = org.json.JSONArray()
        copilotConversationHistory.takeLast(6).forEach { (role, content) ->
            historyArray.put(JSONObject().apply {
                put("role", role)
                put("content", content)
            })
        }

        // Build patient context if available
        val patientContext = if (currentPatientData != null) {
            JSONObject().apply {
                put("name", currentPatientData?.optString("name", "Unknown"))
                put("age", currentPatientData?.optString("age", ""))
                put("gender", currentPatientData?.optString("gender", ""))
                put("chief_complaint", extractedEntities.chiefComplaints.firstOrNull() ?: "")
                put("conditions", currentPatientData?.optJSONArray("conditions")?.let { arr ->
                    (0 until arr.length()).map { arr.getJSONObject(it).optString("display", "") }.take(5).joinToString(", ")
                } ?: "")
                put("medications", currentPatientData?.optJSONArray("medications")?.let { arr ->
                    (0 until arr.length()).map { arr.getJSONObject(it).optString("display", "") }.take(5).joinToString(", ")
                } ?: "")
                put("allergies", currentPatientData?.optJSONArray("allergies")?.let { arr ->
                    (0 until arr.length()).map { arr.getJSONObject(it).optString("display", "") }.take(5).joinToString(", ")
                } ?: "")
            }
        } else null

        // Build request
        val requestBody = JSONObject().apply {
            put("message", question)
            if (patientContext != null) put("patient_context", patientContext)
            put("conversation_history", historyArray)
            put("include_actions", true)
        }

        // POST to copilot endpoint
        val url = "$EHR_PROXY_URL/api/v1/copilot/chat"
        val request = Request.Builder()
            .url(url)
            .header("Content-Type", "application/json")
            .header("X-Device-ID", deviceId)
            .post(requestBody.toString().toRequestBody("application/json".toMediaType()))
            .build()

        httpClient.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                runOnUiThread {
                    Log.e(TAG, "Copilot request failed", e)
                    speakFeedback("Sorry, couldn't reach the copilot. Please try again.")
                }
            }

            override fun onResponse(call: Call, response: Response) {
                response.use { resp ->
                    if (resp.isSuccessful) {
                        val body = resp.body?.string()
                        if (body != null) {
                            val json = JSONObject(body)
                            runOnUiThread { handleCopilotResponse(json) }
                        }
                    } else {
                        runOnUiThread {
                            speakFeedback("Copilot error. Please try again.")
                        }
                    }
                }
            }
        })

        Log.d(TAG, "Copilot question sent: $question")
    }

    /**
     * Handle copilot response - speak it and track conversation.
     */
    private fun handleCopilotResponse(response: JSONObject) {
        val responseText = response.optString("response", "")
        val suggestions = response.optJSONArray("suggestions")
        val actions = response.optJSONArray("actions")

        if (responseText.isBlank()) {
            speakFeedback("No response from copilot.")
            return
        }

        // Add to conversation history
        copilotConversationHistory.add(Pair("user", lastCopilotQuestion))
        copilotConversationHistory.add(Pair("assistant", responseText))

        // Trim history to last 10 exchanges
        while (copilotConversationHistory.size > 20) {
            copilotConversationHistory.removeAt(0)
        }

        // Speak the response
        speakFeedback(responseText)

        // Log suggestions if any
        if (suggestions != null && suggestions.length() > 0) {
            Log.d(TAG, "Copilot suggestions: ${(0 until suggestions.length()).map { suggestions.getString(it) }}")
        }

        // Handle actionable suggestions
        if (actions != null && actions.length() > 0) {
            val actionList = (0 until actions.length()).map { actions.getJSONObject(it) }
            actionList.forEach { action ->
                val actionType = action.optString("action_type", "")
                val label = action.optString("label", "")
                val command = action.optString("command", "")

                when (actionType) {
                    "order" -> {
                        // Queue action prompt after main response
                        android.os.Handler(mainLooper).postDelayed({
                            speakFeedback("Say '$command' to $label")
                        }, 3000)
                    }
                    "calculate" -> {
                        android.os.Handler(mainLooper).postDelayed({
                            speakFeedback("Say '$command' to $label")
                        }, 3000)
                    }
                }
            }
        }

        Log.d(TAG, "Copilot response handled: ${responseText.take(100)}...")
    }

    /**
     * Send a follow-up question using context from previous response.
     */
    private fun sendCopilotFollowUp(followUp: String) {
        if (copilotConversationHistory.isEmpty()) {
            speakFeedback("No previous copilot conversation. Ask a question first.")
            return
        }
        sendCopilotQuestion(followUp)
    }

    /**
     * Clear copilot conversation history.
     */
    private fun clearCopilotHistory() {
        copilotConversationHistory.clear()
        lastCopilotQuestion = ""
        isCopilotActive = false
        speakFeedback("Copilot conversation cleared.")
        Log.d(TAG, "Copilot history cleared")
    }

    // ============ Multi-Turn Clinical Reasoning (Feature #95 - Jarvis Wave 1) ============

    /**
     * Send question to copilot in teaching mode.
     * Provides clinical education-style explanations with reasoning steps.
     */
    private fun sendCopilotTeachingMode(question: String) {
        if (question.isBlank()) {
            speakFeedback("Please ask what you'd like explained.")
            return
        }

        lastCopilotQuestion = question
        speakFeedback("Let me explain...")

        // Build patient context if available
        val patientContext = buildPatientContextJson()

        // Build conversation history
        val historyArray = org.json.JSONArray()
        copilotConversationHistory.takeLast(6).forEach { (role, content) ->
            historyArray.put(JSONObject().apply {
                put("role", role)
                put("content", content)
            })
        }

        // Build request for teaching mode
        val requestBody = JSONObject().apply {
            put("message", question)
            if (patientContext != null) put("patient_context", patientContext)
            put("conversation_history", historyArray)
        }

        // POST to teach endpoint
        val url = "$EHR_PROXY_URL/api/v1/copilot/teach"
        val request = Request.Builder()
            .url(url)
            .header("Content-Type", "application/json")
            .header("X-Device-ID", deviceId)
            .post(requestBody.toString().toRequestBody("application/json".toMediaType()))
            .build()

        httpClient.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                runOnUiThread {
                    Log.e(TAG, "Teaching mode request failed", e)
                    speakFeedback("Sorry, couldn't get the explanation. Try again.")
                }
            }

            override fun onResponse(call: Call, response: Response) {
                response.use { resp ->
                    if (resp.isSuccessful) {
                        val body = resp.body?.string()
                        if (body != null) {
                            val json = JSONObject(body)
                            runOnUiThread { handleMultiTurnResponse(json, "teaching") }
                        }
                    } else {
                        runOnUiThread {
                            speakFeedback("Teaching mode unavailable. Try again.")
                        }
                    }
                }
            }
        })

        Log.d(TAG, "Teaching mode question sent: $question")
    }

    /**
     * Send question to copilot for a second opinion / challenge.
     * Provides alternative diagnoses and considerations.
     */
    private fun sendCopilotSecondOpinion(question: String) {
        if (question.isBlank()) {
            speakFeedback("Please describe what you'd like a second opinion on.")
            return
        }

        lastCopilotQuestion = question
        speakFeedback("Getting second opinion...")

        // Build patient context if available
        val patientContext = buildPatientContextJson()

        // Build conversation history
        val historyArray = org.json.JSONArray()
        copilotConversationHistory.takeLast(6).forEach { (role, content) ->
            historyArray.put(JSONObject().apply {
                put("role", role)
                put("content", content)
            })
        }

        // Build request for challenge mode
        val requestBody = JSONObject().apply {
            put("message", question)
            if (patientContext != null) put("patient_context", patientContext)
            put("conversation_history", historyArray)
        }

        // POST to challenge endpoint
        val url = "$EHR_PROXY_URL/api/v1/copilot/challenge"
        val request = Request.Builder()
            .url(url)
            .header("Content-Type", "application/json")
            .header("X-Device-ID", deviceId)
            .post(requestBody.toString().toRequestBody("application/json".toMediaType()))
            .build()

        httpClient.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                runOnUiThread {
                    Log.e(TAG, "Second opinion request failed", e)
                    speakFeedback("Sorry, couldn't get second opinion. Try again.")
                }
            }

            override fun onResponse(call: Call, response: Response) {
                response.use { resp ->
                    if (resp.isSuccessful) {
                        val body = resp.body?.string()
                        if (body != null) {
                            val json = JSONObject(body)
                            runOnUiThread { handleMultiTurnResponse(json, "second_opinion") }
                        }
                    } else {
                        runOnUiThread {
                            speakFeedback("Second opinion unavailable. Try again.")
                        }
                    }
                }
            }
        })

        Log.d(TAG, "Second opinion question sent: $question")
    }

    /**
     * Ask copilot for clarifying questions.
     * Returns questions to help refine the clinical picture.
     */
    private fun sendCopilotClarifyMode(question: String) {
        speakFeedback("Considering what to ask...")

        // Build patient context if available
        val patientContext = buildPatientContextJson()

        // Build conversation history
        val historyArray = org.json.JSONArray()
        copilotConversationHistory.takeLast(6).forEach { (role, content) ->
            historyArray.put(JSONObject().apply {
                put("role", role)
                put("content", content)
            })
        }

        // Build request for clarify mode
        val requestBody = JSONObject().apply {
            put("message", question.ifBlank { "What additional information would help clarify this case?" })
            put("mode", "clarify")
            if (patientContext != null) put("patient_context", patientContext)
            put("conversation_history", historyArray)
        }

        // POST to reason endpoint with clarify mode
        val url = "$EHR_PROXY_URL/api/v1/copilot/reason"
        val request = Request.Builder()
            .url(url)
            .header("Content-Type", "application/json")
            .header("X-Device-ID", deviceId)
            .post(requestBody.toString().toRequestBody("application/json".toMediaType()))
            .build()

        httpClient.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                runOnUiThread {
                    Log.e(TAG, "Clarify mode request failed", e)
                    speakFeedback("Sorry, couldn't get clarifying questions. Try again.")
                }
            }

            override fun onResponse(call: Call, response: Response) {
                response.use { resp ->
                    if (resp.isSuccessful) {
                        val body = resp.body?.string()
                        if (body != null) {
                            val json = JSONObject(body)
                            runOnUiThread { handleMultiTurnResponse(json, "clarify") }
                        }
                    } else {
                        runOnUiThread {
                            speakFeedback("Clarify mode unavailable. Try again.")
                        }
                    }
                }
            }
        })

        Log.d(TAG, "Clarify mode question sent: $question")
    }

    /**
     * Build patient context JSON for multi-turn reasoning requests.
     */
    private fun buildPatientContextJson(): JSONObject? {
        return if (currentPatientData != null) {
            JSONObject().apply {
                put("name", currentPatientData?.optString("name", "Unknown"))
                put("age", currentPatientData?.optString("age", ""))
                put("gender", currentPatientData?.optString("gender", ""))
                put("chief_complaint", extractedEntities.chiefComplaints.firstOrNull() ?: "")
                put("conditions", currentPatientData?.optJSONArray("conditions")?.let { arr ->
                    (0 until arr.length()).map { arr.getJSONObject(it).optString("display", "") }.take(5).joinToString(", ")
                } ?: "")
                put("medications", currentPatientData?.optJSONArray("medications")?.let { arr ->
                    (0 until arr.length()).map { arr.getJSONObject(it).optString("display", "") }.take(5).joinToString(", ")
                } ?: "")
                put("allergies", currentPatientData?.optJSONArray("allergies")?.let { arr ->
                    (0 until arr.length()).map { arr.getJSONObject(it).optString("display", "") }.take(5).joinToString(", ")
                } ?: "")
            }
        } else null
    }

    /**
     * Handle response from multi-turn reasoning endpoints.
     */
    private fun handleMultiTurnResponse(response: JSONObject, mode: String) {
        val responseText = response.optString("response", "")
        val reasoning = response.optString("reasoning", "")
        val alternativesArray = response.optJSONArray("alternatives")
        val questionsArray = response.optJSONArray("clarifying_questions")

        if (responseText.isBlank()) {
            speakFeedback("No response received.")
            return
        }

        // Add to conversation history
        copilotConversationHistory.add(Pair("user", lastCopilotQuestion))
        copilotConversationHistory.add(Pair("assistant", responseText))

        // Trim history to last 10 exchanges
        while (copilotConversationHistory.size > 20) {
            copilotConversationHistory.removeAt(0)
        }

        // Speak the main response
        speakFeedback(responseText)

        // For teaching mode, offer to explain reasoning
        if (mode == "teaching" && reasoning.isNotBlank()) {
            android.os.Handler(mainLooper).postDelayed({
                speakFeedback("Say 'tell me more' for the full reasoning.")
            }, 4000)
        }

        // For second opinion, mention alternatives if present
        if (mode == "second_opinion" && alternativesArray != null && alternativesArray.length() > 0) {
            val altCount = alternativesArray.length()
            android.os.Handler(mainLooper).postDelayed({
                speakFeedback("$altCount alternative diagnoses to consider. Say 'tell me more' for details.")
            }, 4000)
        }

        // For clarify mode, speak the questions
        if (mode == "clarify" && questionsArray != null && questionsArray.length() > 0) {
            val questions = (0 until questionsArray.length()).map { questionsArray.getString(it) }
            android.os.Handler(mainLooper).postDelayed({
                speakFeedback("Questions to consider: ${questions.take(3).joinToString(". ")}")
            }, 4000)
        }

        Log.d(TAG, "Multi-turn response handled (mode=$mode): ${responseText.take(100)}...")
    }

    // ═══════════════════════════════════════════════════════════════════════════════
    // RACIAL MEDICINE AWARENESS (Feature #79) - Addressing "white default" in medicine
    // ═══════════════════════════════════════════════════════════════════════════════

    /**
     * Set patient Fitzpatrick skin type (I-VI).
     * Used for pulse oximeter accuracy alerts and skin assessment guidance.
     */
    private fun setSkinType(type: String) {
        currentPatientSkinType = type
        val typeDesc = when (type) {
            "I" -> "Type 1 - Very light, always burns"
            "II" -> "Type 2 - Light, burns easily"
            "III" -> "Type 3 - Medium, burns moderately"
            "IV" -> "Type 4 - Olive, burns minimally"
            "V" -> "Type 5 - Brown, rarely burns"
            "VI" -> "Type 6 - Dark brown/black, never burns"
            else -> type
        }
        speakFeedback("Skin type set to $typeDesc")
        Toast.makeText(this, "Skin type: $type", Toast.LENGTH_SHORT).show()
        Log.d(TAG, "Skin type set to $type")

        // Automatically fetch alerts for types V and VI
        if (type in listOf("V", "VI")) {
            fetchRacialMedicineAlerts()
        }
    }

    /**
     * Set patient ancestry for pharmacogenomics guidance.
     */
    private fun setPatientAncestry(ancestry: String) {
        currentPatientAncestry = ancestry
        val displayName = ancestry.replace("_", " ").replaceFirstChar { it.uppercase() }
        speakFeedback("Ancestry set to $displayName. Checking medication considerations.")
        Toast.makeText(this, "Ancestry: $displayName", Toast.LENGTH_SHORT).show()
        Log.d(TAG, "Patient ancestry set to $ancestry")

        // Fetch medication considerations
        fetchMedicationAncestryConsiderations(ancestry)
    }

    /**
     * Show pulse oximeter accuracy warning for darker skin.
     */
    private fun showPulseOxWarning() {
        val skinType = currentPatientSkinType
        if (skinType == null) {
            speakFeedback("No skin type set. Say set skin type followed by a number 1 through 6.")
            return
        }

        val warning = when (skinType) {
            "V", "VI" -> {
                """
                |⚠️ PULSE OXIMETER ACCURACY ALERT
                |
                |Patient Skin Type: $skinType (melanin-rich)
                |
                |CLINICAL IMPLICATIONS:
                |• SpO2 readings may overestimate by 1-4%
                |• A reading of 94% may actually be 90-93%
                |• Consider arterial blood gas for critical decisions
                |
                |FDA GUIDANCE (Jan 2025):
                |• Pulse oximeters less accurate on darker skin
                |• 3x more likely to miss hypoxemia
                |
                |RECOMMENDATIONS:
                |• Use ABG for precise oxygen assessment
                |• Monitor trends rather than single values
                |• Consider lower SpO2 thresholds for intervention
                |• Document skin type in chart
                """.trimMargin()
            }
            "IV" -> {
                """
                |ℹ️ PULSE OXIMETER NOTE
                |
                |Patient Skin Type: $skinType (olive)
                |
                |• Moderate melanin may affect accuracy
                |• SpO2 overestimation possible: 0.5-2%
                |• Use clinical judgment with borderline readings
                |• Consider ABG if SpO2 94-96% with symptoms
                """.trimMargin()
            }
            else -> {
                """
                |✓ PULSE OXIMETER
                |
                |Patient Skin Type: $skinType
                |
                |Standard pulse oximetry accuracy expected.
                |No specific melanin-related adjustments needed.
                """.trimMargin()
            }
        }

        showDataOverlay("Pulse Ox Warning", warning)
        if (skinType in listOf("V", "VI")) {
            speakFeedback("Warning: Pulse oximeter may overestimate oxygen saturation by up to 4 percent on melanin-rich skin. Consider arterial blood gas for critical decisions.")
        }
    }

    /**
     * Show skin assessment guidance for current skin type.
     */
    private fun showSkinAssessmentGuidance() {
        val skinType = currentPatientSkinType
        if (skinType == null) {
            speakFeedback("No skin type set. Say set skin type followed by a number 1 through 6.")
            return
        }

        // Fetch guidance from backend
        Thread {
            try {
                val url = java.net.URL("$EHR_PROXY_URL/api/v1/racial-medicine/skin-guidance?skin_type=$skinType")
                val connection = url.openConnection() as java.net.HttpURLConnection
                connection.requestMethod = "GET"
                connection.setRequestProperty("Accept", "application/json")

                if (connection.responseCode == 200) {
                    val response = connection.inputStream.bufferedReader().readText()
                    skinAssessmentGuidance = JSONObject(response)

                    runOnUiThread {
                        displaySkinAssessmentGuidance(skinAssessmentGuidance!!)
                    }
                } else {
                    runOnUiThread {
                        showDefaultSkinGuidance(skinType)
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Failed to fetch skin guidance: ${e.message}")
                runOnUiThread {
                    showDefaultSkinGuidance(skinType)
                }
            }
        }.start()
    }

    /**
     * Display skin assessment guidance from backend or default.
     */
    private fun displaySkinAssessmentGuidance(guidance: JSONObject) {
        val sb = StringBuilder()
        sb.appendLine("🔬 SKIN ASSESSMENT GUIDANCE")
        sb.appendLine("Fitzpatrick Type: ${guidance.optString("skin_type", currentPatientSkinType)}")
        sb.appendLine()

        val assessments = guidance.optJSONObject("assessments")
        assessments?.keys()?.forEach { condition ->
            val detail = assessments.optJSONObject(condition)
            sb.appendLine("━━━ ${condition.uppercase()} ━━━")
            sb.appendLine("Look for: ${detail?.optString("look_for", "N/A")}")
            sb.appendLine("Technique: ${detail?.optString("technique", "N/A")}")
            sb.appendLine()
        }

        showDataOverlay("Skin Assessment", sb.toString())
        speakFeedback("Skin assessment guidance displayed for type ${currentPatientSkinType}.")
    }

    /**
     * Default skin guidance when backend unavailable.
     */
    private fun showDefaultSkinGuidance(skinType: String) {
        val isMelaninRich = skinType in listOf("IV", "V", "VI")
        val guidance = if (isMelaninRich) {
            """
            |🔬 SKIN ASSESSMENT - MELANIN-RICH SKIN
            |Fitzpatrick Type: $skinType
            |
            |━━━ CYANOSIS ━━━
            |Look for: Gray or ashen hue on mucous membranes
            |Check: Conjunctivae, oral mucosa, nail beds, palms
            |Note: Blue discoloration harder to detect on skin
            |
            |━━━ JAUNDICE ━━━
            |Look for: Yellow in sclera and hard palate
            |Check: Palms, soles may show yellow tinge
            |Note: Skin jaundice may appear green-brown
            |
            |━━━ PALLOR ━━━
            |Look for: Ashen gray or loss of red undertones
            |Check: Lower eyelid conjunctivae, oral mucosa, palms
            |Note: Skin may appear dull rather than pale
            |
            |━━━ ERYTHEMA ━━━
            |Look for: Increased warmth, edema, tenderness
            |Check: Palpate for heat; compare to unaffected areas
            |Note: Redness may not be visible; rely on touch
            |
            |━━━ PETECHIAE/BRUISING ━━━
            |Look for: Dark purple or black discoloration
            |Check: Conjunctivae, oral mucosa for petechiae
            |Note: Use tangential lighting at skin surface
            """.trimMargin()
        } else {
            """
            |🔬 SKIN ASSESSMENT
            |Fitzpatrick Type: $skinType
            |
            |Standard visual assessment techniques apply.
            |
            |━━━ CYANOSIS ━━━
            |Look for: Bluish discoloration of skin/mucosa
            |
            |━━━ JAUNDICE ━━━
            |Look for: Yellowing of skin and sclera
            |
            |━━━ PALLOR ━━━
            |Look for: Pale or washed-out skin color
            |
            |━━━ ERYTHEMA ━━━
            |Look for: Redness, warmth, swelling
            """.trimMargin()
        }

        showDataOverlay("Skin Assessment", guidance)
        if (isMelaninRich) {
            speakFeedback("Skin assessment guidance for melanin-rich skin. Check mucous membranes and use palpation for erythema.")
        }
    }

    /**
     * Show medication considerations based on ancestry.
     */
    private fun showMedicationAncestryGuidance() {
        val ancestry = currentPatientAncestry
        if (ancestry == null) {
            speakFeedback("No ancestry set. Say set ancestry followed by the ancestry group.")
            return
        }
        fetchMedicationAncestryConsiderations(ancestry)
    }

    /**
     * Fetch medication considerations from backend.
     */
    private fun fetchMedicationAncestryConsiderations(ancestry: String) {
        Thread {
            try {
                val url = java.net.URL("$EHR_PROXY_URL/api/v1/racial-medicine/medication-considerations/$ancestry")
                val connection = url.openConnection() as java.net.HttpURLConnection
                connection.requestMethod = "GET"

                if (connection.responseCode == 200) {
                    val response = connection.inputStream.bufferedReader().readText()
                    val json = JSONObject(response)

                    runOnUiThread {
                        displayMedicationConsiderations(ancestry, json)
                    }
                } else {
                    runOnUiThread {
                        showDefaultMedicationConsiderations(ancestry)
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Failed to fetch medication considerations: ${e.message}")
                runOnUiThread {
                    showDefaultMedicationConsiderations(ancestry)
                }
            }
        }.start()
    }

    /**
     * Display medication considerations.
     */
    private fun displayMedicationConsiderations(ancestry: String, json: JSONObject) {
        val sb = StringBuilder()
        val displayName = ancestry.replace("_", " ").replaceFirstChar { it.uppercase() }
        sb.appendLine("💊 PHARMACOGENOMIC CONSIDERATIONS")
        sb.appendLine("Ancestry: $displayName")
        sb.appendLine()

        val considerations = json.optJSONArray("considerations")
        considerations?.let {
            for (i in 0 until it.length()) {
                val item = it.getJSONObject(i)
                sb.appendLine("━━━ ${item.optString("medication_class", "Unknown")} ━━━")
                sb.appendLine(item.optString("guidance", ""))
                sb.appendLine()
            }
        }

        if (considerations == null || considerations.length() == 0) {
            sb.appendLine("No specific pharmacogenomic considerations on file.")
            sb.appendLine("Standard dosing guidelines apply.")
        }

        showDataOverlay("Medication Guidance", sb.toString())
    }

    /**
     * Default medication considerations when backend unavailable.
     */
    private fun showDefaultMedicationConsiderations(ancestry: String) {
        val displayName = ancestry.replace("_", " ").replaceFirstChar { it.uppercase() }
        val guidance = when (ancestry) {
            "african" -> """
                |💊 PHARMACOGENOMIC CONSIDERATIONS
                |Ancestry: $displayName
                |
                |━━━ ACE INHIBITORS ━━━
                |• May be less effective as monotherapy for HTN
                |• Consider thiazide or CCB as first-line
                |• Or use ACE + thiazide combination
                |
                |━━━ BETA-BLOCKERS ━━━
                |• Reduced efficacy for hypertension
                |• Still effective for heart failure, CAD
                |• Consider higher doses if needed for BP
                |
                |━━━ CLOPIDOGREL ━━━
                |• CYP2C19 variants more common
                |• Consider genetic testing for ACS/PCI
                |• Ticagrelor may be preferred alternative
                """.trimMargin()

            "east_asian", "south_asian" -> """
                |💊 PHARMACOGENOMIC CONSIDERATIONS
                |Ancestry: $displayName
                |
                |━━━ WARFARIN ━━━
                |• Lower dose requirements common
                |• Start at reduced dose (2-3mg)
                |• VKORC1 variants affect sensitivity
                |
                |━━━ CLOPIDOGREL ━━━
                |• Higher CYP2C19 poor metabolizer rates
                |• Consider prasugrel or ticagrelor
                |• Genetic testing recommended for ACS
                |
                |━━━ STATINS ━━━
                |• May need lower doses for efficacy
                |• Higher myopathy risk at standard doses
                |• Start rosuvastatin at 5mg
                """.trimMargin()

            else -> """
                |💊 PHARMACOGENOMIC CONSIDERATIONS
                |Ancestry: $displayName
                |
                |No specific population-level considerations.
                |
                |Standard dosing guidelines apply.
                |Consider individual genetic testing if available.
                """.trimMargin()
        }

        showDataOverlay("Medication Guidance", guidance)
        speakFeedback("Medication considerations for $displayName ancestry displayed.")
    }

    /**
     * Fetch racial medicine alerts from backend.
     */
    private fun fetchRacialMedicineAlerts() {
        val skinType = currentPatientSkinType ?: return
        val patientId = currentPatientData?.optString("patient_id") ?: return

        Thread {
            try {
                val url = java.net.URL("$EHR_PROXY_URL/api/v1/racial-medicine/alerts")
                val connection = url.openConnection() as java.net.HttpURLConnection
                connection.requestMethod = "POST"
                connection.setRequestProperty("Content-Type", "application/json")
                connection.doOutput = true

                val requestBody = JSONObject().apply {
                    put("patient_id", patientId)
                    put("skin_type", skinType)
                    currentPatientAncestry?.let { put("ancestry", it) }
                }

                connection.outputStream.bufferedWriter().use { it.write(requestBody.toString()) }

                if (connection.responseCode == 200) {
                    val response = connection.inputStream.bufferedReader().readText()
                    val json = JSONObject(response)
                    val alerts = json.optJSONArray("alerts")

                    runOnUiThread {
                        racialMedicineAlerts.clear()
                        alerts?.let {
                            for (i in 0 until it.length()) {
                                racialMedicineAlerts.add(it.getJSONObject(i))
                            }
                        }
                        Log.d(TAG, "Fetched ${racialMedicineAlerts.size} racial medicine alerts")
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Failed to fetch racial medicine alerts: ${e.message}")
            }
        }.start()
    }

    /**
     * Show all racial medicine alerts.
     */
    private fun showRacialMedicineAlerts() {
        if (racialMedicineAlerts.isEmpty()) {
            fetchRacialMedicineAlerts()
            speakFeedback("Checking for racial medicine alerts. Please wait.")
            android.os.Handler(mainLooper).postDelayed({
                displayRacialMedicineAlerts()
            }, 1500)
        } else {
            displayRacialMedicineAlerts()
        }
    }

    private fun displayRacialMedicineAlerts() {
        if (racialMedicineAlerts.isEmpty()) {
            showDataOverlay("Racial Medicine Alerts", "No alerts for current patient.\n\nSet skin type and ancestry to enable alerts.")
            return
        }

        val sb = StringBuilder()
        sb.appendLine("⚕️ RACIAL MEDICINE ALERTS")
        sb.appendLine("Addressing healthcare disparities")
        sb.appendLine()

        racialMedicineAlerts.forEach { alert ->
            val severity = alert.optString("severity", "info")
            val icon = when (severity) {
                "critical" -> "🔴"
                "warning" -> "🟡"
                else -> "🔵"
            }
            sb.appendLine("$icon ${alert.optString("title", "Alert")}")
            sb.appendLine(alert.optString("message", ""))
            sb.appendLine("→ ${alert.optString("recommendation", "")}")
            sb.appendLine()
        }

        showDataOverlay("Equity Alerts", sb.toString())
        speakFeedback("${racialMedicineAlerts.size} racial medicine alerts displayed.")
    }

    /**
     * Show maternal mortality risk alert.
     */
    private fun showMaternalRiskAlert() {
        val ancestry = currentPatientAncestry
        val alert = if (ancestry == "african") {
            """
            |🚨 MATERNAL MORTALITY RISK ALERT
            |
            |Patient ancestry: African American
            |
            |CRITICAL DATA:
            |• Black women 3-4x higher maternal mortality
            |• Risk persists across all income/education levels
            |• Leading causes: Cardiovascular, cardiomyopathy,
            |  hemorrhage, preeclampsia/eclampsia
            |
            |HIGH-RISK SIGNS - ESCALATE IMMEDIATELY:
            |• Headache unrelieved by medication
            |• Chest pain or shortness of breath
            |• Swelling of face or hands
            |• Visual changes
            |• Fever or chills postpartum
            |• Heavy bleeding (soaking pad hourly)
            |
            |RECOMMENDATIONS:
            |• Lower threshold for intervention
            |• Believe patient-reported symptoms
            |• Consider implicit bias in assessment
            |• Close postpartum follow-up
            |• Screen for cardiomyopathy if symptomatic
            """.trimMargin()
        } else {
            """
            |ℹ️ MATERNAL HEALTH
            |
            |No elevated risk based on current ancestry data.
            |
            |Standard obstetric monitoring applies.
            |
            |Always be alert to warning signs:
            |• Severe headache
            |• Visual changes
            |• Chest pain
            |• Heavy bleeding
            |• Fever
            """.trimMargin()
        }

        showDataOverlay("Maternal Risk", alert)
        if (ancestry == "african") {
            speakFeedback("Maternal mortality alert. Black women have 3 to 4 times higher risk. Review warning signs.")
        }
    }

    /**
     * Show sickle cell pain crisis protocol.
     */
    private fun showSickleCellProtocol() {
        val protocol = """
            |🩸 SICKLE CELL PAIN CRISIS PROTOCOL
            |
            |GOAL: Analgesia within 60 minutes of arrival
            |
            |IMMEDIATE ACTIONS:
            |1. Triage as urgent - do not delay for labs
            |2. IV access and fluids
            |3. Pain assessment using patient's reported level
            |4. Administer analgesia per protocol
            |
            |PAIN MANAGEMENT:
            |• Patient's home opioid dose as baseline
            |• IV morphine or hydromorphone preferred
            |• Reassess pain q15-30 min
            |• Do NOT undertreat due to bias concerns
            |
            |⚠️ PAIN BIAS REMINDER:
            |Studies show sickle cell patients wait longer
            |and receive less analgesia than other pain crises.
            |Trust the patient's pain report.
            |
            |WORKUP:
            |• CBC with reticulocyte count
            |• CMP, LDH, bilirubin
            |• Type and screen if severe
            |• Chest X-ray if fever or respiratory symptoms
            |
            |ADMIT CRITERIA:
            |• Severe pain uncontrolled in ED
            |• Fever >38.5°C
            |• Acute chest syndrome
            |• Neurologic symptoms
            |• Aplastic crisis
            """.trimMargin()

        showDataOverlay("Sickle Cell Protocol", protocol)
        speakFeedback("Sickle cell pain crisis protocol. Goal: analgesia within 60 minutes. Trust patient's pain report.")
    }

    // ═══════════════════════════════════════════════════════════════════════════════
    // CULTURAL CARE PREFERENCES (Feature #80) - Religious/cultural healthcare needs
    // ═══════════════════════════════════════════════════════════════════════════════

    /**
     * Set patient religion for cultural care.
     */
    private fun setPatientReligion(religion: String) {
        if (culturalCarePreferences == null) {
            culturalCarePreferences = JSONObject()
        }
        culturalCarePreferences?.put("religion", religion)
        val displayName = religion.replace("_", " ").replaceFirstChar { it.uppercase() }
        speakFeedback("Religion set to $displayName. Loading care preferences.")
        Toast.makeText(this, "Religion: $displayName", Toast.LENGTH_SHORT).show()
        Log.d(TAG, "Patient religion set to $religion")

        // Fetch religious guidance
        fetchReligiousGuidance(religion)
    }

    /**
     * Fetch religious care guidance from backend.
     */
    private fun fetchReligiousGuidance(religion: String) {
        Thread {
            try {
                val url = java.net.URL("$EHR_PROXY_URL/api/v1/cultural-care/religious-guidance/$religion")
                val connection = url.openConnection() as java.net.HttpURLConnection
                connection.requestMethod = "GET"

                if (connection.responseCode == 200) {
                    val response = connection.inputStream.bufferedReader().readText()
                    religiousGuidance = JSONObject(response)

                    runOnUiThread {
                        displayReligiousGuidance(religiousGuidance!!)
                    }
                } else {
                    runOnUiThread {
                        showDefaultReligiousGuidance(religion)
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Failed to fetch religious guidance: ${e.message}")
                runOnUiThread {
                    showDefaultReligiousGuidance(religion)
                }
            }
        }.start()
    }

    /**
     * Display religious guidance from backend.
     */
    private fun displayReligiousGuidance(guidance: JSONObject) {
        val sb = StringBuilder()
        sb.appendLine("🙏 RELIGIOUS CARE CONSIDERATIONS")
        sb.appendLine("Religion: ${guidance.optString("religion", "Unknown")}")
        sb.appendLine()

        guidance.optJSONArray("considerations")?.let { considerations ->
            for (i in 0 until considerations.length()) {
                sb.appendLine("• ${considerations.getString(i)}")
            }
        }

        showDataOverlay("Religious Care", sb.toString())
        speakFeedback("Religious care guidance displayed.")
    }

    /**
     * Default religious guidance when backend unavailable.
     */
    private fun showDefaultReligiousGuidance(religion: String) {
        val displayName = religion.replace("_", " ").replaceFirstChar { it.uppercase() }
        val guidance = when (religion) {
            "jehovah_witness" -> """
                |🙏 JEHOVAH'S WITNESS CARE
                |
                |🩸 BLOOD PRODUCTS - CRITICAL:
                |• NO whole blood, red cells, white cells, plasma, platelets
                |• Individual conscience items (may accept):
                |  - Albumin, immunoglobulins, clotting factors
                |  - Cell salvage (some accept)
                |  - Hemodilution, heart-lung bypass
                |
                |✓ ALWAYS ACCEPTED:
                |• All non-blood medications
                |• Saline, Ringer's lactate
                |• Volume expanders (non-blood based)
                |• EPO, iron supplementation
                |
                |RECOMMENDATIONS:
                |• Document specific preferences in detail
                |• Have Advance Directive on file
                |• Contact Hospital Liaison Committee
                |• Plan for bloodless surgery techniques
                |• Consider iron optimization preoperatively
                """.trimMargin()

            "islam" -> """
                |🙏 ISLAMIC CARE CONSIDERATIONS
                |
                |🍽️ DIETARY:
                |• Halal food only (no pork, proper slaughter)
                |• Check medications for gelatin, alcohol
                |• Porcine insulin may be accepted if no alternative
                |
                |🌙 RAMADAN:
                |• Fasting dawn to sunset
                |• May skip medications during fast
                |• Discuss which meds are essential
                |• IV medications during fast - consult patient
                |
                |👤 MODESTY:
                |• Same-gender provider preferred
                |• Minimize exposure during exams
                |• Private space for prayer (5x daily)
                |
                |⚰️ END OF LIFE:
                |• Family involvement in decisions
                |• Imam may be requested
                |• Burial within 24 hours preferred
                """.trimMargin()

            "judaism" -> """
                |🙏 JEWISH CARE CONSIDERATIONS
                |
                |🍽️ DIETARY (if observant):
                |• Kosher food requirements
                |• No mixing meat and dairy
                |• No pork or shellfish
                |• Check medication ingredients
                |
                |📅 SABBATH (Friday sunset - Saturday sunset):
                |• May not use electronics
                |• May not sign documents
                |• Pikuach nefesh: life-saving care overrides
                |• Discuss advance consent if needed
                |
                |🙏 RELIGIOUS ITEMS:
                |• Men may wear kippah (head covering)
                |• Tefillin for morning prayers
                |• May request rabbi visit
                |
                |⚰️ END OF LIFE:
                |• No hastening death
                |• Burial usually within 24 hours
                |• Chevra kadisha (burial society)
                """.trimMargin()

            "hinduism" -> """
                |🙏 HINDU CARE CONSIDERATIONS
                |
                |🍽️ DIETARY:
                |• Vegetarian (many adherents)
                |• No beef (cow is sacred)
                |• Some avoid onion and garlic
                |• Fasting days vary by tradition
                |
                |💊 MEDICATIONS:
                |• Check for gelatin (bovine or porcine)
                |• May prefer vegetarian alternatives
                |
                |🙏 PRACTICES:
                |• Prayer and meditation important
                |• May have religious items (mala beads)
                |• Pandit (priest) may be requested
                |
                |⚰️ END OF LIFE:
                |• Family involvement in decisions
                |• Cremation preferred
                |• Last rites by family member
                |• May wish to die at home
                """.trimMargin()

            else -> """
                |🙏 CULTURAL CARE CONSIDERATIONS
                |Religion: $displayName
                |
                |• Ask patient about specific preferences
                |• Dietary restrictions
                |• Modesty requirements
                |• Family involvement in decisions
                |• End-of-life preferences
                |• Religious items or practices
                |
                |Document preferences in chart.
                """.trimMargin()
        }

        showDataOverlay("Religious Care", guidance)
        speakFeedback("$displayName care considerations displayed.")
    }

    /**
     * Show cultural care preferences for current patient.
     */
    private fun showCulturalCarePreferences() {
        if (culturalCarePreferences == null) {
            showDataOverlay("Cultural Care", "No cultural preferences recorded.\n\nSay 'set religion' to add preferences.")
            speakFeedback("No cultural preferences on file. Say set religion to begin.")
            return
        }

        val sb = StringBuilder()
        sb.appendLine("🌍 CULTURAL CARE PREFERENCES")
        sb.appendLine()

        culturalCarePreferences?.let { prefs ->
            prefs.optString("religion", "").takeIf { it.isNotEmpty() }?.let {
                sb.appendLine("Religion: ${it.replace("_", " ").replaceFirstChar { c -> c.uppercase() }}")
            }
            prefs.optString("decision_making_style", "").takeIf { it.isNotEmpty() }?.let {
                sb.appendLine("Decision Making: ${it.replace("_", " ")}")
            }
            prefs.optJSONArray("dietary_restrictions")?.let { diet ->
                if (diet.length() > 0) {
                    sb.appendLine("\nDietary: ${(0 until diet.length()).map { diet.getString(it) }.joinToString(", ")}")
                }
            }
            prefs.optBoolean("same_gender_provider_preferred", false).takeIf { it }?.let {
                sb.appendLine("\n⚠️ Same-gender provider preferred")
            }
        }

        showDataOverlay("Cultural Preferences", sb.toString())
        speakFeedback("Cultural care preferences displayed.")
    }

    /**
     * Show religious preferences.
     */
    private fun showReligiousPreferences() {
        val religion = culturalCarePreferences?.optString("religion")
        if (religion.isNullOrEmpty()) {
            speakFeedback("No religion recorded. Say set religion followed by the faith.")
            return
        }
        showDefaultReligiousGuidance(religion)
    }

    /**
     * Show blood product preferences (especially for JW patients).
     */
    private fun showBloodProductPreferences() {
        val religion = culturalCarePreferences?.optString("religion")
        if (religion == "jehovah_witness") {
            val prefs = """
                |🩸 BLOOD PRODUCT PREFERENCES
                |Religion: Jehovah's Witness
                |
                |REFUSED (Standard JW Position):
                |❌ Whole blood
                |❌ Red blood cells
                |❌ White blood cells
                |❌ Platelets
                |❌ Plasma
                |
                |INDIVIDUAL CONSCIENCE (Ask Patient):
                |❓ Albumin
                |❓ Immunoglobulins
                |❓ Clotting factors (VIII, IX)
                |❓ Cell salvage (intraoperative)
                |❓ Hemodilution
                |❓ Heart-lung bypass
                |❓ Dialysis
                |❓ Epidural blood patch
                |
                |✅ ALWAYS ACCEPTED:
                |• Non-blood volume expanders
                |• Saline, Ringer's lactate
                |• EPO, iron supplementation
                |• All standard medications
                |
                |⚠️ DOCUMENT SPECIFIC PREFERENCES
                |Patient must indicate each item individually.
                |Get Advance Directive signed.
                |Contact Hospital Liaison Committee.
                """.trimMargin()

            showDataOverlay("Blood Preferences", prefs)
            speakFeedback("Blood product preferences for Jehovah's Witness patient. Individual items require specific consent.")
        } else {
            showDataOverlay("Blood Preferences", "No blood product restrictions on file.\n\nStandard consent process applies.")
        }
    }

    /**
     * Show dietary restrictions.
     */
    private fun showDietaryRestrictions() {
        val religion = culturalCarePreferences?.optString("religion", "")
        val restrictions = culturalCarePreferences?.optJSONArray("dietary_restrictions")

        val sb = StringBuilder()
        sb.appendLine("🍽️ DIETARY CONSIDERATIONS")
        sb.appendLine()

        when (religion) {
            "islam" -> {
                sb.appendLine("Religion: Islam")
                sb.appendLine()
                sb.appendLine("FOOD:")
                sb.appendLine("• Halal food required")
                sb.appendLine("• No pork or pork products")
                sb.appendLine("• No alcohol")
                sb.appendLine()
                sb.appendLine("MEDICATIONS - Check for:")
                sb.appendLine("• Gelatin (porcine or bovine)")
                sb.appendLine("• Alcohol-based liquids")
                sb.appendLine("• Porcine-derived insulin")
                sb.appendLine()
                sb.appendLine("Note: Life-saving medications may override")
            }
            "judaism" -> {
                sb.appendLine("Religion: Judaism")
                sb.appendLine()
                sb.appendLine("FOOD (if observant):")
                sb.appendLine("• Kosher food required")
                sb.appendLine("• No pork or shellfish")
                sb.appendLine("• No mixing meat and dairy")
                sb.appendLine()
                sb.appendLine("MEDICATIONS:")
                sb.appendLine("• Check for non-kosher ingredients")
                sb.appendLine("• Pikuach nefesh: health overrides dietary law")
            }
            "hinduism" -> {
                sb.appendLine("Religion: Hinduism")
                sb.appendLine()
                sb.appendLine("FOOD:")
                sb.appendLine("• Often vegetarian")
                sb.appendLine("• No beef (cow is sacred)")
                sb.appendLine("• Some avoid onion and garlic")
                sb.appendLine()
                sb.appendLine("MEDICATIONS:")
                sb.appendLine("• Check for bovine gelatin")
                sb.appendLine("• Vegetarian alternatives preferred")
            }
            else -> {
                if (restrictions != null && restrictions.length() > 0) {
                    sb.appendLine("Recorded restrictions:")
                    for (i in 0 until restrictions.length()) {
                        sb.appendLine("• ${restrictions.getString(i)}")
                    }
                } else {
                    sb.appendLine("No dietary restrictions recorded.")
                    sb.appendLine()
                    sb.appendLine("Ask patient about:")
                    sb.appendLine("• Religious dietary laws")
                    sb.appendLine("• Vegetarian/vegan preferences")
                    sb.appendLine("• Food allergies")
                    sb.appendLine("• Medication ingredient concerns")
                }
            }
        }

        showDataOverlay("Dietary Restrictions", sb.toString())
    }

    /**
     * Show decision-making preference.
     */
    private fun showDecisionMakingPreference() {
        val style = culturalCarePreferences?.optString("decision_making_style", "individual")
        val religion = culturalCarePreferences?.optString("religion", "")

        val guidance = """
            |👥 DECISION-MAKING PREFERENCES
            |
            |Current Setting: ${style?.replace("_", " ")?.replaceFirstChar { it.uppercase() } ?: "Not specified"}
            |
            |STYLES:
            |
            |INDIVIDUAL AUTONOMY:
            |• Patient makes own decisions
            |• Standard Western medical ethics
            |• Family informed per patient wishes
            |
            |FAMILY-CENTERED:
            |• Family involved in all decisions
            |• Patient may defer to family
            |• Common in many Asian, Hispanic cultures
            |
            |PATRIARCH/MATRIARCH-LED:
            |• Senior family member makes decisions
            |• Patient consults family elder first
            |• Common in some Middle Eastern, Asian cultures
            |
            |SHARED (PATIENT + FAMILY):
            |• Collaborative decision-making
            |• Both patient and family preferences considered
            |• Seek consensus before proceeding
            |
            |RECOMMENDATIONS:
            |• Ask patient: "Who should be involved in decisions?"
            |• "Should we discuss with family first?"
            |• Document preference in chart
            |• Respect cultural norms while ensuring patient voice
            """.trimMargin()

        showDataOverlay("Decision Making", guidance)
    }

    /**
     * Show modesty preferences.
     */
    private fun showModestyPreferences() {
        val religion = culturalCarePreferences?.optString("religion", "")
        val sameGender = culturalCarePreferences?.optBoolean("same_gender_provider_preferred", false) ?: false

        val sb = StringBuilder()
        sb.appendLine("👤 MODESTY PREFERENCES")
        sb.appendLine()

        if (sameGender || religion in listOf("islam", "judaism")) {
            sb.appendLine("⚠️ SAME-GENDER PROVIDER PREFERRED")
            sb.appendLine()
        }

        when (religion) {
            "islam" -> {
                sb.appendLine("Islamic Modesty Guidelines:")
                sb.appendLine("• Female patients prefer female providers")
                sb.appendLine("• Male patients may accept female provider")
                sb.appendLine("• Minimize body exposure during exams")
                sb.appendLine("• Allow hijab/head covering to remain")
                sb.appendLine("• Knock and announce before entering")
                sb.appendLine("• Private space for 5x daily prayers")
            }
            "judaism" -> {
                sb.appendLine("Jewish Modesty Guidelines (Orthodox):")
                sb.appendLine("• Same-gender provider when possible")
                sb.appendLine("• Modest clothing/gowns")
                sb.appendLine("• Men may keep kippah on")
                sb.appendLine("• Women may keep head covering")
            }
            else -> {
                if (sameGender) {
                    sb.appendLine("Patient has requested same-gender providers")
                    sb.appendLine("when possible for examinations.")
                } else {
                    sb.appendLine("No specific modesty preferences recorded.")
                    sb.appendLine()
                    sb.appendLine("Always ask patients about:")
                    sb.appendLine("• Provider gender preferences")
                    sb.appendLine("• Chaperone requests")
                    sb.appendLine("• Clothing/covering preferences")
                }
            }
        }

        showDataOverlay("Modesty Preferences", sb.toString())
    }

    /**
     * Show end-of-life preferences.
     */
    private fun showEndOfLifePreferences() {
        val religion = culturalCarePreferences?.optString("religion", "")

        val sb = StringBuilder()
        sb.appendLine("⚰️ END-OF-LIFE PREFERENCES")
        sb.appendLine()

        when (religion) {
            "jehovah_witness" -> {
                sb.appendLine("Jehovah's Witness:")
                sb.appendLine("• No blood products even at end of life")
                sb.appendLine("• Comfort care acceptable")
                sb.appendLine("• Elders may visit for spiritual support")
                sb.appendLine("• Burial preferred, but cremation acceptable")
            }
            "islam" -> {
                sb.appendLine("Islamic End-of-Life:")
                sb.appendLine("• Family presence important")
                sb.appendLine("• Imam may be requested")
                sb.appendLine("• Face patient toward Mecca (SE in US)")
                sb.appendLine("• Recitation of Quran at bedside")
                sb.appendLine("• Burial within 24 hours preferred")
                sb.appendLine("• No cremation")
                sb.appendLine("• Body washed by same-gender Muslims")
            }
            "judaism" -> {
                sb.appendLine("Jewish End-of-Life:")
                sb.appendLine("• No hastening of death")
                sb.appendLine("• May remove impediments to natural death")
                sb.appendLine("• Shema prayer at death")
                sb.appendLine("• Eyes closed by family member")
                sb.appendLine("• Chevra kadisha (burial society) prepares body")
                sb.appendLine("• Burial usually within 24 hours")
                sb.appendLine("• No cremation (Orthodox)")
                sb.appendLine("• Shiva mourning period follows")
            }
            "hinduism" -> {
                sb.appendLine("Hindu End-of-Life:")
                sb.appendLine("• Family involvement essential")
                sb.appendLine("• Pandit (priest) may perform last rites")
                sb.appendLine("• Ganges water may be given")
                sb.appendLine("• Mantras recited")
                sb.appendLine("• May wish to die at home")
                sb.appendLine("• Cremation preferred")
                sb.appendLine("• Ashes scattered in sacred water")
            }
            "buddhism" -> {
                sb.appendLine("Buddhist End-of-Life:")
                sb.appendLine("• Peaceful environment important")
                sb.appendLine("• Chanting may be performed")
                sb.appendLine("• Monk may be requested")
                sb.appendLine("• Mindfulness at time of death")
                sb.appendLine("• Cremation common")
                sb.appendLine("• Some traditions have waiting periods")
            }
            else -> {
                sb.appendLine("No specific religious end-of-life preferences recorded.")
                sb.appendLine()
                sb.appendLine("DISCUSS WITH PATIENT/FAMILY:")
                sb.appendLine("• Advance directives")
                sb.appendLine("• DNR/DNI preferences")
                sb.appendLine("• Spiritual/religious needs")
                sb.appendLine("• Family notification preferences")
                sb.appendLine("• Burial vs. cremation")
                sb.appendLine("• Organ donation wishes")
            }
        }

        showDataOverlay("End-of-Life Care", sb.toString())
    }

    /**
     * Show Ramadan fasting medication guidance.
     */
    private fun showRamadanGuidance() {
        val guidance = """
            |🌙 RAMADAN FASTING GUIDANCE
            |
            |FASTING PERIOD: Dawn to Sunset
            |• No food, drink, or oral medications
            |
            |MEDICATION TIMING OPTIONS:
            |
            |ONCE DAILY:
            |• Take after sunset (iftar) meal
            |
            |TWICE DAILY:
            |• Take at pre-dawn (suhur) and sunset
            |
            |THREE TIMES DAILY:
            |• May need regimen change
            |• Consider long-acting alternatives
            |• Two doses at non-fasting hours if possible
            |
            |GENERALLY ACCEPTABLE DURING FAST:
            |• Eye drops, ear drops
            |• Injections (insulin, vaccines)
            |• Topical medications
            |• Inhalers (some scholars differ)
            |• Suppositories (some scholars differ)
            |
            |BREAKS THE FAST:
            |• Oral medications with water
            |• IV fluids (if not life-saving)
            |• Sublingual tablets
            |
            |⚠️ PATIENT MAY BE EXEMPT FROM FASTING IF:
            |• Illness that fasting would worsen
            |• Diabetes with hypoglycemia risk
            |• Pregnancy or breastfeeding
            |• Elderly with health conditions
            |
            |Always discuss with patient - they may still
            |choose to fast despite medical advice.
            """.trimMargin()

        showDataOverlay("Ramadan Guidance", guidance)
        speakFeedback("Ramadan fasting medication guidance displayed.")
    }

    /**
     * Show all cultural care alerts.
     */
    private fun showCulturalCareAlerts() {
        if (culturalCareAlerts.isEmpty()) {
            showDataOverlay("Cultural Alerts", "No cultural care alerts.\n\nSet patient religion and preferences to enable alerts.")
            return
        }

        val sb = StringBuilder()
        sb.appendLine("🌍 CULTURAL CARE ALERTS")
        sb.appendLine()

        culturalCareAlerts.forEach { alert ->
            sb.appendLine("• ${alert.optString("message", "Alert")}")
        }

        showDataOverlay("Cultural Alerts", sb.toString())
    }

    // ═══════════════════════════════════════════════════════════════════════════════
    // IMPLICIT BIAS ALERTS (Feature #81) - Gentle, evidence-based reminders
    // ═══════════════════════════════════════════════════════════════════════════════

    /**
     * Check for implicit bias alerts during documentation.
     * Triggered automatically during pain documentation or manually via voice command.
     */
    private fun checkImplicitBias(keywords: List<String> = emptyList()) {
        if (!biasAlertsEnabled) {
            speakFeedback("Bias alerts are disabled. Say enable bias alerts to turn them on.")
            return
        }

        val patientId = currentPatientData?.optString("patient_id")
        if (patientId == null) {
            speakFeedback("No patient loaded. Load a patient first.")
            return
        }

        // Get keywords from current transcript or extracted entities
        val checkKeywords = if (keywords.isNotEmpty()) {
            keywords
        } else {
            val combined = mutableListOf<String>()
            combined.addAll(extractedEntities.symptoms)
            combined.addAll(extractedEntities.chiefComplaints)
            combined
        }

        Thread {
            try {
                val url = java.net.URL("$EHR_PROXY_URL/api/v1/implicit-bias/check")
                val connection = url.openConnection() as java.net.HttpURLConnection
                connection.requestMethod = "POST"
                connection.setRequestProperty("Content-Type", "application/json")
                connection.doOutput = true

                val requestBody = JSONObject().apply {
                    put("patient_id", patientId)
                    currentPatientAncestry?.let { put("patient_ancestry", it) }
                    put("clinical_context", currentBiasContext ?: "general")
                    put("transcript_keywords", org.json.JSONArray(checkKeywords))
                    extractedEntities.chiefComplaints.firstOrNull()?.let { put("chief_complaint", it) }
                }

                connection.outputStream.bufferedWriter().use { it.write(requestBody.toString()) }

                if (connection.responseCode == 200) {
                    val response = connection.inputStream.bufferedReader().readText()
                    val json = JSONObject(response)

                    if (json.optBoolean("should_show_reminder", false)) {
                        val alerts = json.optJSONArray("alerts")
                        if (alerts != null && alerts.length() > 0) {
                            lastBiasAlert = alerts.getJSONObject(0)
                            runOnUiThread {
                                showBiasAlert(lastBiasAlert!!)
                            }
                        }
                    } else {
                        runOnUiThread {
                            showDataOverlay("Bias Check", "✓ No bias alerts for current context.\n\nContinue with documentation.")
                        }
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Failed to check implicit bias: ${e.message}")
                runOnUiThread {
                    // Show generic reminder on error
                    showGenericBiasReminder()
                }
            }
        }.start()
    }

    /**
     * Display a bias awareness alert in a gentle, non-accusatory manner.
     */
    private fun showBiasAlert(alert: JSONObject) {
        if (biasAlertShownThisSession) {
            // Don't spam alerts - show once per session per context
            return
        }

        val title = alert.optString("title", "Bias Awareness")
        val reminder = alert.optString("reminder", "")
        val reflectionPrompt = alert.optString("reflection_prompt", "")
        val evidence = alert.optString("evidence", "")

        val display = """
            |💭 $title
            |
            |$reminder
            |
            |━━━ REFLECTION ━━━
            |$reflectionPrompt
            |
            |━━━ EVIDENCE ━━━
            |${evidence.take(200)}...
            |
            |Say "acknowledge bias" when ready to continue.
            |Say "bias resources" for training materials.
            """.trimMargin()

        showDataOverlay("Equity Reminder", display)

        // Speak the gentle reminder (not the full evidence)
        speakFeedback("Equity reminder: $reminder")

        biasAlertShownThisSession = true
        Log.d(TAG, "Showed bias alert: $title")
    }

    /**
     * Show generic bias reminder when backend unavailable.
     */
    private fun showGenericBiasReminder() {
        val display = """
            |💭 Clinical Decision Check
            |
            |Research shows unconscious associations can
            |influence clinical decisions across all providers.
            |
            |Taking a brief pause to reflect supports
            |more objective clinical reasoning.
            |
            |━━━ REFLECTION ━━━
            |Would my approach be the same if this patient
            |had different demographics?
            |
            |This reminder is educational, not accusatory.
            |We all have unconscious biases - awareness helps.
            """.trimMargin()

        showDataOverlay("Equity Reminder", display)
        speakFeedback("Equity reminder: Taking a moment to reflect supports objective clinical reasoning.")
    }

    /**
     * Acknowledge and dismiss a bias alert.
     */
    private fun acknowledgeBiasAlert() {
        lastBiasAlert = null
        hideDataOverlay()
        speakFeedback("Thank you. Continuing with documentation.")
        Log.d(TAG, "Bias alert acknowledged")
    }

    /**
     * Show educational resources for implicit bias training.
     */
    private fun showBiasResources() {
        Thread {
            try {
                val url = java.net.URL("$EHR_PROXY_URL/api/v1/implicit-bias/resources")
                val connection = url.openConnection() as java.net.HttpURLConnection
                connection.requestMethod = "GET"

                if (connection.responseCode == 200) {
                    val response = connection.inputStream.bufferedReader().readText()
                    val json = JSONObject(response)

                    runOnUiThread {
                        displayBiasResources(json)
                    }
                } else {
                    runOnUiThread {
                        showDefaultBiasResources()
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Failed to fetch bias resources: ${e.message}")
                runOnUiThread {
                    showDefaultBiasResources()
                }
            }
        }.start()
    }

    /**
     * Display bias training resources from backend.
     */
    private fun displayBiasResources(json: JSONObject) {
        val sb = StringBuilder()
        sb.appendLine("📚 IMPLICIT BIAS RESOURCES")
        sb.appendLine()
        sb.appendLine("TRAINING:")

        json.optJSONArray("training_resources")?.let { resources ->
            for (i in 0 until resources.length()) {
                val resource = resources.getJSONObject(i)
                sb.appendLine("• ${resource.optString("name")}")
                sb.appendLine("  ${resource.optString("description")}")
                sb.appendLine()
            }
        }

        sb.appendLine("KEY PUBLICATIONS:")
        json.optJSONArray("key_publications")?.let { pubs ->
            for (i in 0 until pubs.length()) {
                sb.appendLine("• ${pubs.getString(i)}")
            }
        }

        showDataOverlay("Bias Resources", sb.toString())
        speakFeedback("Implicit bias resources displayed. These include training materials and key research publications.")
    }

    /**
     * Default bias resources when backend unavailable.
     */
    private fun showDefaultBiasResources() {
        val resources = """
            |📚 IMPLICIT BIAS RESOURCES
            |
            |TRAINING:
            |• Project Implicit (Harvard)
            |  Free Implicit Association Tests
            |  implicit.harvard.edu
            |
            |• AAMC Unconscious Bias Training
            |  Medical education resources
            |  aamc.org
            |
            |• NIH Bias in Health Care
            |  nih.gov/ending-structural-racism
            |
            |KEY PUBLICATIONS:
            |• Hoffman et al. (2016) PNAS
            |  Racial bias in pain assessment
            |
            |• FitzGerald & Hurst (2017) BMC
            |  Implicit bias in healthcare
            |
            |• Pletcher et al. (2008) JAMA
            |  Opioid prescribing by race
            |
            |These resources help build awareness.
            |Implicit bias is universal - awareness
            |is the first step to mitigation.
            """.trimMargin()

        showDataOverlay("Bias Resources", resources)
        speakFeedback("Implicit bias resources displayed.")
    }

    /**
     * Automatically check for bias during pain documentation.
     * Called when pain-related keywords detected in transcript.
     */
    fun checkBiasForPainDocumentation() {
        if (!biasAlertsEnabled || biasAlertShownThisSession) return

        // Only trigger for patients with ancestry indicating disparity risk
        val ancestry = currentPatientAncestry ?: return
        val highDisparityAncestries = listOf("african", "black", "hispanic", "latino", "native_american")

        if (highDisparityAncestries.any { it in ancestry.lowercase() }) {
            currentBiasContext = "pain_assessment"
            checkImplicitBias(listOf("pain", "pain assessment"))
        }
    }

    /**
     * Reset bias alert state for new patient.
     */
    private fun resetBiasAlertState() {
        biasAlertShownThisSession = false
        lastBiasAlert = null
        currentBiasContext = null
    }

    // ═══════════════════════════════════════════════════════════════════════════════
    // MATERNAL HEALTH MONITORING (Feature #82) - High-risk OB alerts for Black mothers
    // ═══════════════════════════════════════════════════════════════════════════════

    /**
     * Set maternal status for current patient.
     */
    private fun setMaternalStatus(status: String?) {
        currentMaternalStatus = status
        if (status == null) {
            maternalAlerts.clear()
            maternalRiskLevel = "standard"
            speakFeedback("Maternal status cleared.")
            Toast.makeText(this, "Maternal status: None", Toast.LENGTH_SHORT).show()
        } else {
            val displayStatus = status.replaceFirstChar { it.uppercase() }
            speakFeedback("Patient marked as $displayStatus. Assessing maternal health.")
            Toast.makeText(this, "Status: $displayStatus", Toast.LENGTH_SHORT).show()
            assessMaternalHealth()
        }
    }

    /**
     * Assess maternal health and generate alerts.
     */
    private fun assessMaternalHealth() {
        val patientId = currentPatientData?.optString("patient_id")
        if (patientId == null) {
            speakFeedback("No patient loaded. Load a patient first.")
            return
        }

        if (currentMaternalStatus == null) {
            speakFeedback("No maternal status set. Say patient is pregnant or patient is postpartum.")
            return
        }

        Thread {
            try {
                val url = java.net.URL("$EHR_PROXY_URL/api/v1/maternal-health/assess")
                val connection = url.openConnection() as java.net.HttpURLConnection
                connection.requestMethod = "POST"
                connection.setRequestProperty("Content-Type", "application/json")
                connection.doOutput = true

                val requestBody = JSONObject().apply {
                    put("patient_id", patientId)
                    currentPatientAncestry?.let { put("patient_ancestry", it) }
                    put("maternal_status", currentMaternalStatus)
                    put("current_symptoms", org.json.JSONArray(extractedEntities.symptoms))
                    put("conditions", org.json.JSONArray(extractedEntities.symptoms))  // Use extracted conditions
                }

                connection.outputStream.bufferedWriter().use { it.write(requestBody.toString()) }

                if (connection.responseCode == 200) {
                    val response = connection.inputStream.bufferedReader().readText()
                    val json = JSONObject(response)

                    maternalRiskLevel = json.optString("risk_level", "standard")
                    val alerts = json.optJSONArray("alerts")
                    val checklist = json.optJSONArray("postpartum_checklist")
                    val disparityContext = json.optString("disparity_context", "")

                    runOnUiThread {
                        maternalAlerts.clear()
                        alerts?.let {
                            for (i in 0 until it.length()) {
                                maternalAlerts.add(it.getJSONObject(i))
                            }
                        }

                        postpartumChecklist = mutableListOf<String>().apply {
                            checklist?.let {
                                for (i in 0 until it.length()) {
                                    add(it.getString(i))
                                }
                            }
                        }

                        displayMaternalAssessment(json)
                    }
                } else {
                    runOnUiThread {
                        showDefaultMaternalAssessment()
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Failed to assess maternal health: ${e.message}")
                runOnUiThread {
                    showDefaultMaternalAssessment()
                }
            }
        }.start()
    }

    /**
     * Display maternal health assessment results.
     */
    private fun displayMaternalAssessment(json: JSONObject) {
        val sb = StringBuilder()
        val riskLevel = json.optString("risk_level", "standard")
        val riskIcon = when (riskLevel) {
            "high" -> "🔴"
            "elevated" -> "🟡"
            else -> "🟢"
        }

        sb.appendLine("🤰 MATERNAL HEALTH ASSESSMENT")
        sb.appendLine()
        sb.appendLine("$riskIcon Risk Level: ${riskLevel.uppercase()}")
        sb.appendLine("Status: ${currentMaternalStatus?.replaceFirstChar { it.uppercase() }}")
        sb.appendLine()

        // Show disparity context if present
        val disparityContext = json.optString("disparity_context", "")
        if (disparityContext.isNotEmpty()) {
            sb.appendLine("⚠️ DISPARITY ALERT:")
            sb.appendLine(disparityContext.take(150))
            sb.appendLine()
        }

        // Show alerts
        val alerts = json.optJSONArray("alerts")
        if (alerts != null && alerts.length() > 0) {
            sb.appendLine("━━━ ALERTS ━━━")
            for (i in 0 until alerts.length()) {
                val alert = alerts.getJSONObject(i)
                val severity = alert.optString("severity", "info")
                val icon = when (severity) {
                    "critical" -> "🔴"
                    "warning" -> "🟡"
                    else -> "🔵"
                }
                sb.appendLine("$icon ${alert.optString("title")}")
                sb.appendLine("   ${alert.optString("message")}")
                sb.appendLine()
            }
        }

        // Show key warning signs to check
        val warningSigns = json.optJSONArray("warning_signs_to_check")
        if (warningSigns != null && warningSigns.length() > 0) {
            sb.appendLine("━━━ CHECK FOR ━━━")
            val maxSigns = minOf(4, warningSigns.length())
            for (i in 0 until maxSigns) {
                val sign = warningSigns.getJSONObject(i)
                sb.appendLine("• ${sign.optString("symptom")}")
            }
            if (warningSigns.length() > 4) {
                sb.appendLine("• ... and ${warningSigns.length() - 4} more")
            }
        }

        showDataOverlay("Maternal Assessment", sb.toString())

        // Speak critical alerts
        if (riskLevel == "high" || riskLevel == "elevated") {
            val spokenAlert = when {
                riskLevel == "high" -> "High risk maternal patient. Review alerts immediately."
                disparityContext.isNotEmpty() -> "Elevated risk: Patient is in a demographic group with higher maternal mortality. Lower threshold for intervention."
                else -> "Elevated risk maternal patient."
            }
            speakFeedback(spokenAlert)
        } else {
            speakFeedback("Maternal assessment complete. Standard risk level.")
        }
    }

    /**
     * Default maternal assessment when backend unavailable.
     */
    private fun showDefaultMaternalAssessment() {
        val sb = StringBuilder()
        sb.appendLine("🤰 MATERNAL HEALTH CHECK")
        sb.appendLine()
        sb.appendLine("Status: ${currentMaternalStatus?.replaceFirstChar { it.uppercase() }}")
        sb.appendLine()
        sb.appendLine("━━━ EMERGENCY SIGNS ━━━")
        sb.appendLine("🔴 Severe headache unrelieved by meds")
        sb.appendLine("🔴 Vision changes (spots, blurry)")
        sb.appendLine("🔴 Difficulty breathing")
        sb.appendLine("🔴 Chest pain")
        sb.appendLine("🔴 Heavy bleeding (pad/hour)")
        sb.appendLine("🔴 Seizures")
        sb.appendLine()
        sb.appendLine("━━━ URGENT SIGNS ━━━")
        sb.appendLine("🟡 Fever ≥100.4°F")
        sb.appendLine("🟡 Severe abdominal pain")
        sb.appendLine("🟡 Swelling face/hands")
        sb.appendLine("🟡 Thoughts of self-harm")

        showDataOverlay("Maternal Health", sb.toString())
        speakFeedback("Maternal health checklist displayed. Review emergency and urgent signs.")
    }

    /**
     * Show maternal warning signs.
     */
    private fun showMaternalWarningSigns() {
        Thread {
            try {
                val url = java.net.URL("$EHR_PROXY_URL/api/v1/maternal-health/warning-signs")
                val connection = url.openConnection() as java.net.HttpURLConnection
                connection.requestMethod = "GET"

                if (connection.responseCode == 200) {
                    val response = connection.inputStream.bufferedReader().readText()
                    val json = JSONObject(response)
                    runOnUiThread { displayWarningSigns(json) }
                } else {
                    runOnUiThread { showDefaultMaternalAssessment() }
                }
            } catch (e: Exception) {
                runOnUiThread { showDefaultMaternalAssessment() }
            }
        }.start()
    }

    private fun displayWarningSigns(json: JSONObject) {
        val sb = StringBuilder()
        sb.appendLine("🚨 MATERNAL WARNING SIGNS")
        sb.appendLine()

        sb.appendLine("━━━ EMERGENCY (Call 911) ━━━")
        json.optJSONArray("emergency")?.let { signs ->
            for (i in 0 until signs.length()) {
                val sign = signs.getJSONObject(i)
                sb.appendLine("🔴 ${sign.optString("symptom")}")
                sb.appendLine("   Ask: ${sign.optString("ask_patient")}")
            }
        }

        sb.appendLine()
        sb.appendLine("━━━ URGENT (Same Day) ━━━")
        json.optJSONArray("urgent")?.let { signs ->
            for (i in 0 until signs.length()) {
                val sign = signs.getJSONObject(i)
                sb.appendLine("🟡 ${sign.optString("symptom")}")
            }
        }

        showDataOverlay("Warning Signs", sb.toString())
        speakFeedback("Maternal warning signs displayed. Red items require immediate action.")
    }

    /**
     * Show postpartum checklist.
     */
    private fun showPostpartumChecklist() {
        if (postpartumChecklist.isEmpty()) {
            Thread {
                try {
                    val url = java.net.URL("$EHR_PROXY_URL/api/v1/maternal-health/postpartum-checklist")
                    val connection = url.openConnection() as java.net.HttpURLConnection
                    connection.requestMethod = "GET"

                    if (connection.responseCode == 200) {
                        val response = connection.inputStream.bufferedReader().readText()
                        val json = JSONObject(response)
                        val checklist = json.optJSONArray("checklist")
                        runOnUiThread {
                            postpartumChecklist = mutableListOf<String>().apply {
                                checklist?.let {
                                    for (i in 0 until it.length()) {
                                        add(it.getString(i))
                                    }
                                }
                            }
                            displayPostpartumChecklist()
                        }
                    }
                } catch (e: Exception) {
                    runOnUiThread { displayDefaultPostpartumChecklist() }
                }
            }.start()
        } else {
            displayPostpartumChecklist()
        }
    }

    private fun displayPostpartumChecklist() {
        val sb = StringBuilder()
        sb.appendLine("📋 POSTPARTUM CHECKLIST")
        sb.appendLine()
        sb.appendLine("Complete at each postpartum visit:")
        sb.appendLine()

        postpartumChecklist.forEachIndexed { index, item ->
            sb.appendLine("☐ ${index + 1}. $item")
        }

        sb.appendLine()
        sb.appendLine("⚠️ Preeclampsia can occur up to")
        sb.appendLine("   6 weeks postpartum!")

        showDataOverlay("Postpartum Check", sb.toString())
        speakFeedback("Postpartum checklist displayed. Remember: preeclampsia can occur up to 6 weeks postpartum.")
    }

    private fun displayDefaultPostpartumChecklist() {
        postpartumChecklist = listOf(
            "Blood pressure check",
            "Bleeding assessment",
            "Emotional wellbeing (EPDS)",
            "Incision/wound check",
            "Feeding assessment",
            "Pain level",
            "Sleep and fatigue",
            "Social support",
            "Contraception discussion",
            "Follow-up scheduled"
        )
        displayPostpartumChecklist()
    }

    /**
     * Show maternal risk level.
     */
    private fun showMaternalRiskLevel() {
        if (currentMaternalStatus == null) {
            speakFeedback("No maternal status set for this patient.")
            return
        }

        val riskIcon = when (maternalRiskLevel) {
            "high" -> "🔴"
            "elevated" -> "🟡"
            else -> "🟢"
        }

        val ancestry = currentPatientAncestry ?: "Not specified"
        val isHighRisk = currentPatientAncestry?.lowercase()?.let {
            it.contains("african") || it.contains("black") || it.contains("native")
        } ?: false

        val display = """
            |$riskIcon MATERNAL RISK: ${maternalRiskLevel.uppercase()}
            |
            |Status: ${currentMaternalStatus?.replaceFirstChar { it.uppercase() }}
            |Ancestry: $ancestry
            |
            |${if (isHighRisk) """
            |⚠️ DISPARITY ALERT
            |Black women: 3-4x higher maternal mortality
            |Native American: 2-3x higher mortality
            |
            |RECOMMENDED ACTIONS:
            |• Lower threshold for intervention
            |• Believe patient-reported symptoms
            |• Close follow-up especially postpartum
            |• Screen for cardiomyopathy if cardiac symptoms
            """.trimMargin() else "Standard risk monitoring protocols apply."}
            """.trimMargin()

        showDataOverlay("Maternal Risk", display)
        if (isHighRisk) {
            speakFeedback("Elevated maternal risk due to disparity data. Lower threshold for intervention recommended.")
        }
    }

    /**
     * Show maternal disparity data.
     */
    private fun showMaternalDisparityData() {
        val display = """
            |📊 MATERNAL MORTALITY DISPARITIES
            |Source: CDC 2023
            |
            |━━━ BLACK WOMEN ━━━
            |3-4x higher maternal mortality than white women
            |
            |This disparity persists across ALL:
            |• Income levels
            |• Education levels
            |• Geographic regions
            |
            |Leading causes:
            |• Cardiovascular/cardiomyopathy
            |• Preeclampsia/eclampsia
            |• Hemorrhage
            |• Infection/sepsis
            |
            |━━━ NATIVE AMERICAN WOMEN ━━━
            |2-3x higher maternal mortality
            |
            |━━━ CLINICAL IMPLICATIONS ━━━
            |• Lower threshold for intervention
            |• Believe patient-reported symptoms
            |• Screen for cardiomyopathy early
            |• Close postpartum follow-up critical
            |• Most deaths are PREVENTABLE
            """.trimMargin()

        showDataOverlay("Disparity Data", display)
        speakFeedback("Maternal mortality disparity data displayed. Most maternal deaths are preventable with timely intervention.")
    }

    /**
     * Show preeclampsia warning signs.
     */
    private fun showPreeclampsiaWarning() {
        val display = """
            |🚨 PREECLAMPSIA WARNING SIGNS
            |
            |━━━ SEVERE FEATURES (EMERGENCY) ━━━
            |🔴 BP ≥160/110 on two readings
            |🔴 Severe headache unrelieved by meds
            |🔴 Visual disturbances (spots, blurry)
            |🔴 Epigastric/RUQ pain
            |🔴 Altered mental status
            |🔴 Pulmonary edema
            |🔴 Seizure (eclampsia)
            |
            |━━━ LAB FINDINGS ━━━
            |• Platelets <100,000
            |• AST/ALT 2x normal
            |• Creatinine >1.1 or doubled
            |• Proteinuria ≥300mg/24h
            |
            |━━━ ACTION ━━━
            |If severe: Magnesium sulfate, consider delivery
            |Check: BP, urine protein, CBC, CMP, LFTs
            |
            |⚠️ Can occur up to 6 WEEKS postpartum!
            """.trimMargin()

        showDataOverlay("Preeclampsia", display)
        speakFeedback("Preeclampsia warning signs displayed. Remember this can occur up to 6 weeks postpartum.")
    }

    /**
     * Show hemorrhage warning.
     */
    private fun showHemorrhageWarning() {
        val display = """
            |🩸 POSTPARTUM HEMORRHAGE
            |
            |━━━ DEFINITION ━━━
            |Blood loss ≥1000mL or signs of hypovolemia
            |
            |━━━ WARNING SIGNS ━━━
            |🔴 Soaking ≥1 pad per hour
            |🔴 Passing large clots (>egg size)
            |🔴 Dizziness or lightheadedness
            |🔴 Racing heart
            |🔴 Feeling faint
            |🔴 Pale, clammy skin
            |
            |━━━ RISK FACTORS ━━━
            |• Uterine atony (most common)
            |• Retained placenta
            |• Trauma/lacerations
            |• Coagulopathy
            |
            |━━━ IMMEDIATE ACTION ━━━
            |• IV access, type and cross
            |• Uterotonics (oxytocin, methergine)
            |• Uterine massage
            |• Consider transfusion if ongoing
            |
            |⚠️ Leading cause of preventable
            |   maternal death worldwide
            """.trimMargin()

        showDataOverlay("Hemorrhage Alert", display)
        speakFeedback("Postpartum hemorrhage information displayed. Key sign: soaking more than one pad per hour.")
    }

    /**
     * Show postpartum depression screening.
     */
    private fun showPostpartumDepressionScreen() {
        val display = """
            |💭 POSTPARTUM DEPRESSION SCREENING
            |
            |━━━ EDINBURGH SCALE (EPDS) ━━━
            |Screen at every postpartum visit
            |Score ≥10: Further evaluation needed
            |Score ≥13: High probability of depression
            |
            |━━━ KEY QUESTIONS TO ASK ━━━
            |"In the past 7 days..."
            |
            |• Have you been able to laugh and
            |  see the funny side of things?
            |
            |• Have you blamed yourself unnecessarily
            |  when things went wrong?
            |
            |• Have you felt scared or panicky
            |  for no good reason?
            |
            |• Have things been getting on top
            |  of you?
            |
            |🔴 ALWAYS ASK:
            |"Have you had thoughts of harming
            | yourself or your baby?"
            |
            |━━━ ACTION ━━━
            |Positive screen → Psychiatric referral
            |Thoughts of harm → Immediate evaluation
            |
            |PPD affects 1 in 7 mothers
            """.trimMargin()

        showDataOverlay("PPD Screening", display)
        speakFeedback("Postpartum depression screening guidance displayed. Always ask about thoughts of self-harm.")
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // SDOH INTEGRATION (Feature #84) - Social Determinants of Health
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Add an SDOH factor for the current patient.
     */
    private fun addSdohFactor(factorId: String) {
        if (patientSdohFactors.contains(factorId)) {
            speakFeedback("$factorId already noted for this patient.")
            return
        }

        patientSdohFactors.add(factorId)
        val displayName = factorId.replace("_", " ").replaceFirstChar { it.uppercase() }
        speakFeedback("Added SDOH factor: $displayName. Say SDOH screen to get interventions.")

        // Auto-screen after adding factor
        if (patientSdohFactors.size >= 2) {
            performSdohScreening()
        }
    }

    /**
     * Clear all SDOH factors for current patient.
     */
    private fun clearSdohFactors() {
        patientSdohFactors.clear()
        sdohAlerts.clear()
        sdohInterventions.clear()
        sdohRiskLevel = "low"
        sdohScreeningComplete = false
        speakFeedback("SDOH factors cleared.")
    }

    /**
     * Show current SDOH status.
     */
    private fun showSdohStatus() {
        val sb = StringBuilder()
        sb.appendLine("🏠 SOCIAL DETERMINANTS OF HEALTH")
        sb.appendLine()

        if (patientSdohFactors.isEmpty()) {
            sb.appendLine("━━━ NO FACTORS IDENTIFIED ━━━")
            sb.appendLine()
            sb.appendLine("Say commands like:")
            sb.appendLine("• \"Food insecurity\" - food access issues")
            sb.appendLine("• \"Housing unstable\" - housing problems")
            sb.appendLine("• \"Transportation barrier\" - no ride")
            sb.appendLine("• \"No insurance\" - uninsured")
            sb.appendLine("• \"Financial strain\" - money problems")
            sb.appendLine("• \"Lives alone\" - social isolation")
            sb.appendLine("• \"SDOH screen\" - full screening")
        } else {
            sb.appendLine("━━━ IDENTIFIED FACTORS ━━━")
            sb.appendLine("Risk Level: ${sdohRiskLevel.uppercase()}")
            sb.appendLine()

            patientSdohFactors.forEachIndexed { index, factor ->
                val displayName = factor.replace("_", " ").replaceFirstChar { it.uppercase() }
                sb.appendLine("${index + 1}. $displayName")
            }

            sb.appendLine()
            sb.appendLine("━━━ COMMANDS ━━━")
            sb.appendLine("• \"SDOH interventions\" - see resources")
            sb.appendLine("• \"Z codes\" - billing codes")
            sb.appendLine("• \"Clear SDOH\" - reset factors")
        }

        showDataOverlay("SDOH Status", sb.toString())
        if (patientSdohFactors.isEmpty()) {
            speakFeedback("No SDOH factors identified. Use voice commands to note social determinants.")
        } else {
            speakFeedback("${patientSdohFactors.size} SDOH factors identified. Risk level: $sdohRiskLevel.")
        }
    }

    /**
     * Perform SDOH screening via backend.
     */
    private fun performSdohScreening() {
        if (patientSdohFactors.isEmpty()) {
            speakFeedback("No SDOH factors noted. Add factors first by saying things like food insecurity or housing unstable.")
            return
        }

        val currentPatientId = currentPatientData?.optString("id") ?: "unknown"
        speakFeedback("Screening for ${patientSdohFactors.size} social determinants.")

        lifecycleScope.launch {
            try {
                val requestBody = JSONObject().apply {
                    put("patient_id", currentPatientId)
                    put("known_factors", org.json.JSONArray(patientSdohFactors))
                }

                val request = okhttp3.Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/sdoh/screen")
                    .post(requestBody.toString().toRequestBody("application/json".toMediaType()))
                    .build()

                withContext(Dispatchers.IO) {
                    httpClient.newCall(request).execute()
                }.use { response ->
                    if (response.isSuccessful) {
                        val result = JSONObject(response.body?.string() ?: "{}")
                        sdohRiskLevel = result.optString("overall_risk", "low")
                        sdohScreeningComplete = true

                        // Parse alerts
                        sdohAlerts.clear()
                        val alertsArray = result.optJSONArray("alerts")
                        if (alertsArray != null) {
                            for (i in 0 until alertsArray.length()) {
                                sdohAlerts.add(alertsArray.getJSONObject(i))
                            }
                        }

                        // Parse interventions
                        sdohInterventions.clear()
                        val interventionsArray = result.optJSONArray("recommended_interventions")
                        if (interventionsArray != null) {
                            for (i in 0 until interventionsArray.length()) {
                                sdohInterventions.add(interventionsArray.getJSONObject(i))
                            }
                        }

                        displaySdohScreeningResults(result)
                    } else {
                        speakFeedback("SDOH screening failed. Check connection.")
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "SDOH screening error: ${e.message}")
                speakFeedback("SDOH screening error.")
            }
        }
    }

    /**
     * Display SDOH screening results.
     */
    private fun displaySdohScreeningResults(result: JSONObject) {
        val sb = StringBuilder()
        sb.appendLine("🏠 SDOH SCREENING RESULTS")
        sb.appendLine()

        val riskLevel = result.optString("overall_risk", "low")
        val riskIcon = when (riskLevel) {
            "critical" -> "🔴"
            "high" -> "🟠"
            "moderate" -> "🟡"
            else -> "🟢"
        }
        sb.appendLine("$riskIcon Overall Risk: ${riskLevel.uppercase()}")
        sb.appendLine()

        // Show domain risks
        val domainRisks = result.optJSONObject("domain_risks")
        if (domainRisks != null && domainRisks.length() > 0) {
            sb.appendLine("━━━ RISK BY DOMAIN ━━━")
            domainRisks.keys().forEach { domain ->
                val risk = domainRisks.optString(domain)
                val icon = when (risk) {
                    "critical" -> "🔴"
                    "high" -> "🟠"
                    "moderate" -> "🟡"
                    else -> "🟢"
                }
                val displayDomain = domain.replace("_", " ").replaceFirstChar { it.uppercase() }
                sb.appendLine("$icon $displayDomain: $risk")
            }
            sb.appendLine()
        }

        // Show identified factors with clinical impact
        val factors = result.optJSONArray("identified_factors")
        if (factors != null && factors.length() > 0) {
            sb.appendLine("━━━ CLINICAL IMPACTS ━━━")
            for (i in 0 until minOf(factors.length(), 3)) {
                val factor = factors.getJSONObject(i)
                val name = factor.optString("factor")
                val impact = factor.optString("clinical_impact").take(80)
                sb.appendLine("• $name")
                sb.appendLine("  $impact...")
                sb.appendLine()
            }
        }

        // Show intervention count
        val interventions = result.optJSONArray("recommended_interventions")
        if (interventions != null && interventions.length() > 0) {
            sb.appendLine("━━━ ${interventions.length()} INTERVENTIONS AVAILABLE ━━━")
            sb.appendLine("Say \"SDOH interventions\" to view")
        }

        // Show Z-codes for billing
        val zCodes = result.optJSONArray("z_codes_for_billing")
        if (zCodes != null && zCodes.length() > 0) {
            sb.appendLine()
            sb.appendLine("━━━ Z-CODES FOR BILLING ━━━")
            for (i in 0 until minOf(zCodes.length(), 4)) {
                val code = zCodes.getJSONObject(i)
                sb.appendLine("${code.optString("code")}: ${code.optString("description").take(30)}")
            }
        }

        showDataOverlay("SDOH Results", sb.toString())

        val factorCount = patientSdohFactors.size
        val interventionCount = interventions?.length() ?: 0
        speakFeedback("SDOH screening complete. $factorCount factors, risk level $riskLevel. $interventionCount interventions available.")
    }

    /**
     * Show SDOH interventions.
     */
    private fun showSdohInterventions() {
        if (sdohInterventions.isEmpty()) {
            speakFeedback("No interventions available. Run SDOH screening first.")
            return
        }

        val sb = StringBuilder()
        sb.appendLine("📋 SDOH INTERVENTIONS")
        sb.appendLine()

        sdohInterventions.forEachIndexed { index, intervention ->
            val factor = intervention.optString("factor")
            val title = intervention.optString("title")
            val description = intervention.optString("description")
            val type = intervention.optString("intervention_type")

            val typeIcon = when (type) {
                "referral" -> "📞"
                "resource" -> "📦"
                "accommodation" -> "♿"
                "care_modification" -> "💊"
                else -> "•"
            }

            sb.appendLine("${index + 1}. $typeIcon $title")
            sb.appendLine("   For: $factor")
            sb.appendLine("   $description")
            sb.appendLine()
        }

        showDataOverlay("SDOH Interventions", sb.toString())
        speakFeedback("${sdohInterventions.size} interventions displayed. Includes referrals, resources, and care modifications.")
    }

    /**
     * Show SDOH Z-codes for billing.
     */
    private fun showSdohZCodes() {
        val sb = StringBuilder()
        sb.appendLine("📋 SDOH Z-CODES FOR BILLING")
        sb.appendLine()
        sb.appendLine("━━━ COMMON SDOH CODES ━━━")
        sb.appendLine()
        sb.appendLine("Z59.41 - Food insecurity")
        sb.appendLine("Z59.0  - Homelessness")
        sb.appendLine("Z59.1  - Inadequate housing")
        sb.appendLine("Z59.82 - Transportation insecurity")
        sb.appendLine("Z59.86 - Financial insecurity")
        sb.appendLine("Z59.7  - Insufficient social support")
        sb.appendLine("Z55.0  - Low literacy")
        sb.appendLine("Z60.4  - Social isolation")
        sb.appendLine("Z60.5  - Discrimination")
        sb.appendLine("Z63.0  - Partner relationship problem")
        sb.appendLine("Z56.0  - Unemployment")
        sb.appendLine("Z75.3  - Healthcare unavailability")
        sb.appendLine()
        sb.appendLine("━━━ PATIENT'S CODES ━━━")

        if (patientSdohFactors.isNotEmpty()) {
            val codeMap = mapOf(
                "food_insecurity" to "Z59.41",
                "housing_instability" to "Z59.0",
                "transportation_barrier" to "Z59.82",
                "financial_strain" to "Z59.86",
                "no_insurance" to "Z59.7",
                "low_health_literacy" to "Z55.0",
                "social_isolation" to "Z60.4",
                "domestic_violence" to "Z63.0",
                "unemployment" to "Z56.0"
            )
            patientSdohFactors.forEach { factor ->
                val code = codeMap[factor] ?: "Z59.9"
                val name = factor.replace("_", " ").replaceFirstChar { it.uppercase() }
                sb.appendLine("$code - $name")
            }
        } else {
            sb.appendLine("No factors identified yet.")
        }

        showDataOverlay("SDOH Z-Codes", sb.toString())
        speakFeedback("SDOH Z-codes displayed. Document these for care management billing.")
    }

    /**
     * Show medication adherence risk factors.
     */
    private fun showAdherenceRiskFactors() {
        val sb = StringBuilder()
        sb.appendLine("💊 MEDICATION ADHERENCE BARRIERS")
        sb.appendLine()
        sb.appendLine("━━━ SDOH FACTORS AFFECTING ADHERENCE ━━━")
        sb.appendLine()
        sb.appendLine("🏠 Housing Instability")
        sb.appendLine("   • No refrigeration for insulin")
        sb.appendLine("   • Inconsistent address for refills")
        sb.appendLine()
        sb.appendLine("🍽️ Food Insecurity")
        sb.appendLine("   • Can't take meds with food")
        sb.appendLine("   • Hypoglycemia risk if skipping meals")
        sb.appendLine()
        sb.appendLine("💰 Financial Strain")
        sb.appendLine("   • Choosing food vs medicine")
        sb.appendLine("   • Pill splitting, skipping doses")
        sb.appendLine()
        sb.appendLine("🚗 Transportation Barrier")
        sb.appendLine("   • Can't get to pharmacy")
        sb.appendLine("   • Missed follow-up appointments")
        sb.appendLine()
        sb.appendLine("📖 Low Health Literacy")
        sb.appendLine("   • Medication errors")
        sb.appendLine("   • Doesn't understand instructions")
        sb.appendLine()
        sb.appendLine("━━━ PATIENT'S BARRIERS ━━━")

        val adherenceFactors = patientSdohFactors.filter {
            it in listOf("food_insecurity", "housing_instability", "financial_strain",
                "transportation_barrier", "low_health_literacy")
        }

        if (adherenceFactors.isNotEmpty()) {
            adherenceFactors.forEach { factor ->
                val name = factor.replace("_", " ").replaceFirstChar { it.uppercase() }
                sb.appendLine("⚠️ $name")
            }
            sb.appendLine()
            sb.appendLine("Consider: Extended refills, mail-order,")
            sb.appendLine("simplified regimens, patient assistance")
        } else {
            sb.appendLine("No adherence barriers identified.")
        }

        showDataOverlay("Adherence Risks", sb.toString())
        if (adherenceFactors.isNotEmpty()) {
            speakFeedback("${adherenceFactors.size} medication adherence barriers identified. Review before assuming non-compliance.")
        } else {
            speakFeedback("No medication adherence barriers currently identified for this patient.")
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // HEALTH LITERACY ASSESSMENT (Feature #85)
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Show current literacy status.
     */
    private fun showLiteracyStatus() {
        val sb = StringBuilder()
        sb.appendLine("📖 HEALTH LITERACY STATUS")
        sb.appendLine()

        val levelIcon = when (patientLiteracyLevel) {
            "inadequate" -> "🔴"
            "marginal" -> "🟡"
            "adequate" -> "🟢"
            else -> "🟢"
        }
        sb.appendLine("$levelIcon Level: ${patientLiteracyLevel.uppercase()}")
        sb.appendLine("Assessed: ${if (literacyAssessed) "Yes" else "No"}")
        sb.appendLine("Teach-back required: ${if (teachBackRequired) "Yes" else "No"}")
        sb.appendLine()

        val readingLevel = when (patientLiteracyLevel) {
            "inadequate" -> "3rd-5th grade (pictures only)"
            "marginal" -> "5th-6th grade (simple words)"
            "adequate" -> "7th-8th grade (standard)"
            else -> "9th-12th grade (medical OK)"
        }
        sb.appendLine("Recommended materials: $readingLevel")
        sb.appendLine()
        sb.appendLine("━━━ COMMANDS ━━━")
        sb.appendLine("• \"Literacy screen\" - ask screening question")
        sb.appendLine("• \"Low literacy\" / \"Marginal\" - set level")
        sb.appendLine("• \"Diabetes instructions\" - simplified d/c")
        sb.appendLine("• \"Teach back\" - verification checklist")
        sb.appendLine("• \"Plain language\" - medical terms guide")

        showDataOverlay("Literacy Status", sb.toString())
        speakFeedback("Literacy level: $patientLiteracyLevel. ${if (teachBackRequired) "Teach-back required." else ""}")
    }

    /**
     * Show the screening question for health literacy.
     */
    private fun showLiteracyScreeningQuestion() {
        val sb = StringBuilder()
        sb.appendLine("📖 HEALTH LITERACY SCREENING")
        sb.appendLine()
        sb.appendLine("━━━ ASK THIS QUESTION ━━━")
        sb.appendLine()
        sb.appendLine("\"How confident are you filling")
        sb.appendLine(" out medical forms by yourself?\"")
        sb.appendLine()
        sb.appendLine("━━━ INTERPRET RESPONSE ━━━")
        sb.appendLine()
        sb.appendLine("🟢 \"Extremely\" = Proficient")
        sb.appendLine("🟢 \"Quite a bit\" = Adequate")
        sb.appendLine("🟡 \"Somewhat\" = Marginal")
        sb.appendLine("🟡 \"A little bit\" = Marginal")
        sb.appendLine("🔴 \"Not at all\" = Inadequate")
        sb.appendLine()
        sb.appendLine("━━━ SAY TO RECORD ━━━")
        sb.appendLine("• \"Low literacy\" for inadequate")
        sb.appendLine("• \"Marginal literacy\" for marginal")
        sb.appendLine("• \"Adequate literacy\" for adequate")

        showDataOverlay("Literacy Screen", sb.toString())
        speakFeedback("Ask the patient: How confident are you filling out medical forms by yourself? Then say the result.")
    }

    /**
     * Set literacy level.
     */
    private fun setLiteracyLevel(level: String) {
        patientLiteracyLevel = level
        literacyAssessed = true
        teachBackRequired = level in listOf("inadequate", "marginal")

        val displayLevel = level.replaceFirstChar { it.uppercase() }
        speakFeedback("Literacy level set to $displayLevel. ${if (teachBackRequired) "Teach-back required for all instructions." else ""}")

        // Show accommodations
        showLiteracyAccommodations()
    }

    /**
     * Show literacy accommodations.
     */
    private fun showLiteracyAccommodations() {
        val sb = StringBuilder()
        sb.appendLine("📖 LITERACY ACCOMMODATIONS")
        sb.appendLine()
        sb.appendLine("Level: ${patientLiteracyLevel.uppercase()}")
        sb.appendLine()

        when (patientLiteracyLevel) {
            "inadequate" -> {
                sb.appendLine("━━━ REQUIRED ACCOMMODATIONS ━━━")
                sb.appendLine("🖼️ Use pictures and diagrams ONLY")
                sb.appendLine("1️⃣ Limit to 1-2 key messages")
                sb.appendLine("✅ Teach-back for EVERY instruction")
                sb.appendLine("🗣️ Verbal instructions only")
                sb.appendLine("💊 Pill organizers with pictures")
                sb.appendLine("📅 More frequent follow-ups")
                sb.appendLine("👨‍👩‍👧 Involve caregiver in education")
                sb.appendLine("🎬 Use video if available")
                sb.appendLine("❌ Avoid written materials")
            }
            "marginal" -> {
                sb.appendLine("━━━ RECOMMENDED ACCOMMODATIONS ━━━")
                sb.appendLine("📄 Use 5th grade materials")
                sb.appendLine("🗣️ Supplement written with verbal")
                sb.appendLine("• Use bullet points, not paragraphs")
                sb.appendLine("🖼️ Include pictures with text")
                sb.appendLine("🔆 Highlight key action items")
                sb.appendLine("✅ Teach-back for critical points")
                sb.appendLine("3️⃣ Limit to 3-4 key messages")
                sb.appendLine("🔤 Large font (14pt minimum)")
                sb.appendLine("❌ Avoid medical jargon")
            }
            else -> {
                sb.appendLine("━━━ STANDARD ACCOMMODATIONS ━━━")
                sb.appendLine("📄 7th-8th grade materials OK")
                sb.appendLine("📖 Define medical terms used")
                sb.appendLine("📋 Use headers and organization")
                sb.appendLine("❓ Offer to answer questions")
                sb.appendLine("✅ Confirm key points understood")
            }
        }

        showDataOverlay("Accommodations", sb.toString())
    }

    /**
     * Show simplified instructions.
     */
    private fun showSimplifiedInstructions() {
        if (currentDischargeCondition == null) {
            val sb = StringBuilder()
            sb.appendLine("📋 SIMPLIFIED DISCHARGE TEMPLATES")
            sb.appendLine()
            sb.appendLine("Say one of these to get instructions:")
            sb.appendLine()
            sb.appendLine("• \"Diabetes instructions\"")
            sb.appendLine("• \"Heart failure instructions\"")
            sb.appendLine("• \"Blood pressure instructions\"")
            sb.appendLine("• \"Blood thinner instructions\"")
            sb.appendLine("• \"Antibiotic instructions\"")
            sb.appendLine("• \"Post surgery instructions\"")

            showDataOverlay("Instructions", sb.toString())
            speakFeedback("Say the condition name to get simplified discharge instructions.")
        } else {
            showSimplifiedInstructionsFor(currentDischargeCondition!!)
        }
    }

    /**
     * Show simplified instructions for a specific condition.
     */
    private fun showSimplifiedInstructionsFor(condition: String) {
        currentDischargeCondition = condition
        val sb = StringBuilder()

        when (condition) {
            "diabetes" -> {
                sb.appendLine("🩺 DIABETES CARE (Simplified)")
                sb.appendLine()
                sb.appendLine("━━━ TELL THE PATIENT ━━━")
                sb.appendLine()
                sb.appendLine("✓ Check your blood sugar every day")
                sb.appendLine("✓ Eat healthy foods")
                sb.appendLine("✓ Take medicine same time daily")
                sb.appendLine()
                sb.appendLine("━━━ RED FLAGS ━━━")
                sb.appendLine("🔴 Sugar over 300 → Call doctor")
                sb.appendLine("🔴 Sugar under 70 → Eat sugar, call")
                sb.appendLine("🔴 Very thirsty + confused → ER")
                sb.appendLine()
                sb.appendLine("━━━ TEACH-BACK ━━━")
                sb.appendLine("\"Show me how you check sugar\"")
                sb.appendLine("\"When do you take medicine?\"")
                sb.appendLine("\"What if sugar is too low?\"")
            }
            "heart_failure" -> {
                sb.appendLine("❤️ HEART FAILURE CARE (Simplified)")
                sb.appendLine()
                sb.appendLine("━━━ TELL THE PATIENT ━━━")
                sb.appendLine()
                sb.appendLine("✓ Weigh yourself every morning")
                sb.appendLine("✓ Write down your weight")
                sb.appendLine("✓ Eat less salt (no added salt)")
                sb.appendLine("✓ Take water pill in morning")
                sb.appendLine()
                sb.appendLine("━━━ RED FLAGS ━━━")
                sb.appendLine("🔴 Gained 3 lbs in 1 day → Call")
                sb.appendLine("🔴 Gained 5 lbs in 1 week → Call")
                sb.appendLine("🔴 Can't breathe lying down → ER")
                sb.appendLine()
                sb.appendLine("━━━ TEACH-BACK ━━━")
                sb.appendLine("\"When do you weigh yourself?\"")
                sb.appendLine("\"What foods have lots of salt?\"")
            }
            "hypertension" -> {
                sb.appendLine("💊 HIGH BLOOD PRESSURE (Simplified)")
                sb.appendLine()
                sb.appendLine("━━━ TELL THE PATIENT ━━━")
                sb.appendLine()
                sb.appendLine("✓ Take pill same time every day")
                sb.appendLine("✓ Don't skip doses")
                sb.appendLine("✓ Check BP at home")
                sb.appendLine("✓ Eat less salt")
                sb.appendLine()
                sb.appendLine("━━━ RED FLAGS ━━━")
                sb.appendLine("🔴 BP over 180/120 → ER")
                sb.appendLine("🔴 Severe headache + high BP → ER")
                sb.appendLine("🔴 Chest pain → Call 911")
            }
            "anticoagulation" -> {
                sb.appendLine("💉 BLOOD THINNER (Simplified)")
                sb.appendLine()
                sb.appendLine("━━━ TELL THE PATIENT ━━━")
                sb.appendLine()
                sb.appendLine("✓ Take at same time every day")
                sb.appendLine("✓ Don't skip doses")
                sb.appendLine("✓ Watch for bleeding/bruising")
                sb.appendLine("✓ Keep eating same foods")
                sb.appendLine()
                sb.appendLine("━━━ RED FLAGS ━━━")
                sb.appendLine("🔴 Bleeding won't stop → ER")
                sb.appendLine("🔴 Blood in urine/stool → Call")
                sb.appendLine("🔴 Bad headache → ER")
            }
            "infection" -> {
                sb.appendLine("💊 ANTIBIOTIC INSTRUCTIONS (Simplified)")
                sb.appendLine()
                sb.appendLine("━━━ TELL THE PATIENT ━━━")
                sb.appendLine()
                sb.appendLine("✓ Take ALL the pills")
                sb.appendLine("✓ Don't stop when you feel better")
                sb.appendLine("✓ Take with food if stomach upset")
                sb.appendLine("✓ Finish the whole bottle")
                sb.appendLine()
                sb.appendLine("━━━ RED FLAGS ━━━")
                sb.appendLine("🔴 Fever coming back → Call")
                sb.appendLine("🔴 Rash or hives → Stop, call")
                sb.appendLine("🔴 Getting worse → Call")
            }
            "post_surgery" -> {
                sb.appendLine("🏥 AFTER SURGERY (Simplified)")
                sb.appendLine()
                sb.appendLine("━━━ TELL THE PATIENT ━━━")
                sb.appendLine()
                sb.appendLine("✓ Keep wound clean and dry")
                sb.appendLine("✓ Take pain medicine as needed")
                sb.appendLine("✓ Don't lift heavy things")
                sb.appendLine("✓ Walk a little bit each day")
                sb.appendLine()
                sb.appendLine("━━━ RED FLAGS ━━━")
                sb.appendLine("🔴 Wound red/hot/oozing → Call")
                sb.appendLine("🔴 Fever over 101 → Call")
                sb.appendLine("🔴 Wound opens up → ER")
            }
            else -> {
                sb.appendLine("No template for: $condition")
            }
        }

        showDataOverlay("$condition Instructions", sb.toString())
        speakFeedback("Simplified ${condition.replace("_", " ")} instructions displayed. Use teach-back to verify understanding.")
    }

    /**
     * Show teach-back checklist.
     */
    private fun showTeachBackChecklist() {
        val sb = StringBuilder()
        sb.appendLine("✅ TEACH-BACK CHECKLIST")
        sb.appendLine()
        sb.appendLine("\"Tell me in your own words...\"")
        sb.appendLine()
        sb.appendLine("━━━ MEDICATIONS ━━━")
        sb.appendLine("□ Name of each medication")
        sb.appendLine("□ What each medication is for")
        sb.appendLine("□ When to take each medication")
        sb.appendLine("□ How to take (with food, etc.)")
        sb.appendLine("□ What if you miss a dose")
        sb.appendLine("□ Side effects to watch for")
        sb.appendLine()
        sb.appendLine("━━━ WARNING SIGNS ━━━")
        sb.appendLine("□ When to call the doctor")
        sb.appendLine("□ When to go to the ER")
        sb.appendLine("□ Who to call with questions")
        sb.appendLine()
        sb.appendLine("━━━ FOLLOW-UP ━━━")
        sb.appendLine("□ When is next appointment")
        sb.appendLine("□ What tests before appointment")
        sb.appendLine()
        sb.appendLine("If patient can't repeat back,")
        sb.appendLine("re-teach with simpler language.")

        showDataOverlay("Teach-Back", sb.toString())
        speakFeedback("Teach-back checklist displayed. Ask patient to repeat each item in their own words.")
    }

    /**
     * Show plain language guide.
     */
    private fun showPlainLanguageGuide() {
        val sb = StringBuilder()
        sb.appendLine("📖 PLAIN LANGUAGE GUIDE")
        sb.appendLine()
        sb.appendLine("━━━ SAY THIS ━━━    ━━━ NOT THIS ━━━")
        sb.appendLine()
        sb.appendLine("High blood pressure → Hypertension")
        sb.appendLine("Fast heart rate → Tachycardia")
        sb.appendLine("Trouble breathing → Dyspnea")
        sb.appendLine("Swelling → Edema")
        sb.appendLine("Sick to stomach → Nausea")
        sb.appendLine("Throwing up → Emesis")
        sb.appendLine("Fever → Pyrexia")
        sb.appendLine("Long-lasting → Chronic")
        sb.appendLine("Sudden/new → Acute")
        sb.appendLine("What to expect → Prognosis")
        sb.appendLine("Prevention → Prophylaxis")
        sb.appendLine("Blood thinner → Anticoagulant")
        sb.appendLine("Water pill → Diuretic")
        sb.appendLine()
        sb.appendLine("━━━ MEDICATION TIMING ━━━")
        sb.appendLine("Once a day → QD")
        sb.appendLine("Twice a day → BID")
        sb.appendLine("Three times → TID")
        sb.appendLine("As needed → PRN")
        sb.appendLine("At bedtime → HS")
        sb.appendLine("Nothing to eat → NPO")

        showDataOverlay("Plain Language", sb.toString())
        speakFeedback("Plain language guide displayed. Use simple words instead of medical terms.")
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // INTERPRETER INTEGRATION HELPER FUNCTIONS (Feature #86)
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Request an interpreter (general).
     */
    private fun requestInterpreter() {
        val sb = StringBuilder()
        sb.appendLine("🌐 REQUEST INTERPRETER")
        sb.appendLine()
        sb.appendLine("━━━ QUICK REQUEST ━━━")
        sb.appendLine()
        sb.appendLine("Say language + \"interpreter\":")
        sb.appendLine("• \"Spanish interpreter\"")
        sb.appendLine("• \"Chinese interpreter\"")
        sb.appendLine("• \"Vietnamese interpreter\"")
        sb.appendLine("• \"Arabic interpreter\"")
        sb.appendLine("• \"Korean interpreter\"")
        sb.appendLine("• \"ASL interpreter\"")
        sb.appendLine()
        sb.appendLine("━━━ OR SET TYPE FIRST ━━━")
        sb.appendLine()
        sb.appendLine("• \"Phone interpreter\" (fastest)")
        sb.appendLine("• \"Video interpreter\" (VRI)")
        sb.appendLine("• \"In-person interpreter\"")
        sb.appendLine()
        if (patientPreferredLanguage != null) {
            sb.appendLine("━━━ PATIENT PREFERENCE ━━━")
            sb.appendLine("Preferred: $patientPreferredLanguageName")
            sb.appendLine("Say \"request interpreter\" to use")
        }

        showDataOverlay("Interpreter Request", sb.toString())
        speakFeedback("Say the language followed by interpreter. For example, Spanish interpreter.")
    }

    /**
     * Request interpreter for a specific language.
     */
    private fun requestInterpreterForLanguage(languageCode: String, languageName: String) {
        val json = JSONObject()
        json.put("language", languageCode)
        json.put("interpreter_type", interpreterType)
        json.put("urgency", "routine")
        currentPatientData?.optString("id")?.let { patientId ->
            json.put("patient_id", patientId)
        }

        val requestBody = json.toString().toRequestBody("application/json".toMediaType())
        val request = Request.Builder()
            .url("$EHR_PROXY_URL/api/v1/interpreter/request")
            .post(requestBody)
            .build()

        speakFeedback("Requesting $languageName interpreter")

        httpClient.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                runOnUiThread {
                    // Fallback with service info
                    showInterpreterServicesForLanguage(languageCode, languageName)
                }
            }

            override fun onResponse(call: Call, response: Response) {
                val body = response.body?.string()
                runOnUiThread {
                    if (response.isSuccessful && body != null) {
                        val resp = JSONObject(body)
                        val sb = StringBuilder()
                        sb.appendLine("✅ INTERPRETER REQUESTED")
                        sb.appendLine()
                        sb.appendLine("Language: $languageName")
                        sb.appendLine("Type: ${interpreterType.replace("_", " ").capitalize()}")
                        sb.appendLine("Request ID: ${resp.optString("request_id", "N/A")}")
                        sb.appendLine("Status: ${resp.optString("status", "requested")}")
                        sb.appendLine()

                        val service = resp.optJSONObject("service")
                        if (service != null) {
                            sb.appendLine("━━━ SERVICE INFO ━━━")
                            sb.appendLine("Provider: ${service.optString("name", "")}")
                            sb.appendLine("Phone: ${service.optString("phone", "")}")
                            sb.appendLine("Access Code: ${service.optString("access_code", "")}")
                            interpreterPhoneNumber = service.optString("phone", null)
                            currentInterpreterService = service.optString("id", null)
                        }

                        sb.appendLine()
                        sb.appendLine("Say \"start interpreter\" when connected")

                        showDataOverlay("Interpreter Request", sb.toString())
                        speakFeedback("$languageName interpreter requested. Use service info to connect.")
                    } else {
                        showInterpreterServicesForLanguage(languageCode, languageName)
                    }
                }
            }
        })
    }

    /**
     * Show interpreter service info for a language (fallback).
     */
    private fun showInterpreterServicesForLanguage(languageCode: String, languageName: String) {
        val sb = StringBuilder()
        sb.appendLine("📞 $languageName INTERPRETER")
        sb.appendLine()
        sb.appendLine("━━━ LANGUAGE LINE ━━━")
        sb.appendLine("Phone: 1-800-526-7625")
        sb.appendLine("Access Code: Check badge")
        sb.appendLine("Available: 24/7")
        sb.appendLine()
        sb.appendLine("━━━ CYRACOM ━━━")
        sb.appendLine("Phone: 1-844-797-2266")
        sb.appendLine("Client ID: Check badge")
        sb.appendLine()
        sb.appendLine("━━━ STRATUS VIDEO ━━━")
        sb.appendLine("For VRI (Video)")
        sb.appendLine("Use iPad on wall")
        sb.appendLine()
        sb.appendLine("━━━ DOCUMENTATION ━━━")
        sb.appendLine("Say \"document interpreter\" when done")

        showDataOverlay("Interpreter Services", sb.toString())
        speakFeedback("$languageName interpreter services displayed. Call Language Line or CyraCom to connect.")
    }

    /**
     * Show interpreter status.
     */
    private fun showInterpreterStatus() {
        val sb = StringBuilder()
        sb.appendLine("🌐 INTERPRETER STATUS")
        sb.appendLine()

        if (interpreterSessionActive) {
            sb.appendLine("✅ SESSION ACTIVE")
            sb.appendLine()
            sb.appendLine("Session ID: ${interpreterSessionId ?: "N/A"}")
            sb.appendLine("Language: ${patientPreferredLanguageName ?: "Unknown"}")
            sb.appendLine("Type: ${interpreterType.replace("_", " ").capitalize()}")
            sb.appendLine("Service: ${currentInterpreterService ?: "Unknown"}")
            sb.appendLine()
            sb.appendLine("Say \"end interpreter\" when done")
        } else {
            sb.appendLine("⚪ NO ACTIVE SESSION")
            sb.appendLine()
            if (patientPreferredLanguage != null) {
                sb.appendLine("━━━ PATIENT PREFERENCE ━━━")
                sb.appendLine("Language: $patientPreferredLanguageName")
                sb.appendLine("Interpreter Required: ${if (interpreterRequired) "Yes" else "No"}")
                sb.appendLine("Family Declined: ${if (familyInterpreterDeclined) "Yes" else "No"}")
            }
            sb.appendLine()
            sb.appendLine("Say \"need interpreter\" to request")
        }

        showDataOverlay("Interpreter Status", sb.toString())
    }

    /**
     * Start interpreter session.
     */
    private fun startInterpreterSession() {
        if (patientPreferredLanguage == null) {
            speakFeedback("Set patient language first. Say patient speaks Spanish, for example.")
            return
        }

        val json = JSONObject()
        json.put("language", patientPreferredLanguage)
        json.put("interpreter_type", interpreterType)
        currentPatientData?.optString("id")?.let { patientId ->
            json.put("patient_id", patientId)
        }

        val requestBody = json.toString().toRequestBody("application/json".toMediaType())
        val request = Request.Builder()
            .url("$EHR_PROXY_URL/api/v1/interpreter/start-session")
            .post(requestBody)
            .build()

        httpClient.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                runOnUiThread {
                    // Start locally
                    interpreterSessionActive = true
                    interpreterSessionId = java.util.UUID.randomUUID().toString()
                    speakFeedback("Interpreter session started for ${patientPreferredLanguageName ?: "patient"}.")
                    showInterpreterStatus()
                }
            }

            override fun onResponse(call: Call, response: Response) {
                val body = response.body?.string()
                runOnUiThread {
                    if (response.isSuccessful && body != null) {
                        val resp = JSONObject(body)
                        interpreterSessionActive = true
                        interpreterSessionId = resp.optString("session_id", java.util.UUID.randomUUID().toString())
                        speakFeedback("Interpreter session started. Session ID: $interpreterSessionId")
                    } else {
                        interpreterSessionActive = true
                        interpreterSessionId = java.util.UUID.randomUUID().toString()
                        speakFeedback("Interpreter session started locally.")
                    }
                    showInterpreterStatus()
                }
            }
        })
    }

    /**
     * End interpreter session.
     */
    private fun endInterpreterSession() {
        if (!interpreterSessionActive) {
            speakFeedback("No active interpreter session.")
            return
        }

        val json = JSONObject()
        json.put("session_id", interpreterSessionId)

        val requestBody = json.toString().toRequestBody("application/json".toMediaType())
        val request = Request.Builder()
            .url("$EHR_PROXY_URL/api/v1/interpreter/end-session")
            .post(requestBody)
            .build()

        httpClient.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                runOnUiThread {
                    interpreterSessionActive = false
                    val sessionId = interpreterSessionId
                    interpreterSessionId = null
                    speakFeedback("Interpreter session ended. Say document interpreter to add to chart.")
                }
            }

            override fun onResponse(call: Call, response: Response) {
                val body = response.body?.string()
                runOnUiThread {
                    interpreterSessionActive = false
                    interpreterSessionId = null

                    if (response.isSuccessful && body != null) {
                        val resp = JSONObject(body)
                        val duration = resp.optInt("duration_minutes", 0)
                        speakFeedback("Interpreter session ended. Duration: $duration minutes. Say document interpreter to add to chart.")
                    } else {
                        speakFeedback("Interpreter session ended.")
                    }
                }
            }
        })
    }

    /**
     * Show language preference.
     */
    private fun showLanguagePreference() {
        val sb = StringBuilder()
        sb.appendLine("🌐 PATIENT LANGUAGE PREFERENCE")
        sb.appendLine()

        if (patientPreferredLanguage != null) {
            sb.appendLine("Preferred: $patientPreferredLanguageName")
            sb.appendLine("Code: $patientPreferredLanguage")
            sb.appendLine("Interpreter Required: ${if (interpreterRequired) "Yes" else "No"}")
            sb.appendLine()
            sb.appendLine("Family interpreter declined: ${if (familyInterpreterDeclined) "Yes" else "No"}")
        } else {
            sb.appendLine("⚠️ NOT SET")
            sb.appendLine()
            sb.appendLine("━━━ SET PREFERENCE ━━━")
            sb.appendLine("\"Set language Spanish\"")
            sb.appendLine("\"Set language Chinese\"")
            sb.appendLine("\"Set language Vietnamese\"")
            sb.appendLine()
            sb.appendLine("Or fetch from chart")
        }

        showDataOverlay("Language Preference", sb.toString())
    }

    /**
     * Set patient language preference.
     */
    private fun setPatientLanguagePreference(languageCode: String, languageName: String) {
        patientPreferredLanguage = languageCode
        patientPreferredLanguageName = languageName
        interpreterRequired = true

        speakFeedback("Patient language set to $languageName. Interpreter required.")

        // Optionally save to server
        val patientId = currentPatientData?.optString("id")
        if (patientId != null) {
            val json = JSONObject()
            json.put("patient_id", patientId)
            json.put("preferred_language", languageCode)
            json.put("preferred_language_name", languageName)
            json.put("interpreter_required", true)
            json.put("family_interpreter_declined", familyInterpreterDeclined)

            val requestBody = json.toString().toRequestBody("application/json".toMediaType())
            val request = Request.Builder()
                .url("$EHR_PROXY_URL/api/v1/interpreter/set-preference")
                .post(requestBody)
                .build()

            httpClient.newCall(request).enqueue(object : Callback {
                override fun onFailure(call: Call, e: IOException) {
                    Log.e(TAG, "Failed to save language preference: ${e.message}")
                }
                override fun onResponse(call: Call, response: Response) {
                    Log.d(TAG, "Language preference saved")
                }
            })
        }

        showLanguagePreference()
    }

    /**
     * Show clinical phrases for patient's language.
     */
    private fun showClinicalPhrases() {
        val language = patientPreferredLanguage ?: "es"  // Default to Spanish

        val request = Request.Builder()
            .url("$EHR_PROXY_URL/api/v1/interpreter/phrases/$language")
            .get()
            .build()

        httpClient.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                runOnUiThread {
                    showLocalClinicalPhrases(language)
                }
            }

            override fun onResponse(call: Call, response: Response) {
                val body = response.body?.string()
                runOnUiThread {
                    if (response.isSuccessful && body != null) {
                        val resp = JSONObject(body)
                        val phrases = resp.optJSONArray("phrases") ?: JSONArray()
                        val languageName = resp.optString("language_name", language)

                        val sb = StringBuilder()
                        sb.appendLine("📖 CLINICAL PHRASES - $languageName")
                        sb.appendLine()

                        for (i in 0 until minOf(phrases.length(), 15)) {
                            val phrase = phrases.getJSONObject(i)
                            sb.appendLine("━━━ ${phrase.optString("category", "").uppercase()} ━━━")
                            sb.appendLine("EN: ${phrase.optString("english", "")}")
                            sb.appendLine("TR: ${phrase.optString("translation", "")}")
                            val phonetic = phrase.optString("phonetic", "")
                            if (phonetic.isNotEmpty()) {
                                sb.appendLine("Say: $phonetic")
                            }
                            sb.appendLine()
                        }

                        showDataOverlay("Clinical Phrases", sb.toString())
                        speakFeedback("$languageName clinical phrases displayed.")
                    } else {
                        showLocalClinicalPhrases(language)
                    }
                }
            }
        })
    }

    /**
     * Show local clinical phrases (fallback).
     */
    private fun showLocalClinicalPhrases(language: String) {
        val sb = StringBuilder()

        when (language) {
            "es" -> {
                sb.appendLine("📖 SPANISH CLINICAL PHRASES")
                sb.appendLine()
                sb.appendLine("━━━ GREETINGS ━━━")
                sb.appendLine("EN: Hello, I am your doctor")
                sb.appendLine("ES: Hola, soy su doctor")
                sb.appendLine("Say: OH-lah, soy soo dok-TOR")
                sb.appendLine()
                sb.appendLine("━━━ PAIN ━━━")
                sb.appendLine("EN: Where does it hurt?")
                sb.appendLine("ES: ¿Dónde le duele?")
                sb.appendLine("Say: DOHN-day leh DWEH-leh")
                sb.appendLine()
                sb.appendLine("EN: Rate your pain 1-10")
                sb.appendLine("ES: Del 1 al 10, ¿cuánto dolor?")
                sb.appendLine("Say: del OO-no al dee-ES, KWAHN-toh doh-LOR")
                sb.appendLine()
                sb.appendLine("━━━ INSTRUCTIONS ━━━")
                sb.appendLine("EN: Take a deep breath")
                sb.appendLine("ES: Respire profundo")
                sb.appendLine("Say: res-PEE-ray pro-FOON-doh")
                sb.appendLine()
                sb.appendLine("EN: Open your mouth")
                sb.appendLine("ES: Abra la boca")
                sb.appendLine("Say: AH-brah lah BOH-kah")
            }
            "zh" -> {
                sb.appendLine("📖 CHINESE CLINICAL PHRASES")
                sb.appendLine()
                sb.appendLine("━━━ GREETINGS ━━━")
                sb.appendLine("EN: Hello, I am your doctor")
                sb.appendLine("ZH: 你好，我是你的医生")
                sb.appendLine("Pinyin: Nǐ hǎo, wǒ shì nǐ de yīshēng")
                sb.appendLine()
                sb.appendLine("━━━ PAIN ━━━")
                sb.appendLine("EN: Where does it hurt?")
                sb.appendLine("ZH: 哪里痛？")
                sb.appendLine("Pinyin: Nǎlǐ tòng?")
            }
            "vi" -> {
                sb.appendLine("📖 VIETNAMESE CLINICAL PHRASES")
                sb.appendLine()
                sb.appendLine("━━━ GREETINGS ━━━")
                sb.appendLine("EN: Hello, I am your doctor")
                sb.appendLine("VI: Xin chào, tôi là bác sĩ của bạn")
                sb.appendLine()
                sb.appendLine("━━━ PAIN ━━━")
                sb.appendLine("EN: Where does it hurt?")
                sb.appendLine("VI: Đau ở đâu?")
            }
            else -> {
                sb.appendLine("📖 CLINICAL PHRASES")
                sb.appendLine()
                sb.appendLine("Phrases not available for: $language")
                sb.appendLine()
                sb.appendLine("Use interpreter service instead")
            }
        }

        showDataOverlay("Clinical Phrases", sb.toString())
        speakFeedback("Clinical phrases displayed.")
    }

    /**
     * Show phrases for a specific language with optional phrase filter.
     */
    private fun showPhrasesForLanguage(languageCode: String, phraseFilter: String?) {
        patientPreferredLanguage = languageCode
        showClinicalPhrases()
    }

    /**
     * Extract phrase to translate from voice command.
     */
    private fun extractPhraseToTranslate(transcript: String): String? {
        val lower = transcript.lowercase()
        return when {
            lower.contains("how do i say") -> {
                transcript.substringAfter("how do i say", "").substringBefore(" in ").trim()
            }
            lower.contains("say in") -> {
                transcript.substringBefore("say in", "").replace("how do i", "").trim()
            }
            else -> null
        }
    }

    /**
     * Show interpreter services.
     */
    private fun showInterpreterServices() {
        val request = Request.Builder()
            .url("$EHR_PROXY_URL/api/v1/interpreter/services")
            .get()
            .build()

        httpClient.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                runOnUiThread {
                    showLocalInterpreterServices()
                }
            }

            override fun onResponse(call: Call, response: Response) {
                val body = response.body?.string()
                runOnUiThread {
                    if (response.isSuccessful && body != null) {
                        val resp = JSONObject(body)
                        val services = resp.optJSONArray("services") ?: JSONArray()

                        val sb = StringBuilder()
                        sb.appendLine("📞 INTERPRETER SERVICES")
                        sb.appendLine()

                        for (i in 0 until services.length()) {
                            val service = services.getJSONObject(i)
                            sb.appendLine("━━━ ${service.optString("name", "").uppercase()} ━━━")
                            sb.appendLine("Phone: ${service.optString("phone", "")}")
                            sb.appendLine("Access: ${service.optString("access_code", "Check badge")}")
                            sb.appendLine("Hours: ${service.optString("available", "")}")
                            val types = service.optJSONArray("types")
                            if (types != null && types.length() > 0) {
                                val typesList = (0 until types.length()).map { types.getString(it) }
                                sb.appendLine("Types: ${typesList.joinToString(", ")}")
                            }
                            sb.appendLine()
                        }

                        showDataOverlay("Interpreter Services", sb.toString())
                        speakFeedback("Interpreter services displayed.")
                    } else {
                        showLocalInterpreterServices()
                    }
                }
            }
        })
    }

    /**
     * Show local interpreter services (fallback).
     */
    private fun showLocalInterpreterServices() {
        val sb = StringBuilder()
        sb.appendLine("📞 INTERPRETER SERVICES")
        sb.appendLine()
        sb.appendLine("━━━ LANGUAGE LINE ━━━")
        sb.appendLine("Phone: 1-800-526-7625")
        sb.appendLine("Access: Check badge/ID card")
        sb.appendLine("Hours: 24/7/365")
        sb.appendLine("Types: Phone, Video")
        sb.appendLine()
        sb.appendLine("━━━ CYRACOM ━━━")
        sb.appendLine("Phone: 1-844-797-2266")
        sb.appendLine("Access: Client ID on badge")
        sb.appendLine("Hours: 24/7/365")
        sb.appendLine("Types: Phone, Video")
        sb.appendLine()
        sb.appendLine("━━━ STRATUS VIDEO ━━━")
        sb.appendLine("Use: iPad/tablet on wall")
        sb.appendLine("Hours: 24/7/365")
        sb.appendLine("Types: Video (VRI)")
        sb.appendLine()
        sb.appendLine("━━━ IN-PERSON ━━━")
        sb.appendLine("Contact: Interpreter Services")
        sb.appendLine("Ext: Check hospital directory")

        showDataOverlay("Interpreter Services", sb.toString())
        speakFeedback("Interpreter services displayed. Language Line and CyraCom available 24/7.")
    }

    /**
     * Show interpreter compliance checklist (Title VI).
     */
    private fun showInterpreterComplianceChecklist() {
        val request = Request.Builder()
            .url("$EHR_PROXY_URL/api/v1/interpreter/compliance-checklist")
            .get()
            .build()

        httpClient.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                runOnUiThread {
                    showLocalComplianceChecklist()
                }
            }

            override fun onResponse(call: Call, response: Response) {
                val body = response.body?.string()
                runOnUiThread {
                    if (response.isSuccessful && body != null) {
                        val resp = JSONObject(body)
                        val items = resp.optJSONArray("checklist") ?: JSONArray()

                        val sb = StringBuilder()
                        sb.appendLine("📋 INTERPRETER COMPLIANCE")
                        sb.appendLine("Title VI Requirements")
                        sb.appendLine()

                        for (i in 0 until items.length()) {
                            val item = items.getJSONObject(i)
                            val checked = if (item.optBoolean("required", true)) "□" else "✓"
                            sb.appendLine("$checked ${item.optString("item", "")}")
                        }

                        sb.appendLine()
                        sb.appendLine("━━━ REMEMBER ━━━")
                        sb.appendLine("• Never use children as interpreters")
                        sb.appendLine("• Document family declined if applicable")
                        sb.appendLine("• Document interpreter use in chart")

                        showDataOverlay("Compliance Checklist", sb.toString())
                        speakFeedback("Title VI compliance checklist displayed.")
                    } else {
                        showLocalComplianceChecklist()
                    }
                }
            }
        })
    }

    /**
     * Show local compliance checklist (fallback).
     */
    private fun showLocalComplianceChecklist() {
        val sb = StringBuilder()
        sb.appendLine("📋 TITLE VI COMPLIANCE")
        sb.appendLine("Language Access Requirements")
        sb.appendLine()
        sb.appendLine("━━━ BEFORE ENCOUNTER ━━━")
        sb.appendLine("□ Identify patient's language")
        sb.appendLine("□ Offer qualified interpreter")
        sb.appendLine("□ Document if family declines")
        sb.appendLine("□ Never use children (<18)")
        sb.appendLine()
        sb.appendLine("━━━ DURING ENCOUNTER ━━━")
        sb.appendLine("□ Speak directly to patient")
        sb.appendLine("□ Use short, simple sentences")
        sb.appendLine("□ Pause for interpretation")
        sb.appendLine("□ Avoid medical jargon")
        sb.appendLine()
        sb.appendLine("━━━ DOCUMENTATION ━━━")
        sb.appendLine("□ Language preference")
        sb.appendLine("□ Interpreter used (type)")
        sb.appendLine("□ Interpreter ID/name")
        sb.appendLine("□ Duration of service")
        sb.appendLine()
        sb.appendLine("━━━ VITAL DOCUMENTS ━━━")
        sb.appendLine("Must be translated:")
        sb.appendLine("• Consent forms")
        sb.appendLine("• Discharge instructions")
        sb.appendLine("• HIPAA notices")

        showDataOverlay("Compliance Checklist", sb.toString())
        speakFeedback("Title VI compliance checklist displayed. Document interpreter use in chart.")
    }

    /**
     * Set family interpreter declined.
     */
    private fun setFamilyInterpreterDeclined(declined: Boolean) {
        familyInterpreterDeclined = declined
        if (declined) {
            speakFeedback("Documented: Family member as interpreter declined by patient. Qualified interpreter required.")
        }
    }

    /**
     * Set interpreter type.
     */
    private fun setInterpreterType(type: String) {
        interpreterType = type
        speakFeedback("Interpreter type set to ${type.replace("_", " ")}.")
    }

    /**
     * Document interpreter use in note.
     */
    private fun documentInterpreterUse() {
        val sb = StringBuilder()
        sb.appendLine("📝 INTERPRETER DOCUMENTATION")
        sb.appendLine()
        sb.appendLine("━━━ ADD TO NOTE ━━━")
        sb.appendLine()
        sb.appendLine("Language: ${patientPreferredLanguageName ?: "Unknown"}")
        sb.appendLine("Interpreter Type: ${interpreterType.replace("_", " ").capitalize()}")
        sb.appendLine("Service: ${currentInterpreterService ?: "Unknown"}")
        sb.appendLine("Family Declined: ${if (familyInterpreterDeclined) "Yes" else "N/A"}")
        sb.appendLine()

        // Build documentation string
        val docString = buildString {
            append("Interpreter Services Used: ")
            append("${patientPreferredLanguageName ?: "Unknown"} ")
            append("via ${interpreterType.replace("_", " ")} interpretation. ")
            if (familyInterpreterDeclined) {
                append("Patient declined family member as interpreter. ")
            }
            append("Qualified medical interpreter used per Title VI requirements.")
        }

        sb.appendLine("━━━ DOCUMENTATION TEXT ━━━")
        sb.appendLine()
        sb.appendLine(docString)
        sb.appendLine()
        sb.appendLine("Copy to Plan section of note")

        showDataOverlay("Interpreter Documentation", sb.toString())
        speakFeedback("Interpreter documentation prepared. Add to plan section of note.")
    }

    // ============ Patient History Methods ============

    /**
     * Add a patient to the recently viewed history.
     * Stores patient ID, name, and timestamp for quick access.
     * Maintains a maximum of MAX_HISTORY_SIZE entries.
     */
    private fun addToPatientHistory(patientId: String, patientName: String) {
        val history = getPatientHistory().toMutableList()

        // Remove existing entry for this patient (to move to top)
        history.removeAll { it.optString("patient_id") == patientId }

        // Create new entry
        val entry = JSONObject().apply {
            put("patient_id", patientId)
            put("name", patientName)
            put("timestamp", System.currentTimeMillis())
        }

        // Add to beginning (most recent first)
        history.add(0, entry)

        // Trim to max size
        val trimmed = history.take(MAX_HISTORY_SIZE)

        // Save as JSON array
        val historyArray = org.json.JSONArray()
        trimmed.forEach { historyArray.put(it) }

        cachePrefs.edit()
            .putString(HISTORY_KEY, historyArray.toString())
            .apply()

        Log.d(TAG, "Added to history: $patientName ($patientId)")
    }

    /**
     * Get list of recently viewed patients.
     * Returns list of JSONObjects with patient_id, name, timestamp.
     */
    private fun getPatientHistory(): List<JSONObject> {
        val historyJson = cachePrefs.getString(HISTORY_KEY, null) ?: return emptyList()

        return try {
            val array = org.json.JSONArray(historyJson)
            (0 until array.length()).map { array.getJSONObject(it) }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to parse patient history: ${e.message}")
            emptyList()
        }
    }

    /**
     * Clear patient history.
     */
    private fun clearPatientHistory() {
        cachePrefs.edit().remove(HISTORY_KEY).apply()
        Toast.makeText(this, "Patient history cleared", Toast.LENGTH_SHORT).show()
        Log.d(TAG, "Patient history cleared")
    }

    /**
     * Show overlay with recently viewed patients.
     * Allows quick load by saying "load [number]".
     */
    private fun showHistoryOverlay() {
        val history = getPatientHistory()

        if (history.isEmpty()) {
            showDataOverlay("📋 Recent Patients", "No patients in history.\n\nLoad a patient to add them to history.")
            speakFeedback("No patients in history")
            return
        }

        val sb = StringBuilder()
        sb.appendLine("Say \"load [number]\" to quickly load a patient")
        sb.appendLine()

        history.forEachIndexed { index, entry ->
            val name = entry.optString("name", "Unknown")
            val patientId = entry.optString("patient_id", "")
            val timestamp = entry.optLong("timestamp", 0)
            val timeAgo = formatTimeAgo(timestamp)

            sb.appendLine("${index + 1}. $name")
            sb.appendLine("   ID: $patientId • $timeAgo")
            sb.appendLine()
        }

        sb.appendLine("─────────────────────")
        sb.appendLine("Commands: \"clear history\"")

        showDataOverlay("📋 Recent Patients (${history.size})", sb.toString())
        speakFeedback("${history.size} recent patients")
    }

    /**
     * Load patient from history by index (1-based).
     */
    private fun loadPatientFromHistory(index: Int) {
        val history = getPatientHistory()

        if (index < 1 || index > history.size) {
            Toast.makeText(this, "Invalid selection: $index", Toast.LENGTH_SHORT).show()
            speakFeedback("Invalid selection")
            return
        }

        val entry = history[index - 1]
        val patientId = entry.optString("patient_id", "")
        val patientName = entry.optString("name", "Unknown")

        if (patientId.isEmpty()) {
            Toast.makeText(this, "Invalid patient entry", Toast.LENGTH_SHORT).show()
            return
        }

        Log.d(TAG, "Loading patient from history: $patientName ($patientId)")
        fetchPatientData(patientId)
    }

    // ============ Offline Note Drafts Methods ============

    private fun saveDraftNote(
        patientId: String,
        patientName: String,
        noteType: String,
        displayText: String,
        summary: String,
        transcript: String,
        wasEdited: Boolean,
        signedBy: String,
        signedAt: String
    ): String {
        val draftId = "DRAFT-${java.util.UUID.randomUUID().toString().take(8).uppercase()}"

        val draft = JSONObject().apply {
            put("draft_id", draftId)
            put("patient_id", patientId)
            put("patient_name", patientName)
            put("note_type", noteType)
            put("display_text", displayText)
            put("summary", summary)
            put("transcript", transcript)
            put("was_edited", wasEdited)
            put("signed_by", signedBy)
            put("signed_at", signedAt)
            put("created_at", System.currentTimeMillis())
            put("sync_attempts", 0)
            put("last_sync_attempt", 0L)
            put("last_error", JSONObject.NULL)
        }

        cachePrefs.edit().apply {
            putString("$DRAFT_PREFIX$draftId", draft.toString())
            val existingIds = cachePrefs.getString(DRAFT_IDS_KEY, "") ?: ""
            val newIds = if (existingIds.isEmpty()) draftId else "$existingIds,$draftId"
            putString(DRAFT_IDS_KEY, newIds)
            apply()
        }

        Log.d(TAG, "Saved draft note: $draftId for patient $patientId")
        updatePendingDraftsIndicator()
        return draftId
    }

    private fun getPendingDrafts(): List<JSONObject> {
        val idsString = cachePrefs.getString(DRAFT_IDS_KEY, "") ?: ""
        if (idsString.isEmpty()) return emptyList()

        return idsString.split(",")
            .filter { it.isNotEmpty() }
            .mapNotNull { draftId ->
                cachePrefs.getString("$DRAFT_PREFIX$draftId", null)?.let { json ->
                    try { JSONObject(json) } catch (e: Exception) { null }
                }
            }
            .sortedByDescending { it.optLong("created_at", 0) }
    }

    private fun getPendingDraftCount(): Int {
        val idsString = cachePrefs.getString(DRAFT_IDS_KEY, "") ?: ""
        return if (idsString.isEmpty()) 0 else idsString.split(",").filter { it.isNotEmpty() }.size
    }

    private fun deleteDraft(draftId: String) {
        cachePrefs.edit().apply {
            remove("$DRAFT_PREFIX$draftId")

            val existingIds = cachePrefs.getString(DRAFT_IDS_KEY, "") ?: ""
            val newIds = existingIds.split(",")
                .filter { it.isNotEmpty() && it != draftId }
                .joinToString(",")
            putString(DRAFT_IDS_KEY, newIds)
            apply()
        }

        Log.d(TAG, "Deleted draft: $draftId")
        updatePendingDraftsIndicator()
    }

    private fun updateDraftSyncStatus(draftId: String, error: String?) {
        val draftJson = cachePrefs.getString("$DRAFT_PREFIX$draftId", null) ?: return

        try {
            val draft = JSONObject(draftJson)
            draft.put("sync_attempts", draft.optInt("sync_attempts", 0) + 1)
            draft.put("last_sync_attempt", System.currentTimeMillis())
            draft.put("last_error", error ?: JSONObject.NULL)

            cachePrefs.edit().putString("$DRAFT_PREFIX$draftId", draft.toString()).apply()
        } catch (e: Exception) {
            Log.e(TAG, "Failed to update draft sync status: ${e.message}")
        }
    }

    private fun updatePendingDraftsIndicator() {
        val count = getPendingDraftCount()
        runOnUiThread {
            if (count > 0) {
                transcriptText.text = "📋 $count draft(s) pending sync"
            }
        }
    }

    private fun formatTimeAgo(timestamp: Long): String {
        val diff = System.currentTimeMillis() - timestamp
        val minutes = diff / 60000
        val hours = minutes / 60
        val days = hours / 24

        return when {
            days > 0 -> "$days day(s) ago"
            hours > 0 -> "$hours hour(s) ago"
            minutes > 0 -> "$minutes min ago"
            else -> "Just now"
        }
    }

    private fun showPendingDraftsOverlay() {
        val drafts = getPendingDrafts()

        if (drafts.isEmpty()) {
            Toast.makeText(this, "No pending drafts", Toast.LENGTH_SHORT).show()
            return
        }

        val sb = StringBuilder()
        sb.append("📋 PENDING DRAFTS\n")
        sb.append("${"═".repeat(30)}\n\n")

        drafts.forEachIndexed { index, draft ->
            val patientName = draft.optString("patient_name", "Unknown")
            val noteType = draft.optString("note_type", "SOAP")
            val createdAt = draft.optLong("created_at", 0)
            val attempts = draft.optInt("sync_attempts", 0)
            val lastError = draft.optString("last_error", "")
            val timeAgo = formatTimeAgo(createdAt)
            val draftIdShort = draft.optString("draft_id", "")

            sb.append("${index + 1}. $patientName\n")
            sb.append("   Type: $noteType | $timeAgo\n")
            sb.append("   ID: $draftIdShort\n")
            if (attempts > 0) {
                sb.append("   ⚠️ Sync attempts: $attempts\n")
                if (lastError.isNotEmpty() && lastError != "null") {
                    sb.append("   Error: $lastError\n")
                }
            }
            sb.append("\n")
        }

        sb.append("─".repeat(30) + "\n")
        sb.append("Say 'sync notes' to sync now\n")
        sb.append("Say 'delete draft [number]' to remove\n")
        sb.append("Say 'view draft [number]' to see details")

        showDataOverlay("Pending Drafts (${drafts.size})", sb.toString())
    }

    private fun showDraftDetails(draft: JSONObject) {
        val patientName = draft.optString("patient_name", "Unknown")
        val noteType = draft.optString("note_type", "SOAP")
        val displayText = draft.optString("display_text", "")
        val draftId = draft.optString("draft_id", "")

        val title = "$noteType Draft - $patientName"
        val content = "$displayText\n\n─────────────────\nDraft ID: $draftId\nSay 'delete draft' to remove"

        showDataOverlay(title, content)
    }

    // ============ Network Monitoring & Auto-Sync ============

    private fun registerNetworkCallback() {
        val connectivityManager = getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager

        networkCallback = object : ConnectivityManager.NetworkCallback() {
            override fun onAvailable(network: android.net.Network) {
                Log.d(TAG, "Network available - checking for pending data")
                runOnUiThread {
                    // Sync pending note drafts
                    val draftCount = getPendingDraftCount()
                    if (draftCount > 0 && !isSyncing) {
                        Toast.makeText(this@MainActivity, "Network restored - $draftCount draft(s) pending", Toast.LENGTH_SHORT).show()
                        syncPendingDrafts()
                    }

                    // Sync all pending CRUD data (vitals, orders, allergies, medication updates)
                    syncAllPendingCrudData()
                }
            }

            override fun onLost(network: android.net.Network) {
                Log.d(TAG, "Network lost")
                runOnUiThread {
                    val draftCount = getPendingDraftCount()
                    if (draftCount > 0) {
                        transcriptText.text = "Offline - $draftCount draft(s) pending"
                    }
                }
            }
        }

        val networkRequest = android.net.NetworkRequest.Builder()
            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
            .build()

        connectivityManager.registerNetworkCallback(networkRequest, networkCallback!!)
        Log.d(TAG, "Network callback registered")
    }

    private fun unregisterNetworkCallback() {
        networkCallback?.let { callback ->
            val connectivityManager = getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
            try {
                connectivityManager.unregisterNetworkCallback(callback)
                Log.d(TAG, "Network callback unregistered")
            } catch (e: Exception) {
                Log.e(TAG, "Error unregistering network callback: ${e.message}")
            }
        }
        networkCallback = null
    }

    private fun syncPendingDrafts() {
        if (isSyncing) {
            Log.d(TAG, "Sync already in progress")
            return
        }

        val drafts = getPendingDrafts()
        if (drafts.isEmpty()) {
            Log.d(TAG, "No drafts to sync")
            return
        }

        if (!isNetworkAvailable()) {
            Log.d(TAG, "Network not available for sync")
            Toast.makeText(this, "No network connection", Toast.LENGTH_SHORT).show()
            return
        }

        isSyncing = true
        statusText.text = "Syncing ${drafts.size} draft(s)..."
        speakFeedback("Syncing ${drafts.size} pending notes")

        Thread {
            var successCount = 0
            var failCount = 0

            for (draft in drafts) {
                val draftId = draft.optString("draft_id", "")
                val attempts = draft.optInt("sync_attempts", 0)

                // Skip if too many attempts
                if (attempts >= MAX_SYNC_ATTEMPTS) {
                    Log.w(TAG, "Skipping draft $draftId - max attempts reached")
                    failCount++
                    continue
                }

                try {
                    val json = JSONObject().apply {
                        put("patient_id", draft.optString("patient_id"))
                        put("note_type", draft.optString("note_type"))
                        put("display_text", draft.optString("display_text"))
                        put("summary", draft.optString("summary"))
                        put("transcript", draft.optString("transcript"))
                        put("timestamp", draft.optString("signed_at"))
                        put("was_edited", draft.optBoolean("was_edited"))
                        put("signed_by", draft.optString("signed_by"))
                        put("signed_at", draft.optString("signed_at"))
                    }

                    val request = Request.Builder()
                        .url("$EHR_PROXY_URL/api/v1/notes/save")
                        .post(json.toString().toRequestBody("application/json".toMediaType()))
                        .build()

                    val response = httpClient.newCall(request).execute()
                    val body = response.body?.string()
                    val result = JSONObject(body ?: "{}")

                    if (result.optBoolean("success", false)) {
                        deleteDraft(draftId)
                        successCount++
                        Log.d(TAG, "Synced draft $draftId successfully")
                    } else {
                        updateDraftSyncStatus(draftId, result.optString("message", "Unknown error"))
                        failCount++
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Sync error for draft $draftId: ${e.message}")
                    updateDraftSyncStatus(draftId, e.message)
                    failCount++
                }
            }

            isSyncing = false

            runOnUiThread {
                updatePendingDraftsIndicator()

                when {
                    successCount > 0 && failCount == 0 -> {
                        Toast.makeText(this@MainActivity, "Synced $successCount note(s)", Toast.LENGTH_SHORT).show()
                        statusText.text = "All notes synced"
                        transcriptText.text = "Ready"
                        speakFeedback("All notes synced successfully")
                    }
                    successCount > 0 && failCount > 0 -> {
                        Toast.makeText(this@MainActivity, "Synced $successCount, $failCount failed", Toast.LENGTH_LONG).show()
                        statusText.text = "$failCount draft(s) pending"
                        speakFeedback("Synced $successCount notes. $failCount still pending.")
                    }
                    else -> {
                        Toast.makeText(this@MainActivity, "Sync failed - will retry later", Toast.LENGTH_SHORT).show()
                        statusText.text = "${drafts.size} draft(s) pending"
                    }
                }
            }
        }.start()
    }

    // ============ Font Size Methods ============

    private fun getContentFontSize(): Float {
        return when (currentFontSizeLevel) {
            FONT_SIZE_SMALL -> 14f
            FONT_SIZE_MEDIUM -> 16f
            FONT_SIZE_LARGE -> 20f
            FONT_SIZE_EXTRA_LARGE -> 24f
            else -> 16f
        }
    }

    private fun getTitleFontSize(): Float {
        return when (currentFontSizeLevel) {
            FONT_SIZE_SMALL -> 18f
            FONT_SIZE_MEDIUM -> 22f
            FONT_SIZE_LARGE -> 26f
            FONT_SIZE_EXTRA_LARGE -> 30f
            else -> 22f
        }
    }

    private fun getFontSizeName(): String {
        return when (currentFontSizeLevel) {
            FONT_SIZE_SMALL -> "Small"
            FONT_SIZE_MEDIUM -> "Medium"
            FONT_SIZE_LARGE -> "Large"
            FONT_SIZE_EXTRA_LARGE -> "Extra Large"
            else -> "Medium"
        }
    }

    private fun loadFontSizeSetting() {
        currentFontSizeLevel = cachePrefs.getInt(PREF_FONT_SIZE, FONT_SIZE_MEDIUM)
    }

    private fun saveFontSizeSetting() {
        cachePrefs.edit().putInt(PREF_FONT_SIZE, currentFontSizeLevel).apply()
    }

    private fun loadClinicianName() {
        clinicianName = cachePrefs.getString(PREF_CLINICIAN_NAME, DEFAULT_CLINICIAN_NAME) ?: DEFAULT_CLINICIAN_NAME
    }

    private fun setClinicianName(name: String) {
        clinicianName = name
        cachePrefs.edit().putString(PREF_CLINICIAN_NAME, name).apply()
        Toast.makeText(this, "Clinician: $name", Toast.LENGTH_SHORT).show()
        transcriptText.text = "Clinician set to: $name"
        Log.d(TAG, "Clinician name set to: $name")
    }

    private fun loadSpeechFeedbackSetting() {
        isSpeechFeedbackEnabled = cachePrefs.getBoolean(PREF_SPEECH_FEEDBACK, true)
    }

    private fun toggleSpeechFeedback() {
        isSpeechFeedbackEnabled = !isSpeechFeedbackEnabled
        cachePrefs.edit().putBoolean(PREF_SPEECH_FEEDBACK, isSpeechFeedbackEnabled).apply()
        val status = if (isSpeechFeedbackEnabled) "enabled" else "disabled"
        Toast.makeText(this, "Speech feedback $status", Toast.LENGTH_SHORT).show()
        transcriptText.text = "Speech feedback: $status"
        // Announce the change
        if (isSpeechFeedbackEnabled) {
            speakFeedback("Speech feedback enabled")
        }
        Log.d(TAG, "Speech feedback $status")
    }

    /**
     * Push saved note to EHR as FHIR DocumentReference
     */
    private fun pushNoteToEhr() {
        val noteId = lastSavedNoteId
        if (noteId == null) {
            Toast.makeText(this, "No saved note to push", Toast.LENGTH_SHORT).show()
            speakFeedback("No saved note to push. Save a note first.")
            return
        }

        if (!isNetworkAvailable()) {
            Toast.makeText(this, "No network - cannot push to EHR", Toast.LENGTH_SHORT).show()
            speakFeedback("No network connection. Cannot push to EHR.")
            return
        }

        statusText.text = "Pushing to EHR..."
        speakFeedback("Pushing note to EHR")

        Thread {
            try {
                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/notes/$noteId/push")
                    .post("".toRequestBody("application/json".toMediaType()))
                    .build()

                httpClient.newCall(request).enqueue(object : Callback {
                    override fun onFailure(call: Call, e: IOException) {
                        Log.e(TAG, "Push to EHR failed: ${e.message}")
                        runOnUiThread {
                            Toast.makeText(this@MainActivity, "Push failed: ${e.message}", Toast.LENGTH_LONG).show()
                            statusText.text = "Push failed"
                            speakFeedback("Push to EHR failed. Network error.")
                        }
                    }

                    override fun onResponse(call: Call, response: Response) {
                        val body = response.body?.string()
                        Log.d(TAG, "Push response: $body")

                        runOnUiThread {
                            try {
                                val result = JSONObject(body ?: "{}")
                                val success = result.optBoolean("success", false)

                                if (success) {
                                    val fhirId = result.optString("fhir_id", "")
                                    val alreadyPushed = result.optBoolean("already_pushed", false)

                                    if (alreadyPushed) {
                                        Toast.makeText(this@MainActivity, "Note was already pushed to EHR", Toast.LENGTH_SHORT).show()
                                        speakFeedback("Note was already pushed to EHR")
                                    } else {
                                        Toast.makeText(this@MainActivity, "Note pushed to EHR: $fhirId", Toast.LENGTH_LONG).show()
                                        speakFeedback("Note successfully pushed to EHR")
                                    }
                                    statusText.text = "Pushed to EHR"
                                    transcriptText.text = fhirId
                                } else {
                                    val error = result.optString("error", "Push failed")
                                    val statusCode = result.optInt("status_code", 0)

                                    // Handle sandbox read-only gracefully
                                    if (statusCode == 403) {
                                        Toast.makeText(this@MainActivity, "EHR sandbox is read-only", Toast.LENGTH_LONG).show()
                                        speakFeedback("EHR sandbox is read-only. Production credentials required.")
                                        statusText.text = "Sandbox read-only"
                                    } else {
                                        Toast.makeText(this@MainActivity, error, Toast.LENGTH_LONG).show()
                                        speakFeedback("Push to EHR failed")
                                        statusText.text = "Push failed"
                                    }
                                }
                            } catch (e: Exception) {
                                Toast.makeText(this@MainActivity, "Push response error", Toast.LENGTH_SHORT).show()
                                speakFeedback("Push response error")
                            }
                        }
                    }
                })
            } catch (e: Exception) {
                Log.e(TAG, "Failed to push note: ${e.message}")
                runOnUiThread {
                    Toast.makeText(this@MainActivity, "Push error: ${e.message}", Toast.LENGTH_LONG).show()
                    statusText.text = "Push error"
                    speakFeedback("Failed to push note to EHR")
                }
            }
        }.start()
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // CRUD WRITE-BACK TO EHR - Push vitals, orders, allergies to EHR
    // ═══════════════════════════════════════════════════════════════════════════

    /**
     * Push all captured vitals to EHR as FHIR Observations
     * Each vital becomes a separate Observation resource
     */
    private fun pushCapturedVitalsToEhr() {
        if (capturedVitals.isEmpty()) {
            Toast.makeText(this, "No vitals to push", Toast.LENGTH_SHORT).show()
            speakFeedback("No captured vitals to push. Record vitals first.")
            return
        }

        val patientId = currentPatientData?.optString("patient_id", "") ?: ""
        if (patientId.isEmpty()) {
            Toast.makeText(this, "Load a patient first", Toast.LENGTH_SHORT).show()
            speakFeedback("Load a patient before pushing vitals.")
            return
        }

        if (!isNetworkAvailable()) {
            saveVitalsForOfflineSync(patientId)
            Toast.makeText(this, "No network - vitals saved for later sync", Toast.LENGTH_SHORT).show()
            speakFeedback("No network. Vitals saved for offline sync.")
            return
        }

        val vitalCount = capturedVitals.size
        statusText.text = "Pushing $vitalCount vitals to EHR..."
        speakFeedback("Pushing $vitalCount vitals to EHR")

        var successCount = 0
        var failCount = 0

        Thread {
            for (vital in capturedVitals.toList()) {
                try {
                    val vitalType = when (vital.type) {
                        VitalType.BLOOD_PRESSURE -> "blood_pressure"
                        VitalType.HEART_RATE -> "heart_rate"
                        VitalType.TEMPERATURE -> "temperature"
                        VitalType.OXYGEN_SATURATION -> "oxygen_saturation"
                        VitalType.RESPIRATORY_RATE -> "respiratory_rate"
                        VitalType.WEIGHT -> "weight"
                        VitalType.HEIGHT -> "height"
                        VitalType.PAIN_LEVEL -> "pain_level"
                    }

                    val requestBody = JSONObject().apply {
                        put("patient_id", patientId)
                        put("vital_type", vitalType)
                        put("value", vital.value)
                        put("unit", vital.unit)
                        put("performer_name", clinicianName)
                        put("device_type", "AR_GLASSES")

                        // Parse systolic/diastolic for BP
                        if (vital.type == VitalType.BLOOD_PRESSURE && vital.value.contains("/")) {
                            val parts = vital.value.split("/")
                            if (parts.size == 2) {
                                put("systolic", parts[0].trim().toIntOrNull() ?: 0)
                                put("diastolic", parts[1].trim().toIntOrNull() ?: 0)
                            }
                        }
                    }

                    val request = Request.Builder()
                        .url("$EHR_PROXY_URL/api/v1/vitals/push")
                        .post(requestBody.toString().toRequestBody("application/json".toMediaType()))
                        .build()

                    val response = httpClient.newCall(request).execute()
                    val body = response.body?.string()
                    val result = JSONObject(body ?: "{}")

                    if (result.optBoolean("success", false)) {
                        successCount++
                        Log.d(TAG, "Pushed vital: ${vital.displayName}")
                    } else {
                        failCount++
                        Log.e(TAG, "Failed to push vital ${vital.displayName}: ${result.optString("error")}")
                    }
                } catch (e: Exception) {
                    failCount++
                    Log.e(TAG, "Error pushing vital ${vital.displayName}: ${e.message}")
                }
            }

            runOnUiThread {
                if (failCount == 0) {
                    Toast.makeText(this@MainActivity, "$successCount vitals pushed to EHR", Toast.LENGTH_SHORT).show()
                    speakFeedback("$successCount vitals successfully pushed to EHR")
                    statusText.text = "Vitals pushed"
                    capturedVitals.clear()  // Clear after successful push
                } else {
                    Toast.makeText(this@MainActivity, "$successCount pushed, $failCount failed", Toast.LENGTH_LONG).show()
                    speakFeedback("$successCount vitals pushed. $failCount failed.")
                    statusText.text = "$failCount vitals failed"
                }
            }
        }.start()
    }

    /**
     * Push confirmed orders to EHR as FHIR ServiceRequest/MedicationRequest
     */
    private fun pushOrdersToEhr() {
        val confirmedOrders = orderQueue.filter { it.status == OrderStatus.CONFIRMED }

        if (confirmedOrders.isEmpty()) {
            Toast.makeText(this, "No confirmed orders to push", Toast.LENGTH_SHORT).show()
            speakFeedback("No confirmed orders to push. Confirm orders first.")
            return
        }

        val patientId = currentPatientData?.optString("patient_id", "") ?: ""
        if (patientId.isEmpty()) {
            Toast.makeText(this, "Load a patient first", Toast.LENGTH_SHORT).show()
            speakFeedback("Load a patient before pushing orders.")
            return
        }

        if (!isNetworkAvailable()) {
            saveOrdersForOfflineSync(patientId)
            Toast.makeText(this, "No network - orders saved for later sync", Toast.LENGTH_SHORT).show()
            speakFeedback("No network. Orders saved for offline sync.")
            return
        }

        val orderCount = confirmedOrders.size
        statusText.text = "Pushing $orderCount orders to EHR..."
        speakFeedback("Pushing $orderCount orders to EHR")

        var successCount = 0
        var failCount = 0
        val pushedOrderIds = mutableListOf<String>()

        Thread {
            for (order in confirmedOrders) {
                try {
                    val requestBody = JSONObject().apply {
                        put("patient_id", patientId)
                        put("order_type", order.type.name)
                        put("code", order.name)  // Use order name to match CPT/LOINC in proxy
                        put("display_name", order.displayName)
                        put("status", "active")
                        put("priority", "routine")
                        put("requester_name", clinicianName)
                        put("notes", order.details)

                        // Medication-specific fields
                        order.dose?.let { put("dose", it) }
                        order.frequency?.let { put("frequency", it) }
                        order.duration?.let { put("duration", it) }
                        order.route?.let { put("route", it) }
                        put("prn", order.prn)

                        // Imaging-specific fields
                        order.bodyPart?.let { put("body_site", it) }
                        order.laterality?.let { put("laterality", it) }
                        order.contrast?.let { put("contrast", it) }
                    }

                    val request = Request.Builder()
                        .url("$EHR_PROXY_URL/api/v1/orders/push")
                        .post(requestBody.toString().toRequestBody("application/json".toMediaType()))
                        .build()

                    val response = httpClient.newCall(request).execute()
                    val body = response.body?.string()
                    val result = JSONObject(body ?: "{}")

                    if (result.optBoolean("success", false)) {
                        successCount++
                        pushedOrderIds.add(order.id)
                        Log.d(TAG, "Pushed order: ${order.displayName}")
                    } else {
                        failCount++
                        Log.e(TAG, "Failed to push order ${order.displayName}: ${result.optString("error")}")
                    }
                } catch (e: Exception) {
                    failCount++
                    Log.e(TAG, "Error pushing order ${order.displayName}: ${e.message}")
                }
            }

            runOnUiThread {
                // Remove successfully pushed orders from queue
                orderQueue.removeAll { it.id in pushedOrderIds }
                saveOrdersToPrefs()

                if (failCount == 0) {
                    Toast.makeText(this@MainActivity, "$successCount orders pushed to EHR", Toast.LENGTH_SHORT).show()
                    speakFeedback("$successCount orders successfully pushed to EHR")
                    statusText.text = "Orders pushed"
                } else {
                    Toast.makeText(this@MainActivity, "$successCount pushed, $failCount failed", Toast.LENGTH_LONG).show()
                    speakFeedback("$successCount orders pushed. $failCount failed.")
                    statusText.text = "$failCount orders failed"
                }
            }
        }.start()
    }

    // Pending allergy for confirmation workflow
    private var pendingAllergySubstance: String? = null
    private var pendingAllergyCriticality: String = "unable-to-assess"
    private var pendingAllergyReactions: MutableList<String> = mutableListOf()

    /**
     * Start allergy recording workflow - prompt for details
     */
    private fun promptAllergyDetails(substance: String) {
        pendingAllergySubstance = substance
        pendingAllergyCriticality = "unable-to-assess"
        pendingAllergyReactions.clear()

        val message = """
            |Recording allergy to: $substance
            |
            |Say the severity:
            |• "high" for anaphylaxis/severe
            |• "low" for mild/rash
            |• "unknown" if unsure
            |
            |Then say "confirm allergy" to save
        """.trimMargin()

        transcriptText.text = message
        Toast.makeText(this, "Recording allergy to $substance", Toast.LENGTH_SHORT).show()
        speakFeedback("Recording allergy to $substance. Say high, low, or unknown for severity. Then say confirm allergy.")
    }

    /**
     * Set allergy criticality from voice command
     */
    private fun setAllergyCriticality(severity: String) {
        if (pendingAllergySubstance == null) {
            speakFeedback("No pending allergy. Say add allergy followed by the substance name.")
            return
        }

        pendingAllergyCriticality = when (severity.lowercase()) {
            "high", "severe", "anaphylaxis" -> "high"
            "low", "mild", "rash" -> "low"
            else -> "unable-to-assess"
        }

        val severityText = when (pendingAllergyCriticality) {
            "high" -> "High (severe/anaphylaxis)"
            "low" -> "Low (mild/rash)"
            else -> "Unknown"
        }

        transcriptText.text = "Allergy: ${pendingAllergySubstance}\nSeverity: $severityText\n\nSay 'confirm allergy' to save to EHR"
        speakFeedback("Severity set to $severityText. Say confirm allergy to save.")
    }

    /**
     * Add reaction to pending allergy
     */
    private fun addAllergyReaction(reaction: String) {
        if (pendingAllergySubstance == null) {
            speakFeedback("No pending allergy. Say add allergy followed by the substance name.")
            return
        }

        pendingAllergyReactions.add(reaction)
        transcriptText.text = "Allergy: ${pendingAllergySubstance}\nReactions: ${pendingAllergyReactions.joinToString(", ")}\n\nSay 'confirm allergy' to save"
        speakFeedback("Added reaction: $reaction")
    }

    /**
     * Confirm and push allergy to EHR
     */
    private fun confirmAndPushAllergy() {
        val substance = pendingAllergySubstance
        if (substance == null) {
            speakFeedback("No pending allergy to confirm. Say add allergy followed by the substance name.")
            return
        }

        val patientId = currentPatientData?.optString("patient_id", "") ?: ""
        if (patientId.isEmpty()) {
            Toast.makeText(this, "Load a patient first", Toast.LENGTH_SHORT).show()
            speakFeedback("Load a patient before adding allergies.")
            return
        }

        if (!isNetworkAvailable()) {
            saveAllergyForOfflineSync(patientId, substance, pendingAllergyCriticality, pendingAllergyReactions.toList())
            Toast.makeText(this, "No network - allergy saved for later sync", Toast.LENGTH_SHORT).show()
            speakFeedback("No network. Allergy saved for offline sync.")
            clearPendingAllergy()
            return
        }

        statusText.text = "Adding allergy to EHR..."
        speakFeedback("Adding allergy to EHR")

        Thread {
            try {
                val requestBody = JSONObject().apply {
                    put("patient_id", patientId)
                    put("substance", substance)
                    put("criticality", pendingAllergyCriticality)
                    put("category", "medication")  // Default to medication
                    put("recorder_name", clinicianName)
                    if (pendingAllergyReactions.isNotEmpty()) {
                        put("reactions", JSONArray(pendingAllergyReactions))
                    }
                }

                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/allergies/push")
                    .post(requestBody.toString().toRequestBody("application/json".toMediaType()))
                    .build()

                httpClient.newCall(request).enqueue(object : Callback {
                    override fun onFailure(call: Call, e: IOException) {
                        Log.e(TAG, "Push allergy failed: ${e.message}")
                        runOnUiThread {
                            Toast.makeText(this@MainActivity, "Failed to add allergy", Toast.LENGTH_LONG).show()
                            statusText.text = "Allergy push failed"
                            speakFeedback("Failed to add allergy to EHR")
                        }
                    }

                    override fun onResponse(call: Call, response: Response) {
                        val body = response.body?.string()
                        val result = JSONObject(body ?: "{}")

                        runOnUiThread {
                            if (result.optBoolean("success", false)) {
                                Toast.makeText(this@MainActivity, "Allergy added to EHR", Toast.LENGTH_SHORT).show()
                                speakFeedback("Allergy to $substance added to EHR")
                                statusText.text = "Allergy added"

                                // Add to local patient allergies if loaded
                                addToLocalPatientAllergies(substance)
                                clearPendingAllergy()
                            } else {
                                val statusCode = result.optInt("status_code", 0)
                                if (statusCode == 403) {
                                    Toast.makeText(this@MainActivity, "EHR sandbox is read-only", Toast.LENGTH_LONG).show()
                                    speakFeedback("EHR sandbox is read-only. Allergy recorded locally.")
                                    addToLocalPatientAllergies(substance)
                                    clearPendingAllergy()
                                } else {
                                    Toast.makeText(this@MainActivity, "Failed to add allergy", Toast.LENGTH_SHORT).show()
                                    speakFeedback("Failed to add allergy to EHR")
                                }
                                statusText.text = "Allergy push failed"
                            }
                        }
                    }
                })
            } catch (e: Exception) {
                Log.e(TAG, "Error adding allergy: ${e.message}")
                runOnUiThread {
                    Toast.makeText(this@MainActivity, "Error adding allergy", Toast.LENGTH_LONG).show()
                    statusText.text = "Error"
                    speakFeedback("Error adding allergy")
                }
            }
        }.start()
    }

    private fun clearPendingAllergy() {
        pendingAllergySubstance = null
        pendingAllergyCriticality = "unable-to-assess"
        pendingAllergyReactions.clear()
    }

    private fun addToLocalPatientAllergies(substance: String) {
        // Add to cached patient data if available
        val patientId = currentPatientData?.optString("patient_id", "") ?: ""
        if (patientId.isNotEmpty()) {
            try {
                val cachedJson = cachePrefs.getString("patient_$patientId", null)
                if (cachedJson != null) {
                    val patient = JSONObject(cachedJson)
                    val allergies = patient.optJSONArray("allergies") ?: JSONArray()
                    allergies.put(substance)
                    patient.put("allergies", allergies)
                    cachePrefs.edit().putString("patient_$patientId", patient.toString()).apply()
                    Log.d(TAG, "Added allergy to local cache: $substance")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error updating local allergy cache: ${e.message}")
            }
        }
    }

    // Pending medication update for confirmation
    private var pendingMedicationUpdate: Pair<String, String>? = null  // (medicationId/name, newStatus)

    /**
     * Initiate medication discontinuation workflow
     */
    private fun promptDiscontinueMedication(medicationName: String) {
        // Find medication in current patient's med list
        val medId = findMedicationId(medicationName)
        if (medId == null) {
            speakFeedback("Medication $medicationName not found in patient's medication list.")
            return
        }

        pendingMedicationUpdate = Pair(medId, "stopped")

        transcriptText.text = """
            |Discontinue: $medicationName
            |
            |Say "confirm" to discontinue
            |Say "cancel" to cancel
            |
            |Optional: Say "reason [your reason]" to add a reason
        """.trimMargin()

        speakFeedback("Discontinuing $medicationName. Say confirm to proceed or cancel to abort.")
    }

    /**
     * Initiate medication hold workflow
     */
    private fun promptHoldMedication(medicationName: String) {
        val medId = findMedicationId(medicationName)
        if (medId == null) {
            speakFeedback("Medication $medicationName not found in patient's medication list.")
            return
        }

        pendingMedicationUpdate = Pair(medId, "on-hold")

        transcriptText.text = """
            |Hold: $medicationName
            |
            |Say "confirm" to hold medication
            |Say "cancel" to cancel
        """.trimMargin()

        speakFeedback("Holding $medicationName. Say confirm to proceed or cancel to abort.")
    }

    private var pendingMedicationReason: String = ""

    /**
     * Set reason for medication update
     */
    private fun setMedicationUpdateReason(reason: String) {
        if (pendingMedicationUpdate == null) {
            speakFeedback("No pending medication update.")
            return
        }

        pendingMedicationReason = reason
        speakFeedback("Reason noted: $reason")
    }

    /**
     * Confirm and execute medication status update
     */
    private fun confirmMedicationUpdate() {
        val update = pendingMedicationUpdate
        if (update == null) {
            speakFeedback("No pending medication update to confirm.")
            return
        }

        val patientId = currentPatientData?.optString("patient_id", "") ?: ""
        if (patientId.isEmpty()) {
            Toast.makeText(this, "Load a patient first", Toast.LENGTH_SHORT).show()
            speakFeedback("Load a patient first.")
            return
        }

        if (!isNetworkAvailable()) {
            saveMedicationUpdateForOfflineSync(patientId, update.first, update.second, pendingMedicationReason)
            Toast.makeText(this, "No network - update saved for later sync", Toast.LENGTH_SHORT).show()
            speakFeedback("No network. Medication update saved for offline sync.")
            clearPendingMedicationUpdate()
            return
        }

        val (medId, newStatus) = update
        val statusVerb = when (newStatus) {
            "stopped" -> "Discontinuing"
            "on-hold" -> "Holding"
            "cancelled" -> "Cancelling"
            else -> "Updating"
        }

        statusText.text = "$statusVerb medication..."
        speakFeedback("$statusVerb medication")

        Thread {
            try {
                val requestBody = JSONObject().apply {
                    put("patient_id", patientId)
                    put("medication_id", medId)
                    put("new_status", newStatus)
                    put("reason", pendingMedicationReason)
                    put("performer_name", clinicianName)
                }

                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/medications/$medId/status")
                    .put(requestBody.toString().toRequestBody("application/json".toMediaType()))
                    .build()

                httpClient.newCall(request).enqueue(object : Callback {
                    override fun onFailure(call: Call, e: IOException) {
                        Log.e(TAG, "Medication update failed: ${e.message}")
                        runOnUiThread {
                            Toast.makeText(this@MainActivity, "Failed to update medication", Toast.LENGTH_LONG).show()
                            statusText.text = "Update failed"
                            speakFeedback("Failed to update medication")
                        }
                    }

                    override fun onResponse(call: Call, response: Response) {
                        val body = response.body?.string()
                        val result = JSONObject(body ?: "{}")

                        runOnUiThread {
                            if (result.optBoolean("success", false)) {
                                val action = when (newStatus) {
                                    "stopped" -> "discontinued"
                                    "on-hold" -> "held"
                                    "cancelled" -> "cancelled"
                                    else -> "updated"
                                }
                                Toast.makeText(this@MainActivity, "Medication $action", Toast.LENGTH_SHORT).show()
                                speakFeedback("Medication $action")
                                statusText.text = "Medication $action"
                                clearPendingMedicationUpdate()
                            } else {
                                val statusCode = result.optInt("status_code", 0)
                                if (statusCode == 403) {
                                    Toast.makeText(this@MainActivity, "EHR sandbox is read-only", Toast.LENGTH_LONG).show()
                                    speakFeedback("EHR sandbox is read-only.")
                                } else {
                                    Toast.makeText(this@MainActivity, "Failed to update medication", Toast.LENGTH_SHORT).show()
                                    speakFeedback("Failed to update medication")
                                }
                                statusText.text = "Update failed"
                            }
                        }
                    }
                })
            } catch (e: Exception) {
                Log.e(TAG, "Error updating medication: ${e.message}")
                runOnUiThread {
                    Toast.makeText(this@MainActivity, "Error updating medication", Toast.LENGTH_LONG).show()
                    statusText.text = "Error"
                    speakFeedback("Error updating medication")
                }
            }
        }.start()
    }

    /**
     * Cancel pending medication update
     */
    private fun cancelMedicationUpdate() {
        if (pendingMedicationUpdate == null) {
            speakFeedback("No pending medication update to cancel.")
            return
        }

        clearPendingMedicationUpdate()
        transcriptText.text = "Medication update cancelled"
        speakFeedback("Medication update cancelled")
    }

    private fun clearPendingMedicationUpdate() {
        pendingMedicationUpdate = null
        pendingMedicationReason = ""
    }

    /**
     * Find medication ID from patient's current medication list
     */
    private fun findMedicationId(medicationName: String): String? {
        // Search in cached patient data
        val patientId = currentPatientData?.optString("patient_id", "") ?: ""
        if (patientId.isEmpty()) return null

        try {
            val cachedJson = cachePrefs.getString("patient_$patientId", null) ?: return null
            val patient = JSONObject(cachedJson)
            val medications = patient.optJSONArray("medications") ?: return null

            for (i in 0 until medications.length()) {
                val med = medications.optJSONObject(i)
                val name = med?.optString("name", "") ?: ""
                val id = med?.optString("id", "") ?: med?.optString("fhir_id", "") ?: ""

                if (name.contains(medicationName, ignoreCase = true) ||
                    medicationName.contains(name, ignoreCase = true)) {
                    return if (id.isNotEmpty()) id else name  // Use name as fallback ID
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error finding medication: ${e.message}")
        }

        return medicationName  // Return name as ID if not found (proxy will handle)
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // OFFLINE SYNC QUEUES - Store pending writes for later sync
    // ═══════════════════════════════════════════════════════════════════════════

    private val OFFLINE_VITALS_KEY = "offline_vitals_queue"
    private val OFFLINE_ORDERS_KEY = "offline_orders_queue"
    private val OFFLINE_ALLERGIES_KEY = "offline_allergies_queue"
    private val OFFLINE_MED_UPDATES_KEY = "offline_medication_updates"

    private fun saveVitalsForOfflineSync(patientId: String) {
        try {
            val vitalsArray = JSONArray()
            for (vital in capturedVitals) {
                vitalsArray.put(JSONObject().apply {
                    put("patient_id", patientId)
                    put("vital_type", vital.type.name)
                    put("value", vital.value)
                    put("unit", vital.unit)
                    put("display_name", vital.displayName)
                    put("timestamp", vital.timestamp)
                })
            }
            cachePrefs.edit().putString(OFFLINE_VITALS_KEY, vitalsArray.toString()).apply()
            Log.d(TAG, "Saved ${capturedVitals.size} vitals for offline sync")
        } catch (e: Exception) {
            Log.e(TAG, "Error saving vitals for offline sync: ${e.message}")
        }
    }

    private fun saveOrdersForOfflineSync(patientId: String) {
        try {
            val ordersArray = JSONArray()
            for (order in orderQueue.filter { it.status == OrderStatus.CONFIRMED }) {
                ordersArray.put(order.toJson().apply {
                    put("patient_id", patientId)
                })
            }
            cachePrefs.edit().putString(OFFLINE_ORDERS_KEY, ordersArray.toString()).apply()
            Log.d(TAG, "Saved ${ordersArray.length()} orders for offline sync")
        } catch (e: Exception) {
            Log.e(TAG, "Error saving orders for offline sync: ${e.message}")
        }
    }

    private fun saveAllergyForOfflineSync(patientId: String, substance: String, criticality: String, reactions: List<String>) {
        try {
            val existingJson = cachePrefs.getString(OFFLINE_ALLERGIES_KEY, "[]")
            val allergiesArray = JSONArray(existingJson)
            allergiesArray.put(JSONObject().apply {
                put("patient_id", patientId)
                put("substance", substance)
                put("criticality", criticality)
                put("reactions", JSONArray(reactions))
                put("timestamp", System.currentTimeMillis())
            })
            cachePrefs.edit().putString(OFFLINE_ALLERGIES_KEY, allergiesArray.toString()).apply()
            Log.d(TAG, "Saved allergy for offline sync: $substance")
        } catch (e: Exception) {
            Log.e(TAG, "Error saving allergy for offline sync: ${e.message}")
        }
    }

    private fun saveMedicationUpdateForOfflineSync(patientId: String, medId: String, newStatus: String, reason: String) {
        try {
            val existingJson = cachePrefs.getString(OFFLINE_MED_UPDATES_KEY, "[]")
            val updatesArray = JSONArray(existingJson)
            updatesArray.put(JSONObject().apply {
                put("patient_id", patientId)
                put("medication_id", medId)
                put("new_status", newStatus)
                put("reason", reason)
                put("timestamp", System.currentTimeMillis())
            })
            cachePrefs.edit().putString(OFFLINE_MED_UPDATES_KEY, updatesArray.toString()).apply()
            Log.d(TAG, "Saved medication update for offline sync: $medId -> $newStatus")
        } catch (e: Exception) {
            Log.e(TAG, "Error saving medication update for offline sync: ${e.message}")
        }
    }

    /**
     * Sync all pending offline data when network becomes available
     */
    private fun syncAllPendingCrudData() {
        if (!isNetworkAvailable()) {
            Log.d(TAG, "Network not available, skipping CRUD sync")
            return
        }

        Log.d(TAG, "Syncing all pending CRUD data...")

        // Sync vitals
        syncOfflineVitals()

        // Sync orders
        syncOfflineOrders()

        // Sync allergies
        syncOfflineAllergies()

        // Sync medication updates
        syncOfflineMedicationUpdates()
    }

    private fun syncOfflineVitals() {
        try {
            val vitalsJson = cachePrefs.getString(OFFLINE_VITALS_KEY, "[]")
            val vitalsArray = JSONArray(vitalsJson)
            if (vitalsArray.length() == 0) return

            Log.d(TAG, "Syncing ${vitalsArray.length()} offline vitals...")

            Thread {
                var successCount = 0
                for (i in 0 until vitalsArray.length()) {
                    val vital = vitalsArray.getJSONObject(i)
                    try {
                        val request = Request.Builder()
                            .url("$EHR_PROXY_URL/api/v1/vitals/push")
                            .post(vital.toString().toRequestBody("application/json".toMediaType()))
                            .build()

                        val response = httpClient.newCall(request).execute()
                        if (response.isSuccessful) {
                            successCount++
                        }
                    } catch (e: Exception) {
                        Log.e(TAG, "Error syncing vital: ${e.message}")
                    }
                }

                if (successCount == vitalsArray.length()) {
                    cachePrefs.edit().remove(OFFLINE_VITALS_KEY).apply()
                }
                Log.d(TAG, "Synced $successCount/${vitalsArray.length()} vitals")
            }.start()
        } catch (e: Exception) {
            Log.e(TAG, "Error syncing offline vitals: ${e.message}")
        }
    }

    private fun syncOfflineOrders() {
        try {
            val ordersJson = cachePrefs.getString(OFFLINE_ORDERS_KEY, "[]")
            val ordersArray = JSONArray(ordersJson)
            if (ordersArray.length() == 0) return

            Log.d(TAG, "Syncing ${ordersArray.length()} offline orders...")

            Thread {
                var successCount = 0
                for (i in 0 until ordersArray.length()) {
                    val order = ordersArray.getJSONObject(i)
                    try {
                        val request = Request.Builder()
                            .url("$EHR_PROXY_URL/api/v1/orders/push")
                            .post(order.toString().toRequestBody("application/json".toMediaType()))
                            .build()

                        val response = httpClient.newCall(request).execute()
                        if (response.isSuccessful) {
                            successCount++
                        }
                    } catch (e: Exception) {
                        Log.e(TAG, "Error syncing order: ${e.message}")
                    }
                }

                if (successCount == ordersArray.length()) {
                    cachePrefs.edit().remove(OFFLINE_ORDERS_KEY).apply()
                }
                Log.d(TAG, "Synced $successCount/${ordersArray.length()} orders")
            }.start()
        } catch (e: Exception) {
            Log.e(TAG, "Error syncing offline orders: ${e.message}")
        }
    }

    private fun syncOfflineAllergies() {
        try {
            val allergiesJson = cachePrefs.getString(OFFLINE_ALLERGIES_KEY, "[]")
            val allergiesArray = JSONArray(allergiesJson)
            if (allergiesArray.length() == 0) return

            Log.d(TAG, "Syncing ${allergiesArray.length()} offline allergies...")

            Thread {
                var successCount = 0
                for (i in 0 until allergiesArray.length()) {
                    val allergy = allergiesArray.getJSONObject(i)
                    try {
                        val request = Request.Builder()
                            .url("$EHR_PROXY_URL/api/v1/allergies/push")
                            .post(allergy.toString().toRequestBody("application/json".toMediaType()))
                            .build()

                        val response = httpClient.newCall(request).execute()
                        if (response.isSuccessful) {
                            successCount++
                        }
                    } catch (e: Exception) {
                        Log.e(TAG, "Error syncing allergy: ${e.message}")
                    }
                }

                if (successCount == allergiesArray.length()) {
                    cachePrefs.edit().remove(OFFLINE_ALLERGIES_KEY).apply()
                }
                Log.d(TAG, "Synced $successCount/${allergiesArray.length()} allergies")
            }.start()
        } catch (e: Exception) {
            Log.e(TAG, "Error syncing offline allergies: ${e.message}")
        }
    }

    private fun syncOfflineMedicationUpdates() {
        try {
            val updatesJson = cachePrefs.getString(OFFLINE_MED_UPDATES_KEY, "[]")
            val updatesArray = JSONArray(updatesJson)
            if (updatesArray.length() == 0) return

            Log.d(TAG, "Syncing ${updatesArray.length()} offline medication updates...")

            Thread {
                var successCount = 0
                for (i in 0 until updatesArray.length()) {
                    val update = updatesArray.getJSONObject(i)
                    try {
                        val medId = update.getString("medication_id")
                        val request = Request.Builder()
                            .url("$EHR_PROXY_URL/api/v1/medications/$medId/status")
                            .put(update.toString().toRequestBody("application/json".toMediaType()))
                            .build()

                        val response = httpClient.newCall(request).execute()
                        if (response.isSuccessful) {
                            successCount++
                        }
                    } catch (e: Exception) {
                        Log.e(TAG, "Error syncing medication update: ${e.message}")
                    }
                }

                if (successCount == updatesArray.length()) {
                    cachePrefs.edit().remove(OFFLINE_MED_UPDATES_KEY).apply()
                }
                Log.d(TAG, "Synced $successCount/${updatesArray.length()} medication updates")
            }.start()
        } catch (e: Exception) {
            Log.e(TAG, "Error syncing offline medication updates: ${e.message}")
        }
    }

    /**
     * Speak feedback for actions (respects toggle setting)
     * Use this for confirmations like "Patient loaded", "Note saved", etc.
     */
    private fun speakFeedback(message: String) {
        if (isSpeechFeedbackEnabled) {
            speak(message, TextToSpeech.QUEUE_ADD)
        }
    }

    /**
     * Speak allergy warnings when patient is loaded (safety-critical)
     * Always speaks allergies regardless of speech feedback toggle for patient safety
     */
    private fun speakAllergyWarnings(patient: JSONObject) {
        val allergies = patient.optJSONArray("allergies")
        if (allergies != null && allergies.length() > 0) {
            val count = allergies.length()
            val allergyWord = if (count == 1) "allergy" else "allergies"

            val speechBuilder = StringBuilder()
            speechBuilder.append("Alert: Patient has $count known $allergyWord. ")

            // Speak up to 5 allergies
            for (i in 0 until minOf(count, 5)) {
                val allergyName = try {
                    allergies.getString(i)
                } catch (e: Exception) {
                    try { allergies.getJSONObject(i).optString("name", "") } catch (e2: Exception) { "" }
                }
                if (allergyName.isNotBlank()) {
                    speechBuilder.append("$allergyName. ")
                }
            }
            if (count > 5) {
                speechBuilder.append("And ${count - 5} more.")
            }

            // Use QUEUE_ADD so it plays after "Patient loaded" message
            speak(speechBuilder.toString(), TextToSpeech.QUEUE_ADD)
            Log.d(TAG, "Spoke allergy warning: $count allergies")
        }
    }

    /**
     * Speak critical lab alerts when patient is loaded (safety-critical)
     * Always speaks critical labs regardless of speech feedback toggle for patient safety
     */
    private fun speakCriticalLabAlerts(patient: JSONObject) {
        val criticalLabs = patient.optJSONArray("critical_labs")
        if (criticalLabs != null && criticalLabs.length() > 0) {
            val count = criticalLabs.length()
            val labWord = if (count == 1) "lab value" else "lab values"

            val speechBuilder = StringBuilder()
            speechBuilder.append("Critical alert: Patient has $count critical $labWord. ")

            // Speak up to 3 critical labs with values
            for (i in 0 until minOf(count, 3)) {
                try {
                    val lab = criticalLabs.getJSONObject(i)
                    val name = lab.optString("name", "Unknown")
                    val value = lab.optString("value", "")
                    val unit = lab.optString("unit", "")
                    val interp = lab.optString("interpretation", "")

                    // Format interpretation for speech
                    val interpText = when (interp) {
                        "HH" -> "critically high"
                        "LL" -> "critically low"
                        "H" -> "high"
                        "L" -> "low"
                        else -> "abnormal"
                    }

                    speechBuilder.append("$name is $interpText at $value $unit. ")
                } catch (e: Exception) {
                    Log.e(TAG, "Error parsing critical lab: ${e.message}")
                }
            }
            if (count > 3) {
                speechBuilder.append("Plus ${count - 3} more critical values.")
            }

            // Use QUEUE_ADD so it plays after allergies if both exist
            speak(speechBuilder.toString(), TextToSpeech.QUEUE_ADD)
            Log.d(TAG, "Spoke critical lab alert: $count critical labs")
        }
    }

    /**
     * Speak significant lab trends when patient is loaded
     * Alerts clinician to rising or falling lab values
     */
    private fun speakLabTrends(patient: JSONObject) {
        if (!isSpeechFeedbackEnabled) return

        val labs = patient.optJSONArray("labs") ?: return
        if (labs.length() == 0) return

        val trendingLabs = mutableListOf<String>()

        for (i in 0 until labs.length()) {
            try {
                val lab = labs.getJSONObject(i)
                val trend = lab.optString("trend", "")
                val name = lab.optString("name", "")
                val value = lab.optString("value", "")
                val previousValue = lab.optString("previous_value", "")

                // Only speak rising or falling trends (skip stable/new)
                if (trend == "rising" || trend == "falling") {
                    val direction = if (trend == "rising") "rising" else "falling"
                    trendingLabs.add("$name $direction from $previousValue to $value")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error parsing lab: ${e.message}")
            }
        }

        if (trendingLabs.isNotEmpty()) {
            val count = trendingLabs.size
            val labWord = if (count == 1) "lab" else "labs"

            val speechBuilder = StringBuilder()
            speechBuilder.append("Note: $count trending $labWord. ")

            // Speak up to 3 trending labs
            for (i in 0 until minOf(count, 3)) {
                speechBuilder.append("${trendingLabs[i]}. ")
            }
            if (count > 3) {
                speechBuilder.append("Plus ${count - 3} more trending.")
            }

            // Queue after critical alerts
            speak(speechBuilder.toString(), TextToSpeech.QUEUE_ADD)
            Log.d(TAG, "Spoke lab trend alert: $count trending labs")
        }
    }

    /**
     * Speak significant vital trends when patient is loaded
     * Alerts clinician to rising or falling vital values
     */
    private fun speakVitalTrends(patient: JSONObject) {
        if (!isSpeechFeedbackEnabled) return

        val vitals = patient.optJSONArray("vitals") ?: return
        if (vitals.length() == 0) return

        val trendingVitals = mutableListOf<String>()

        for (i in 0 until vitals.length()) {
            try {
                val vital = vitals.getJSONObject(i)
                val trend = vital.optString("trend", "")
                val name = vital.optString("name", "")
                val value = vital.optString("value", "")
                val previousValue = vital.optString("previous_value", "")

                // Only speak rising or falling trends (skip stable/new)
                if (trend == "rising" || trend == "falling") {
                    val direction = if (trend == "rising") "rising" else "falling"
                    trendingVitals.add("$name $direction from $previousValue to $value")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error parsing vital: ${e.message}")
            }
        }

        if (trendingVitals.isNotEmpty()) {
            val count = trendingVitals.size
            val vitalWord = if (count == 1) "vital" else "vitals"

            val speechBuilder = StringBuilder()
            speechBuilder.append("Note: $count trending $vitalWord. ")

            // Speak up to 3 trending vitals
            for (i in 0 until minOf(count, 3)) {
                speechBuilder.append("${trendingVitals[i]}. ")
            }
            if (count > 3) {
                speechBuilder.append("Plus ${count - 3} more trending.")
            }

            // Queue after other alerts
            speak(speechBuilder.toString(), TextToSpeech.QUEUE_ADD)
            Log.d(TAG, "Spoke vital trend alert: $count trending vitals")
        }
    }

    /**
     * Speak critical vital alerts when patient is loaded (safety-critical)
     * Always speaks critical vitals regardless of speech feedback toggle for patient safety
     */
    private fun speakCriticalVitalAlerts(patient: JSONObject) {
        val criticalVitals = patient.optJSONArray("critical_vitals")
        if (criticalVitals != null && criticalVitals.length() > 0) {
            val count = criticalVitals.length()
            val vitalWord = if (count == 1) "vital sign" else "vital signs"

            val speechBuilder = StringBuilder()
            speechBuilder.append("Warning: Patient has $count critical $vitalWord. ")

            // Speak up to 3 critical vitals with values
            for (i in 0 until minOf(count, 3)) {
                try {
                    val vital = criticalVitals.getJSONObject(i)
                    val name = vital.optString("name", "Unknown")
                    val value = vital.optString("value", "")
                    val unit = vital.optString("unit", "")
                    val interp = vital.optString("interpretation", "")

                    // Format interpretation for speech
                    val interpText = when (interp) {
                        "HH" -> "critically high"
                        "LL" -> "critically low"
                        "H" -> "high"
                        "L" -> "low"
                        else -> "abnormal"
                    }

                    // Make vital names more speech-friendly
                    val speechName = when {
                        name.contains("systolic", ignoreCase = true) -> "blood pressure systolic"
                        name.contains("diastolic", ignoreCase = true) -> "blood pressure diastolic"
                        name.contains("heart rate", ignoreCase = true) -> "heart rate"
                        name.contains("pulse", ignoreCase = true) -> "pulse"
                        name.contains("respiratory", ignoreCase = true) -> "respiratory rate"
                        name.contains("oxygen", ignoreCase = true) || name.contains("spo2", ignoreCase = true) -> "oxygen saturation"
                        name.contains("temp", ignoreCase = true) -> "temperature"
                        else -> name
                    }

                    speechBuilder.append("$speechName is $interpText at $value $unit. ")
                } catch (e: Exception) {
                    Log.e(TAG, "Error parsing critical vital: ${e.message}")
                }
            }
            if (count > 3) {
                speechBuilder.append("Plus ${count - 3} more critical vitals.")
            }

            // Use QUEUE_FLUSH to speak vitals FIRST (most urgent safety alert)
            speak(speechBuilder.toString(), TextToSpeech.QUEUE_FLUSH)
            Log.d(TAG, "Spoke critical vital alert: $count critical vitals")
        }
    }

    /**
     * Speak medication interaction alerts when patient is loaded (safety-critical)
     * High severity interactions always spoken regardless of speech feedback toggle
     */
    private fun speakMedicationInteractions(patient: JSONObject) {
        val interactions = patient.optJSONArray("medication_interactions")
        if (interactions != null && interactions.length() > 0) {
            // Filter for high severity interactions
            val highSeverityInteractions = mutableListOf<JSONObject>()
            for (i in 0 until interactions.length()) {
                try {
                    val interaction = interactions.getJSONObject(i)
                    if (interaction.optString("severity", "") == "high") {
                        highSeverityInteractions.add(interaction)
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Error parsing interaction: ${e.message}")
                }
            }

            if (highSeverityInteractions.isEmpty()) return

            val count = highSeverityInteractions.size
            val interactionWord = if (count == 1) "drug interaction" else "drug interactions"

            val speechBuilder = StringBuilder()
            speechBuilder.append("Warning: Patient has $count high-risk $interactionWord. ")

            // Speak up to 2 high severity interactions
            for (i in 0 until minOf(count, 2)) {
                val interaction = highSeverityInteractions[i]
                val drug1 = interaction.optString("drug1", "").split(" ").firstOrNull() ?: "medication"
                val drug2 = interaction.optString("drug2", "").split(" ").firstOrNull() ?: "medication"
                val effect = interaction.optString("effect", "potential interaction")

                // Simplify effect for speech (take first part before dash or period)
                val shortEffect = effect.split(" - ").firstOrNull()?.split(".")?.firstOrNull() ?: effect

                speechBuilder.append("$drug1 with $drug2: $shortEffect. ")
            }
            if (count > 2) {
                speechBuilder.append("Plus ${count - 2} more interactions.")
            }

            // Use QUEUE_ADD so it plays after vitals/allergies/labs
            speak(speechBuilder.toString(), TextToSpeech.QUEUE_ADD)
            Log.d(TAG, "Spoke medication interaction alert: $count high-severity interactions")
        }
    }

    private fun increaseFontSize() {
        if (currentFontSizeLevel < FONT_SIZE_EXTRA_LARGE) {
            currentFontSizeLevel++
            saveFontSizeSetting()
            Toast.makeText(this, "Font size: ${getFontSizeName()}", Toast.LENGTH_SHORT).show()
            transcriptText.text = "Font: ${getFontSizeName()}"
            Log.d(TAG, "Font size increased to ${getFontSizeName()}")
        } else {
            Toast.makeText(this, "Font size already at maximum", Toast.LENGTH_SHORT).show()
        }
    }

    private fun decreaseFontSize() {
        if (currentFontSizeLevel > FONT_SIZE_SMALL) {
            currentFontSizeLevel--
            saveFontSizeSetting()
            Toast.makeText(this, "Font size: ${getFontSizeName()}", Toast.LENGTH_SHORT).show()
            transcriptText.text = "Font: ${getFontSizeName()}"
            Log.d(TAG, "Font size decreased to ${getFontSizeName()}")
        } else {
            Toast.makeText(this, "Font size already at minimum", Toast.LENGTH_SHORT).show()
        }
    }

    private fun setFontSize(level: Int) {
        currentFontSizeLevel = level.coerceIn(FONT_SIZE_SMALL, FONT_SIZE_EXTRA_LARGE)
        saveFontSizeSetting()
        Toast.makeText(this, "Font size: ${getFontSizeName()}", Toast.LENGTH_SHORT).show()
        transcriptText.text = "Font: ${getFontSizeName()}"
        Log.d(TAG, "Font size set to ${getFontSizeName()}")
    }

    // ============ Auto-Scroll Methods ============

    private fun enableAutoScroll() {
        isAutoScrollEnabled = true
        Toast.makeText(this, "Auto-scroll enabled", Toast.LENGTH_SHORT).show()
        transcriptText.text = "Auto-scroll: ON"
        Log.d(TAG, "Auto-scroll enabled")
        // Immediately scroll to bottom
        liveTranscriptScrollView?.post {
            liveTranscriptScrollView?.fullScroll(android.view.View.FOCUS_DOWN)
        }
    }

    private fun disableAutoScroll() {
        isAutoScrollEnabled = false
        Toast.makeText(this, "Auto-scroll disabled", Toast.LENGTH_SHORT).show()
        transcriptText.text = "Auto-scroll: OFF"
        Log.d(TAG, "Auto-scroll disabled")
    }

    private fun toggleAutoScroll() {
        if (isAutoScrollEnabled) {
            disableAutoScroll()
        } else {
            enableAutoScroll()
        }
    }

    private fun checkPermissions() {
        val missingPermissions = requiredPermissions.filter {
            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED
        }

        if (missingPermissions.isNotEmpty()) {
            ActivityCompat.requestPermissions(
                this,
                missingPermissions.toTypedArray(),
                PERMISSION_REQUEST_CODE
            )
        } else {
            initializeSpeechRecognizer()
        }
    }

    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)

        if (requestCode == PERMISSION_REQUEST_CODE) {
            if (grantResults.all { it == PackageManager.PERMISSION_GRANTED }) {
                initializeSpeechRecognizer()
            } else {
                Toast.makeText(this, "Permissions required for MDx Vision", Toast.LENGTH_LONG).show()
            }
        }
    }

    private fun initializeSpeechRecognizer() {
        if (SpeechRecognizer.isRecognitionAvailable(this)) {
            speechRecognizer = SpeechRecognizer.createSpeechRecognizer(this)
            speechRecognizer.setRecognitionListener(recognitionListener)
            Log.d(TAG, "Speech recognizer initialized")

            // Auto-enable continuous listening for hands-free AR glasses operation
            isContinuousListening = true
            statusText.text = "Listening..."
            transcriptText.text = "Just speak naturally"
            startVoiceRecognition()
        } else {
            // Fallback to WebSocket transcription for Vuzix/devices without Google Speech
            Log.w(TAG, "Google Speech not available - using WebSocket fallback")
            useWebSocketForCommands = true
            isContinuousListening = true
            statusText.text = "Connecting..."
            transcriptText.text = "Using cloud speech recognition"
            startWebSocketCommandListening()
        }
    }

    /**
     * Start WebSocket-based voice command listening (Vuzix fallback)
     * Uses AssemblyAI/Deepgram for speech recognition when Google Speech unavailable
     */
    private fun startWebSocketCommandListening() {
        if (isCommandListening) {
            Log.d(TAG, "Command listening already active")
            return
        }

        if (ContextCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO)
            != PackageManager.PERMISSION_GRANTED
        ) {
            Toast.makeText(this, "Microphone permission required", Toast.LENGTH_SHORT).show()
            return
        }

        // Create command streaming service
        commandStreamingService = AudioStreamingService(this) { result ->
            runOnUiThread {
                if (result.isFinal && result.text.isNotBlank()) {
                    Log.d(TAG, "WebSocket command received: ${result.text}")
                    statusText.text = "Processing..."
                    transcriptText.text = "\"${result.text}\""

                    // Process as voice command
                    processTranscript(result.text)

                    // Continue listening after processing
                    transcriptText.postDelayed({
                        if (useWebSocketForCommands && isContinuousListening) {
                            statusText.text = "Listening..."
                        }
                    }, 1000)
                } else if (!result.isFinal && result.text.isNotBlank()) {
                    // Show partial transcript
                    transcriptText.text = "\"${result.text}\"..."
                }
            }
        }

        if (commandStreamingService?.startStreaming() == true) {
            isCommandListening = true
            statusText.text = "Listening..."
            Log.d(TAG, "WebSocket command listening started")
            speakFeedback("Ready for voice commands")
        } else {
            Log.e(TAG, "Failed to start WebSocket command listening")
            statusText.text = "Connection failed"
            transcriptText.text = "Check network connection"
            speakFeedback("Voice connection failed. Check network.")
        }
    }

    /**
     * Stop WebSocket command listening
     */
    private fun stopWebSocketCommandListening() {
        if (isCommandListening) {
            commandStreamingService?.stopStreaming()
            commandStreamingService = null
            isCommandListening = false
            Log.d(TAG, "WebSocket command listening stopped")
        }
    }

    private fun startVoiceRecognition() {
        val intent = Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {
            putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)
            putExtra(RecognizerIntent.EXTRA_PARTIAL_RESULTS, true)
            putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, 1)
            // Multi-language support: use current locale for speech recognition
            putExtra(RecognizerIntent.EXTRA_LANGUAGE, currentLocale.toLanguageTag())
            putExtra(RecognizerIntent.EXTRA_LANGUAGE_PREFERENCE, currentLocale.toLanguageTag())
        }

        try {
            speechRecognizer.startListening(intent)
            val listeningText = getLocalizedMessage("listening") ?: "Listening..."
            statusText.text = listeningText
            Log.d(TAG, "Voice recognition started in ${currentLocale.displayLanguage}")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to start voice recognition: ${e.message}")
        }
    }

    private val recognitionListener = object : RecognitionListener {
        override fun onReadyForSpeech(params: Bundle?) {
            Log.d(TAG, "Ready for speech")
        }

        override fun onBeginningOfSpeech() {
            Log.d(TAG, "Beginning of speech")
        }

        override fun onRmsChanged(rmsdB: Float) {}

        override fun onBufferReceived(buffer: ByteArray?) {}

        override fun onEndOfSpeech() {
            Log.d(TAG, "End of speech")
            statusText.text = "Processing..."
        }

        override fun onError(error: Int) {
            val errorMessage = when (error) {
                SpeechRecognizer.ERROR_AUDIO -> "Audio error"
                SpeechRecognizer.ERROR_CLIENT -> "Client error"
                SpeechRecognizer.ERROR_INSUFFICIENT_PERMISSIONS -> "Insufficient permissions"
                SpeechRecognizer.ERROR_NETWORK -> "Network error"
                SpeechRecognizer.ERROR_NETWORK_TIMEOUT -> "Network timeout"
                SpeechRecognizer.ERROR_NO_MATCH -> "No speech detected"
                SpeechRecognizer.ERROR_RECOGNIZER_BUSY -> "Recognizer busy"
                SpeechRecognizer.ERROR_SERVER -> "Server error"
                SpeechRecognizer.ERROR_SPEECH_TIMEOUT -> "No speech detected"
                else -> "Unknown error"
            }
            Log.e(TAG, "Speech error: $errorMessage")

            // Continue listening in ambient mode
            if (isAmbientMode) {
                transcriptText.postDelayed({
                    if (isAmbientMode) startAmbientVoiceRecognition()
                }, 1000)
            } else if (isDocumentationMode) {
                statusText.text = "DOCUMENTING"
                transcriptText.text = "Listening..."
                transcriptText.postDelayed({
                    if (isDocumentationMode) startVoiceRecognition()
                }, 2000)
            } else if (isContinuousListening) {
                statusText.text = "Listening..."
                transcriptText.text = "Speak a command..."
                transcriptText.postDelayed({
                    if (isContinuousListening) startVoiceRecognition()
                }, 2000)
            } else {
                statusText.text = "MDx Vision"
                // Reset to default message after 2 seconds
                transcriptText.text = errorMessage
                transcriptText.postDelayed({
                    transcriptText.text = "Tap or speak a command"
                }, 2000)
            }
        }

        override fun onResults(results: Bundle?) {
            val matches = results?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)
            val transcript = matches?.firstOrNull() ?: ""

            Log.d(TAG, "Transcript: $transcript")

            // ═══ AMBIENT MODE HANDLING ═══
            if (isAmbientMode && transcript.isNotBlank()) {
                val lower = transcript.lowercase()

                // Check for stop commands
                when {
                    lower.contains("stop ambient") || lower.contains("end ambient") ||
                    lower.contains("finish ambient") || lower.contains("stop listening") -> {
                        Log.d(TAG, "ACI: Stop command detected via local recognition")
                        stopAmbientMode(true)
                        return
                    }
                    lower.contains("cancel ambient") || lower.contains("discard") ||
                    lower.contains("never mind") -> {
                        Log.d(TAG, "ACI: Cancel command detected via local recognition")
                        stopAmbientMode(false)
                        return
                    }
                    lower.contains("generate note") || lower.contains("create note") ||
                    lower.contains("make note") || lower.contains("document this") -> {
                        Log.d(TAG, "ACI: Generate note command detected via local recognition")
                        stopAmbientMode(true)
                        return
                    }
                }

                // Filter voice commands from transcript before adding to buffer
                val cleanedTranscript = filterVoiceCommandsFromTranscript(transcript)

                if (cleanedTranscript != null) {
                    // Add cleaned transcript to ambient buffer
                    if (ambientTranscriptBuffer.isNotEmpty()) {
                        ambientTranscriptBuffer.append(" ")
                    }

                    // Identify speaker and add segment
                    val speaker = identifySpeaker(cleanedTranscript)
                    val segment = SpeakerSegment(speaker, cleanedTranscript, System.currentTimeMillis())
                    extractedEntities.speakerSegments.add(segment)
                    ambientTranscriptBuffer.append("[$speaker] $cleanedTranscript")

                    // Extract clinical entities from cleaned transcript
                    extractClinicalEntities(cleanedTranscript)
                } else {
                    Log.d(TAG, "ACI: Skipped voice command segment")
                }

                // Update display
                updateAciDisplay()
                aciTranscriptText?.text = ambientTranscriptBuffer.toString().takeLast(500)

                // Continue listening
                transcriptText.postDelayed({
                    if (isAmbientMode) startAmbientVoiceRecognition()
                }, 500)
                return
            }

            if (isContinuousListening) {
                // NLP mode - process all speech as commands directly (no wake word needed)
                if (transcript.isNotBlank()) {
                    statusText.text = "Processing..."
                    transcriptText.text = "\"$transcript\""
                    processTranscript(transcript)
                }

                // Continue listening in continuous mode (longer delay to avoid client errors)
                transcriptText.postDelayed({
                    if (isContinuousListening) {
                        statusText.text = "Listening..."
                        startVoiceRecognition()
                    }
                }, 1500)
            } else {
                // Normal mode - process transcript directly
                transcriptText.text = "\"$transcript\""
                statusText.text = "MDx Vision"
                processTranscript(transcript)
            }
        }

        override fun onPartialResults(partialResults: Bundle?) {
            val matches = partialResults?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)
            val partial = matches?.firstOrNull() ?: ""

            if (isAmbientMode) {
                // Show partial in ACI overlay
                aciTranscriptText?.text = "${ambientTranscriptBuffer.toString().takeLast(400)}\n🎤 $partial"
            } else {
                transcriptText.text = "\"$partial\"..."
            }
        }

        override fun onEvent(eventType: Int, params: Bundle?) {}
    }

    private fun processTranscript(transcript: String) {
        // If in documentation mode, collect transcripts
        if (isDocumentationMode) {
            documentationTranscripts.add(transcript)
            val count = documentationTranscripts.size
            transcriptText.text = "Recording... ($count segments)\nLatest: \"$transcript\""
            patientDataText.text = "Tap 'Start Note' to generate SOAP note"

            // Continue listening
            startVoiceRecognition()
            return
        }

        // Multi-language: Translate Spanish commands to English for processing
        val translatedTranscript = translateCommand(transcript)

        // Parse voice commands for patient lookup
        val lower = translatedTranscript.lowercase()
        val originalLower = transcript.lowercase()  // Keep original for language detection

        // ═══ LANGUAGE SWITCHING (works in any language) ═══
        when {
            // English language switch commands
            originalLower.contains("switch to english") || originalLower.contains("language english") ||
            originalLower.contains("speak english") || originalLower.contains("english mode") -> {
                switchLanguage(LANG_ENGLISH)
                startVoiceRecognition()
                return
            }
            // Spanish language switch commands
            originalLower.contains("cambiar a español") || originalLower.contains("language spanish") ||
            originalLower.contains("español") || originalLower.contains("spanish mode") ||
            originalLower.contains("hablar español") || originalLower.contains("switch to spanish") -> {
                switchLanguage(LANG_SPANISH)
                startVoiceRecognition()
                return
            }
            // Mandarin language switch commands
            originalLower.contains("切换到中文") || originalLower.contains("language chinese") ||
            originalLower.contains("chinese mode") || originalLower.contains("中文") ||
            originalLower.contains("mandarin") || originalLower.contains("switch to chinese") -> {
                switchLanguage(LANG_MANDARIN)
                startVoiceRecognition()
                return
            }
            // Portuguese language switch commands
            originalLower.contains("mudar para português") || originalLower.contains("language portuguese") ||
            originalLower.contains("portuguese mode") || originalLower.contains("português") ||
            originalLower.contains("switch to portuguese") -> {
                switchLanguage(LANG_PORTUGUESE)
                startVoiceRecognition()
                return
            }
            // Russian language switch commands
            originalLower.contains("переключить на русский") || originalLower.contains("language russian") ||
            originalLower.contains("russian mode") || originalLower.contains("русский") ||
            originalLower.contains("говорить по-русски") || originalLower.contains("switch to russian") ||
            originalLower.contains("по-русски") -> {
                switchLanguage(LANG_RUSSIAN)
                startVoiceRecognition()
                return
            }
            // Show language options
            originalLower.contains("language options") || originalLower.contains("change language") ||
            originalLower.contains("idioma") || originalLower.contains("语言") ||
            originalLower.contains("язык") -> {
                showLanguageOptions()
                startVoiceRecognition()
                return
            }
        }

        // Update activity on any voice command
        updateLastActivity()

        // If session is locked, handle unlock
        if (isSessionLocked) {
            // If awaiting TOTP code (device is paired), process spoken digits
            if (isAwaitingTotpCode) {
                // DEBUG: "test unlock" bypasses TOTP in debug mode
                if (DEBUG_SKIP_AUTH && (lower.contains("test unlock") || lower.contains("debug unlock") || lower.contains("skip auth"))) {
                    Log.w(TAG, "⚠️ DEBUG: Bypassing TOTP authentication")
                    isAwaitingTotpCode = false
                    isSessionLocked = false
                    hideLockScreenOverlay()
                    updateLastActivity()
                    speakFeedback("Debug mode. Authentication bypassed.")
                    Toast.makeText(this, "⚠️ DEBUG: Auth bypassed", Toast.LENGTH_SHORT).show()
                    return
                }
                // Handle "pair device" command even when locked
                if (lower.contains("pair device") || lower.contains("pair glasses")) {
                    startDevicePairing()
                    return
                }
                // Handle "clear" to reset entered digits
                if (lower.contains("clear") || lower.contains("reset") || lower.contains("start over")) {
                    totpDigitBuffer.clear()
                    updateTotpDisplay()
                    speakFeedback("Cleared. Say your 6-digit code.")
                    startVoiceRecognition()
                    return
                }
                // Process spoken digits for TOTP
                processTotpVoiceInput(lower)
                return
            } else {
                // Unpaired device: simple unlock
                if (lower.contains("unlock")) {
                    unlockSession()
                }
                startVoiceRecognition()
                return
            }
        }

        // If in dictation mode, handle dictation-specific commands or capture text
        if (isDictationMode) {
            when {
                lower.contains("stop dictating") || lower.contains("stop dictation") ||
                lower.contains("end dictation") || lower.contains("done dictating") ||
                lower.contains("finish dictating") -> {
                    stopDictation()
                }
                lower.contains("cancel dictation") || lower.contains("cancel dictating") ||
                lower.contains("discard dictation") -> {
                    cancelDictation()
                }
                else -> {
                    // Capture speech to dictation buffer
                    addToDictationBuffer(transcript)
                }
            }
            startVoiceRecognition()
            return
        }

        // Fuzzy match for "patient" - common misrecognitions
        val hasPatient = lower.contains("patient") || lower.contains("patine") ||
                         lower.contains("patience") || lower.contains("patent")

        val parsedIntents = parseVoiceIntents(translatedTranscript)
        if (parsedIntents.size > 1) {
            lifecycleScope.launch {
                voiceIntentExecutor.execute(parsedIntents)
            }
            return
        }

        when {
            hasPatient && lower.contains("load") -> {
                // Extract patient ID if mentioned
                val words = transcript.split(" ")
                val idIndex = words.indexOfFirst { it.all { c -> c.isDigit() } }
                val patientId = if (idIndex >= 0) words[idIndex] else TEST_PATIENT_ID
                fetchPatientData(patientId)
            }
            (hasPatient && lower.contains("find")) || lower.contains("search") -> {
                // Patient search by name
                val name = transcript.replace(Regex("(?i)(find|search|patient|patine|patience)"), "").trim()
                if (name.isNotEmpty()) {
                    searchPatients(name)
                }
            }
            lower.contains("start note") || lower.contains("start documentation") -> {
                // Voice command to start documentation
                if (!isDocumentationMode) toggleDocumentationMode()
            }
            lower.contains("stop note") || lower.contains("end note") || lower.contains("finish note") -> {
                // Voice command to stop documentation and generate note
                if (isDocumentationMode) toggleDocumentationMode()
            }
            lower.contains("save note") || lower.contains("save the note") || lower.contains("submit note") -> {
                // Voice command to save the current note
                saveCurrentNote()
            }
            lower.contains("push note") || lower.contains("send to ehr") || lower.contains("push to ehr") || lower.contains("upload note") -> {
                // Voice command to push saved note to EHR - requires voiceprint verification
                verifyVoiceprintForOperation("Push Note to EHR") { verified ->
                    if (verified) {
                        pushNoteToEhr()
                    } else {
                        speakFeedback("Note push cancelled. Voice verification failed.")
                    }
                }
            }
            // ═══ CRUD WRITE-BACK VOICE COMMANDS ═══
            lower.contains("push vitals") || lower.contains("send vitals") || lower.contains("upload vitals") -> {
                // Push captured vitals to EHR - requires voiceprint verification
                verifyVoiceprintForOperation("Push Vitals to EHR") { verified ->
                    if (verified) {
                        pushCapturedVitalsToEhr()
                    } else {
                        speakFeedback("Vitals push cancelled. Voice verification failed.")
                    }
                }
            }
            lower.contains("push orders") || lower.contains("send orders") || lower.contains("submit orders") -> {
                // Push confirmed orders to EHR - requires voiceprint verification
                verifyVoiceprintForOperation("Push Orders to EHR") { verified ->
                    if (verified) {
                        pushOrdersToEhr()
                    } else {
                        speakFeedback("Orders push cancelled. Voice verification failed.")
                    }
                }
            }
            lower.contains("sync all") || lower.contains("sync data") || lower.contains("sync everything") -> {
                // Sync all pending offline data
                syncAllPendingCrudData()
                speakFeedback("Syncing all pending data")
            }
            lower.startsWith("add allergy to ") || lower.startsWith("add allergy ") ||
            lower.startsWith("patient allergic to ") || lower.startsWith("allergic to ") -> {
                // Start allergy recording: "add allergy to penicillin", "allergic to sulfa"
                val substance = when {
                    lower.startsWith("add allergy to ") -> transcript.substringAfter("add allergy to ").trim()
                    lower.startsWith("add allergy ") -> transcript.substringAfter("add allergy ").trim()
                    lower.startsWith("patient allergic to ") -> transcript.substringAfter("patient allergic to ").trim()
                    lower.startsWith("allergic to ") -> transcript.substringAfter("allergic to ").trim()
                    else -> ""
                }
                if (substance.isNotEmpty()) {
                    promptAllergyDetails(substance)
                } else {
                    speakFeedback("Say add allergy to, followed by the substance name.")
                }
            }
            lower == "high" || lower == "severe" || lower == "high severity" || lower == "anaphylaxis" -> {
                // Set allergy severity (if pending allergy)
                if (pendingAllergySubstance != null) {
                    setAllergyCriticality("high")
                }
            }
            lower == "low" || lower == "mild" || lower == "low severity" || lower == "rash" -> {
                // Set allergy severity (if pending allergy)
                if (pendingAllergySubstance != null) {
                    setAllergyCriticality("low")
                }
            }
            lower == "unknown" || lower == "unknown severity" -> {
                // Set allergy severity (if pending allergy)
                if (pendingAllergySubstance != null) {
                    setAllergyCriticality("unknown")
                }
            }
            lower.startsWith("reaction ") || lower.startsWith("causes ") -> {
                // Add reaction to pending allergy: "reaction hives", "causes swelling"
                val reaction = when {
                    lower.startsWith("reaction ") -> transcript.substringAfter("reaction ").trim()
                    lower.startsWith("causes ") -> transcript.substringAfter("causes ").trim()
                    else -> ""
                }
                if (reaction.isNotEmpty() && pendingAllergySubstance != null) {
                    addAllergyReaction(reaction)
                }
            }
            lower.contains("confirm allergy") || lower.contains("save allergy") || lower.contains("submit allergy") -> {
                // Confirm and push allergy - requires voiceprint verification
                verifyVoiceprintForOperation("Add Allergy to EHR") { verified ->
                    if (verified) {
                        confirmAndPushAllergy()
                    } else {
                        speakFeedback("Allergy recording cancelled. Voice verification failed.")
                        clearPendingAllergy()
                    }
                }
            }
            lower.contains("cancel allergy") || lower.contains("clear allergy") -> {
                // Cancel pending allergy
                clearPendingAllergy()
                speakFeedback("Allergy cancelled")
                transcriptText.text = "Allergy recording cancelled"
            }
            lower.startsWith("discontinue ") || lower.startsWith("stop medication ") || lower.startsWith("d c ") || lower.startsWith("dc ") -> {
                // Discontinue medication: "discontinue metformin", "stop medication lisinopril"
                val medName = when {
                    lower.startsWith("discontinue ") -> transcript.substringAfter("discontinue ").trim()
                    lower.startsWith("stop medication ") -> transcript.substringAfter("stop medication ").trim()
                    lower.startsWith("d c ") -> transcript.substringAfter("d c ").trim()
                    lower.startsWith("dc ") -> transcript.substringAfter("dc ").trim()
                    else -> ""
                }
                if (medName.isNotEmpty()) {
                    promptDiscontinueMedication(medName)
                }
            }
            lower.startsWith("hold ") && !lower.contains("hold off") -> {
                // Hold medication: "hold metformin", "hold lisinopril"
                val medName = transcript.substringAfter("hold ").trim()
                if (medName.isNotEmpty() && medName.length > 2) {  // Avoid false positives
                    promptHoldMedication(medName)
                }
            }
            lower.startsWith("reason ") && pendingMedicationUpdate != null -> {
                // Set reason for medication update: "reason patient intolerance"
                val reason = transcript.substringAfter("reason ").trim()
                if (reason.isNotEmpty()) {
                    setMedicationUpdateReason(reason)
                }
            }
            (lower == "confirm" || lower.contains("confirm medication") || lower.contains("yes discontinue") || lower.contains("yes hold")) && pendingMedicationUpdate != null -> {
                // Confirm medication update - requires voiceprint verification
                val medUpdate = pendingMedicationUpdate
                verifyVoiceprintForOperation("Update Medication Status") { verified ->
                    if (verified && medUpdate != null) {
                        confirmMedicationUpdate()
                    } else {
                        speakFeedback("Medication update cancelled. Voice verification failed.")
                        clearPendingMedicationUpdate()
                    }
                }
            }
            (lower == "cancel" || lower.contains("cancel medication") || lower.contains("no discontinue") || lower.contains("don't discontinue")) && pendingMedicationUpdate != null -> {
                // Cancel medication update
                cancelMedicationUpdate()
            }
            lower.contains("view transcript") || lower.contains("show transcript") ||
            lower.contains("full transcript") || lower.contains("see transcript") -> {
                // Voice command to view full ambient transcript (for records)
                viewFullTranscript()
            }
            lower.contains("reset note") || lower.contains("undo changes") || lower.contains("undo edit") || lower.contains("restore note") -> {
                // Voice command to reset edited note to original
                resetNoteEdits()
            }
            lower.contains("edit note") || lower.contains("modify note") -> {
                // Voice command to focus on note editing (bring up keyboard)
                focusNoteEdit()
            }
            // Voice Note Editing Commands
            (lower.contains("change") || lower.contains("set")) &&
                (lower.contains("subjective") || lower.contains("objective") ||
                 lower.contains("assessment") || lower.contains("plan") ||
                 lower.contains("chief complaint") || lower.contains("diagnosis")) &&
                lower.contains(" to ") -> {
                // "Change assessment to viral URI", "Set plan to follow up in 1 week"
                val section = extractSectionFromCommand(lower)
                val content = extractContentAfter(transcript, " to ")
                if (section != null && content.isNotEmpty()) {
                    updateNoteSection(section, content)
                } else {
                    Toast.makeText(this, "Say: change [section] to [content]", Toast.LENGTH_SHORT).show()
                }
            }
            (lower.contains("add to") || lower.contains("append to") || lower.contains("include in")) &&
                (lower.contains("subjective") || lower.contains("objective") ||
                 lower.contains("assessment") || lower.contains("plan")) -> {
                // "Add to plan: order CBC", "Append to assessment: rule out strep"
                val section = extractSectionFromCommand(lower)
                // Extract content after colon or after the section name
                val content = if (transcript.contains(":")) {
                    transcript.substringAfter(":").trim()
                } else {
                    extractContentAfter(transcript, section ?: "")
                }
                if (section != null && content.isNotEmpty()) {
                    appendToNoteSection(section, content)
                } else {
                    Toast.makeText(this, "Say: add to [section]: [content]", Toast.LENGTH_SHORT).show()
                }
            }
            lower.contains("delete last sentence") || lower.contains("remove last sentence") -> {
                deleteLastSentence()
            }
            lower.contains("delete last line") || lower.contains("remove last line") -> {
                deleteLastLine()
            }
            lower.contains("delete") && lower.contains("item") && Regex("\\d+").containsMatchIn(lower) -> {
                // "Delete plan item 2", "Remove assessment item 1"
                val section = extractSectionFromCommand(lower)
                val itemMatch = Regex("\\d+").find(lower)
                if (section != null && itemMatch != null) {
                    val itemNumber = itemMatch.value.toIntOrNull() ?: 0
                    deleteSectionItem(section, itemNumber)
                }
            }
            lower.contains("clear") && (lower.contains("subjective") || lower.contains("objective") ||
                lower.contains("assessment") || lower.contains("plan")) -> {
                // "Clear assessment", "Clear plan"
                val section = extractSectionFromCommand(lower)
                if (section != null) {
                    clearSection(section)
                }
            }
            lower.contains("insert") && lower.contains("normal") && lower.contains("exam") -> {
                insertMacro("normal_exam")
            }
            lower.contains("insert") && lower.contains("normal") && lower.contains("vital") -> {
                insertMacro("normal_vitals")
            }
            lower.contains("insert") && (lower.contains("negative ros") || lower.contains("negative review")) -> {
                insertMacro("negative_ros")
            }
            lower.contains("insert") && lower.contains("follow") && lower.contains("up") -> {
                insertMacro("follow_up")
            }
            lower.contains("insert") && lower.contains("diabetes") -> {
                insertMacro("diabetes_followup")
            }
            lower.contains("insert") && lower.contains("hypertension") -> {
                insertMacro("hypertension_followup")
            }
            lower == "undo" || lower.contains("undo last") || lower.contains("undo change") -> {
                undoLastEdit()
            }
            lower.contains("live transcri") || lower.contains("start transcri") || lower.contains("transcribe") -> {
                // Voice command to start/stop live transcription
                toggleLiveTranscription()
            }
            lower.contains("stop transcri") -> {
                // Voice command to stop live transcription
                if (isLiveTranscribing) stopLiveTranscription()
            }
            // ═══ AMBIENT CLINICAL INTELLIGENCE COMMANDS ═══
            lower.contains("ambient mode") || lower.contains("start ambient") ||
            lower.contains("starts ambient") || lower.contains("ambient listening") ||
            lower.contains("clinical intelligence") || lower.contains("room mode") ||
            lower.contains("auto document") || lower.contains("auto-document") -> {
                // Start Ambient Clinical Intelligence mode
                if (!isAmbientMode) {
                    startAmbientMode()
                } else {
                    Toast.makeText(this, "Ambient mode already active", Toast.LENGTH_SHORT).show()
                }
            }
            lower.contains("stop ambient") || lower.contains("end ambient") ||
            lower.contains("finish ambient") || (isAmbientMode && lower.contains("generate note")) -> {
                // Stop ambient mode and generate note
                if (isAmbientMode) {
                    stopAmbientMode(true)
                }
            }
            lower.contains("cancel ambient") || lower.contains("discard ambient") -> {
                // Cancel ambient mode without generating
                if (isAmbientMode) {
                    stopAmbientMode(false)
                    hideAciOverlay()
                }
            }
            lower.contains("show entities") || lower.contains("what did you detect") ||
            lower.contains("aci status") || lower.contains("ambient status") -> {
                // Show detected entities
                showAciEntities()
            }
            // ═══ DIFFERENTIAL DIAGNOSIS COMMANDS ═══
            lower.contains("differential diagnosis") || lower.contains("differential") ||
            lower == "ddx" || lower.contains(" ddx") ||
            lower.contains("what could this be") || lower.contains("possible diagnoses") ||
            lower.contains("suggest diagnosis") || lower.contains("diagnose this") -> {
                // Generate AI differential diagnosis
                generateDifferentialDiagnosis()
            }
            lower.contains("read differential") || lower.contains("speak ddx") ||
            lower.contains("read ddx") || lower.contains("say differential") -> {
                // TTS readout of differential diagnosis
                speakDdxResults()
            }
            // ═══ AI CLINICAL CO-PILOT COMMANDS (Feature #78) ═══
            lower.contains("hey copilot") || lower.contains("ask copilot") ||
            lower.contains("activate copilot") -> {
                // Activate copilot mode
                activateCopilotMode()
            }
            lower.startsWith("copilot ") -> {
                // Direct question to copilot: "copilot what should I order for chest pain"
                val question = transcript.substringAfter("copilot ").trim()
                if (question.isNotBlank()) {
                    sendCopilotQuestion(question)
                }
            }
            lower.contains("what should i") || lower.contains("what do you think") ||
            lower.contains("can you suggest") || lower.contains("help me with") -> {
                // Natural clinical question triggers (if copilot is active or question is clinical)
                if (isCopilotActive || lower.contains("diagnos") || lower.contains("order") ||
                    lower.contains("workup") || lower.contains("treat") || lower.contains("prescribe")) {
                    sendCopilotQuestion(transcript)
                }
            }
            lower.contains("tell me more") || lower.contains("elaborate") ||
            lower.contains("explain further") || lower.contains("go on") -> {
                // Follow-up request
                sendCopilotFollowUp("Tell me more about that")
            }
            lower.contains("suggest next") || lower.contains("what next") ||
            lower.contains("next steps") || lower.contains("what else") -> {
                // Ask for next step suggestions
                sendCopilotFollowUp("What should I do next?")
            }
            lower.contains("clear copilot") || lower.contains("reset copilot") ||
            lower.contains("new conversation") -> {
                // Clear copilot history
                clearCopilotHistory()
            }
            // Multi-Turn Clinical Reasoning (Feature #95 - Jarvis Wave 1)
            lower.contains("explain why") || lower.contains("why do you think") ||
            lower.contains("teach me") || lower.contains("explain reasoning") -> {
                // Teaching mode - explain clinical reasoning
                val question = transcript.trim()
                sendCopilotTeachingMode(question)
            }
            lower.contains("second opinion") || lower.contains("what else could it be") ||
            lower.contains("challenge") || lower.contains("other possibilities") ||
            lower.contains("what am i missing") -> {
                // Second opinion mode - challenge thinking
                val question = transcript.trim()
                sendCopilotSecondOpinion(question)
            }
            lower.contains("what questions") || lower.contains("clarify") ||
            lower.contains("what should i ask") -> {
                // Clarify mode - AI asks clarifying questions
                val question = lastCopilotQuestion.ifEmpty { "What additional information would help?" }
                sendCopilotClarifyMode(question)
            }
            // ═══ IMAGE ANALYSIS COMMANDS (Feature #70) ═══
            lower.contains("take photo") || lower.contains("capture image") ||
            lower.contains("take picture") || lower.contains("take image") -> {
                // General image capture
                startImageCapture(null)
            }
            lower.contains("analyze wound") || lower.contains("wound photo") ||
            lower.contains("capture wound") || lower.contains("wound image") -> {
                // Wound-specific image capture
                startImageCapture("wound")
            }
            lower.contains("analyze rash") || lower.contains("skin rash") ||
            lower.contains("capture rash") || lower.contains("skin photo") ||
            lower.contains("dermatology") -> {
                // Dermatology/rash image capture
                startImageCapture("rash")
            }
            lower.contains("analyze xray") || lower.contains("x-ray") ||
            lower.contains("capture xray") || lower.contains("radiology") -> {
                // X-ray image capture
                startImageCapture("xray")
            }
            lower.contains("read analysis") || lower.contains("image results") ||
            lower.contains("speak analysis") || lower.contains("read image") -> {
                // TTS readout of image analysis
                speakImageAnalysisResults()
            }
            // ═══ BILLING/CODING COMMANDS (Feature #71) ═══
            lower.contains("create claim") || lower.contains("bill this") ||
            lower.contains("start billing") || lower.contains("billing for this") -> {
                // Create billing claim from current saved note
                lastSavedNoteId?.let { noteId ->
                    createClaimFromNote(noteId)
                } ?: run {
                    speakFeedback("No saved note. Save a note first before creating a claim.")
                    Toast.makeText(this, "Save note first", Toast.LENGTH_SHORT).show()
                }
            }
            lower.contains("submit claim") || lower.contains("send claim") ||
            lower.contains("submit billing") -> {
                // Submit current claim (requires confirmation)
                submitBillingClaim()
            }
            lower == "confirm" || lower.contains("confirm submission") ||
            lower.contains("yes submit") || lower.contains("confirm claim") -> {
                // Confirm pending claim submission
                if (isAwaitingClaimConfirmation) {
                    confirmClaimSubmission()
                }
            }
            (lower == "cancel" || lower.contains("cancel submission") ||
            lower.contains("don't submit") || lower.contains("cancel claim")) &&
            isAwaitingClaimConfirmation -> {
                // Cancel pending claim submission
                isAwaitingClaimConfirmation = false
                speakFeedback("Claim submission cancelled.")
                Toast.makeText(this, "Submission cancelled", Toast.LENGTH_SHORT).show()
            }
            lower.contains("show claims") || lower.contains("claim history") ||
            lower.contains("view claims") || lower.contains("billing history") -> {
                // Show claim history for current patient
                showClaimHistory()
            }
            lower.contains("close billing") || lower.contains("hide billing") ||
            lower.contains("exit billing") -> {
                // Close billing UI
                closeBillingUI()
            }
            lower.contains("add diagnosis") || lower.contains("add icd") -> {
                // Add ICD-10 diagnosis to current claim: "add diagnosis J06.9"
                val code = lower
                    .replace("add diagnosis", "")
                    .replace("add icd", "")
                    .replace("code", "")
                    .trim()
                    .uppercase()
                if (code.isNotEmpty() && currentClaim != null) {
                    addDiagnosisToClaim(code)
                } else if (currentClaim == null) {
                    speakFeedback("No active claim. Say create claim first.")
                } else {
                    speakFeedback("Say add diagnosis followed by the I C D 10 code.")
                }
            }
            lower.contains("remove diagnosis") || lower.contains("delete diagnosis") -> {
                // Remove diagnosis by number: "remove diagnosis 2"
                val match = Regex("\\d+").find(lower)
                if (match != null && currentClaim != null) {
                    val index = match.value.toIntOrNull()?.minus(1) ?: -1
                    removeDiagnosisFromClaim(index)
                } else if (currentClaim == null) {
                    speakFeedback("No active claim.")
                } else {
                    speakFeedback("Say remove diagnosis followed by the number.")
                }
            }
            lower.contains("add procedure") || lower.contains("add cpt") -> {
                // Add CPT procedure to current claim: "add procedure 99213"
                val code = lower
                    .replace("add procedure", "")
                    .replace("add cpt", "")
                    .replace("code", "")
                    .trim()
                    .uppercase()
                if (code.isNotEmpty() && currentClaim != null) {
                    addProcedureToClaim(code)
                } else if (currentClaim == null) {
                    speakFeedback("No active claim. Say create claim first.")
                } else {
                    speakFeedback("Say add procedure followed by the C P T code.")
                }
            }
            lower.contains("add modifier") -> {
                // Add modifier to procedure: "add modifier 25 to 1" or "add modifier 25"
                val parts = lower.replace("add modifier", "").trim()
                val modMatch = Regex("([0-9A-Za-z]{2})").find(parts)
                val toMatch = Regex("to\\s+(\\d+)").find(parts)
                if (modMatch != null && currentClaim != null) {
                    val modifier = modMatch.groupValues[1].uppercase()
                    val procIndex = toMatch?.groupValues?.get(1)?.toIntOrNull()?.minus(1) ?: 0
                    addModifierToProcedure(modifier, procIndex)
                } else if (currentClaim == null) {
                    speakFeedback("No active claim.")
                } else {
                    speakFeedback("Say add modifier followed by the modifier code.")
                }
            }
            lower.contains("search icd") || lower.contains("find icd") ||
            lower.contains("lookup icd") -> {
                // Search ICD-10 codes: "search icd hypertension"
                val query = lower
                    .replace("search icd", "")
                    .replace("find icd", "")
                    .replace("lookup icd", "")
                    .replace("code", "")
                    .replace("codes", "")
                    .trim()
                if (query.isNotEmpty()) {
                    searchICD10Codes(query)
                } else {
                    speakFeedback("Say search I C D followed by the term to search.")
                }
            }
            lower.contains("search cpt") || lower.contains("find cpt") ||
            lower.contains("lookup cpt") -> {
                // Search CPT codes: "search cpt office visit"
                val query = lower
                    .replace("search cpt", "")
                    .replace("find cpt", "")
                    .replace("lookup cpt", "")
                    .replace("code", "")
                    .replace("codes", "")
                    .trim()
                if (query.isNotEmpty()) {
                    searchCPTCodes(query)
                } else {
                    speakFeedback("Say search C P T followed by the term to search.")
                }
            }
            // ═══ DNFB (DISCHARGED NOT FINAL BILLED) COMMANDS (Feature #72) ═══
            lower.contains("show dnfb") || lower.contains("dnfb worklist") ||
            lower.contains("dnfb list") || lower.contains("unbilled accounts") ||
            lower.contains("discharged not billed") -> {
                // Show DNFB worklist
                showDNFBWorklist()
            }
            lower.contains("dnfb summary") || lower.contains("dnfb metrics") ||
            lower.contains("unbilled summary") -> {
                // Show DNFB summary metrics
                showDNFBSummary()
            }
            lower.contains("prior auth issue") || lower.contains("prior authorization issue") ||
            lower.contains("prior auth problem") || lower.contains("auth issues") -> {
                // Show prior auth related DNFB
                showPriorAuthIssues()
            }
            (lower.contains("over") && lower.contains("days") &&
             (lower.contains("dnfb") || lower.contains("unbilled") || lower.contains("aging"))) -> {
                // Show aging DNFB: "over 7 days", "dnfb over 14 days"
                val daysMatch = Regex("(\\d+)\\s*days?").find(lower)
                val days = daysMatch?.groupValues?.get(1)?.toIntOrNull() ?: 7
                showDNFBOverDays(days)
            }
            lower.contains("resolve") && Regex("\\d+").containsMatchIn(lower) &&
            (lower.contains("dnfb") || dnfbAccounts.isNotEmpty()) -> {
                // Resolve DNFB account by number: "resolve 1", "resolve dnfb 2"
                val match = Regex("\\d+").find(lower)
                if (match != null) {
                    val index = match.value.toIntOrNull()?.minus(1) ?: -1
                    resolveDNFBAccount(index)
                }
            }
            lower.contains("patient dnfb") || lower.contains("patient unbilled") ||
            (lower.contains("this patient") && lower.contains("dnfb")) -> {
                // Show current patient's DNFB status
                showPatientDNFB()
            }
            // ═══ VUZIX HUD VOICE COMMANDS (Feature #73) ═══
            lower.contains("show hud") || lower.contains("display hud") -> {
                sendHudCommand(VuzixHudService.ACTION_SHOW)
            }
            lower.contains("hide hud") -> {
                sendHudCommand(VuzixHudService.ACTION_HIDE)
            }
            lower.contains("expand hud") || lower.contains("full hud") || lower.contains("full details") -> {
                sendHudCommand(VuzixHudService.ACTION_EXPAND)
            }
            lower.contains("minimize hud") || lower.contains("compact hud") || lower.contains("compact view") -> {
                sendHudCommand(VuzixHudService.ACTION_MINIMIZE)
            }
            lower.contains("toggle hud") -> {
                sendHudCommand(VuzixHudService.ACTION_TOGGLE)
            }
            // ═══ GESTURE CONTROL VOICE COMMANDS (Feature #75) ═══
            lower.contains("enable gesture") || lower.contains("enable gestures") || lower.contains("gestures on") -> {
                enableGestureControl()
            }
            lower.contains("disable gesture") || lower.contains("disable gestures") || lower.contains("gestures off") -> {
                disableGestureControl()
            }
            lower.contains("gesture status") || lower.contains("gesture mode") -> {
                speakGestureStatus()
            }
            // ═══ WINK DETECTION VOICE COMMANDS (Feature #76) ═══
            lower.contains("enable wink") || lower.contains("wink on") -> {
                enableWinkDetection()
            }
            lower.contains("disable wink") || lower.contains("wink off") -> {
                disableWinkDetection()
            }
            lower.contains("wink status") || lower.contains("wink mode") -> {
                speakWinkStatus()
            }
            // ═══ RACIAL MEDICINE AWARENESS COMMANDS (Feature #79) ═══
            lower.contains("skin type") && (lower.contains("set") || Regex("[1-6]|one|two|three|four|five|six").containsMatchIn(lower)) -> {
                // Set Fitzpatrick skin type: "set skin type 5", "skin type six"
                val typeMatch = Regex("([1-6]|one|two|three|four|five|six)").find(lower)
                val type = when (typeMatch?.value) {
                    "1", "one" -> "I"
                    "2", "two" -> "II"
                    "3", "three" -> "III"
                    "4", "four" -> "IV"
                    "5", "five" -> "V"
                    "6", "six" -> "VI"
                    else -> null
                }
                if (type != null) {
                    setSkinType(type)
                } else {
                    speakFeedback("Say skin type followed by a number 1 through 6.")
                }
            }
            lower.contains("pulse ox warning") || lower.contains("oximeter warning") ||
            lower.contains("spo2 alert") || lower.contains("oxygen alert") -> {
                // Show pulse oximeter accuracy alert for current patient
                showPulseOxWarning()
            }
            lower.contains("skin assessment") || lower.contains("skin guidance") ||
            lower.contains("examine skin") || lower.contains("dermatology guidance") -> {
                // Show skin assessment guidance for current skin type
                showSkinAssessmentGuidance()
            }
            lower.contains("medication ancestry") || lower.contains("pharmacogenomics") ||
            lower.contains("drug ancestry") || lower.contains("ancestry meds") -> {
                // Show medication considerations for patient ancestry
                showMedicationAncestryGuidance()
            }
            lower.contains("set ancestry") || (lower.contains("ancestry") &&
            (lower.contains("african") || lower.contains("asian") || lower.contains("european") ||
             lower.contains("hispanic") || lower.contains("middle eastern"))) -> {
                // Set patient ancestry for pharmacogenomics
                val ancestry = when {
                    lower.contains("african") -> "african"
                    lower.contains("east asian") || lower.contains("asian") -> "east_asian"
                    lower.contains("south asian") -> "south_asian"
                    lower.contains("european") || lower.contains("caucasian") -> "european"
                    lower.contains("hispanic") || lower.contains("latino") -> "hispanic"
                    lower.contains("middle eastern") -> "middle_eastern"
                    else -> null
                }
                if (ancestry != null) {
                    setPatientAncestry(ancestry)
                } else {
                    speakFeedback("Say set ancestry followed by African, Asian, European, Hispanic, or Middle Eastern.")
                }
            }
            lower.contains("racial medicine") || lower.contains("racial alerts") ||
            lower.contains("equity alerts") || lower.contains("disparity alerts") -> {
                // Show all racial medicine alerts for current patient
                showRacialMedicineAlerts()
            }
            lower.contains("maternal risk") || lower.contains("pregnancy risk") ||
            lower.contains("obstetric risk") -> {
                // Show maternal mortality risk alert
                showMaternalRiskAlert()
            }
            lower.contains("sickle cell") || lower.contains("pain crisis") -> {
                // Show sickle cell pain protocol reminder
                showSickleCellProtocol()
            }
            // ═══ CULTURAL CARE PREFERENCES COMMANDS (Feature #80) ═══
            lower.contains("cultural preferences") || lower.contains("cultural care") ||
            lower.contains("patient culture") || lower.contains("culture preferences") -> {
                // Show cultural care preferences for current patient
                showCulturalCarePreferences()
            }
            lower.contains("religious preferences") || lower.contains("religion") ||
            lower.contains("faith preferences") || lower.contains("spiritual care") -> {
                // Show religious healthcare preferences
                showReligiousPreferences()
            }
            lower.contains("blood preference") || lower.contains("blood product") ||
            lower.contains("transfusion preference") -> {
                // Show blood product preferences (esp. JW patients)
                showBloodProductPreferences()
            }
            lower.contains("dietary restrictions") || lower.contains("dietary preference") ||
            lower.contains("food restrictions") || lower.contains("halal") || lower.contains("kosher") -> {
                // Show dietary restrictions/preferences
                showDietaryRestrictions()
            }
            lower.contains("decision making") || lower.contains("family decision") ||
            lower.contains("who decides") || lower.contains("consent preference") -> {
                // Show decision-making style preference
                showDecisionMakingPreference()
            }
            lower.contains("modesty") || lower.contains("same gender") ||
            lower.contains("female provider") || lower.contains("male provider") -> {
                // Show modesty/provider gender preferences
                showModestyPreferences()
            }
            lower.contains("end of life") || lower.contains("advance directive") ||
            lower.contains("death preference") || lower.contains("dying wish") -> {
                // Show end-of-life cultural preferences
                showEndOfLifePreferences()
            }
            lower.contains("set religion") || (lower.contains("patient is") &&
            (lower.contains("jehovah") || lower.contains("muslim") || lower.contains("jewish") ||
             lower.contains("hindu") || lower.contains("buddhist") || lower.contains("sikh") ||
             lower.contains("christian") || lower.contains("catholic"))) -> {
                // Set patient religion for cultural care
                val religion = when {
                    lower.contains("jehovah") || lower.contains("witness") -> "jehovah_witness"
                    lower.contains("muslim") || lower.contains("islam") -> "islam"
                    lower.contains("jewish") || lower.contains("judaism") -> "judaism"
                    lower.contains("hindu") -> "hinduism"
                    lower.contains("buddhist") || lower.contains("buddhism") -> "buddhism"
                    lower.contains("sikh") -> "sikhism"
                    lower.contains("catholic") -> "catholic"
                    lower.contains("christian") -> "christian"
                    else -> null
                }
                if (religion != null) {
                    setPatientReligion(religion)
                } else {
                    speakFeedback("Specify a religion: Jehovah's Witness, Muslim, Jewish, Hindu, Buddhist, Sikh, Christian, or Catholic.")
                }
            }
            lower.contains("ramadan") || lower.contains("fasting") -> {
                // Show Ramadan fasting medication guidance
                showRamadanGuidance()
            }
            lower.contains("cultural alerts") || lower.contains("care alerts") -> {
                // Show all cultural care alerts
                showCulturalCareAlerts()
            }
            // ═══ IMPLICIT BIAS ALERTS COMMANDS (Feature #81) ═══
            lower.contains("bias check") || lower.contains("bias alert") ||
            lower.contains("equity check") || lower.contains("bias reminder") -> {
                // Manually trigger bias awareness check
                checkImplicitBias()
            }
            lower.contains("enable bias") || lower.contains("bias alerts on") ||
            lower.contains("enable equity") -> {
                biasAlertsEnabled = true
                speakFeedback("Bias awareness reminders enabled.")
                Toast.makeText(this, "Bias alerts ON", Toast.LENGTH_SHORT).show()
            }
            lower.contains("disable bias") || lower.contains("bias alerts off") ||
            lower.contains("disable equity") -> {
                biasAlertsEnabled = false
                speakFeedback("Bias awareness reminders disabled.")
                Toast.makeText(this, "Bias alerts OFF", Toast.LENGTH_SHORT).show()
            }
            lower.contains("bias status") || lower.contains("equity status") -> {
                val status = if (biasAlertsEnabled) "enabled" else "disabled"
                speakFeedback("Bias awareness reminders are $status.")
            }
            lower.contains("bias resources") || lower.contains("bias training") ||
            lower.contains("equity resources") || lower.contains("implicit bias help") -> {
                // Show educational resources
                showBiasResources()
            }
            lower.contains("acknowledge bias") || lower.contains("dismiss bias") ||
            lower.contains("noted") && lastBiasAlert != null -> {
                // Acknowledge and dismiss the bias alert
                acknowledgeBiasAlert()
            }
            // ═══ MATERNAL HEALTH MONITORING COMMANDS (Feature #82) ═══
            lower.contains("maternal health") || lower.contains("pregnancy check") ||
            lower.contains("ob assessment") || lower.contains("obstetric check") -> {
                // Trigger maternal health assessment
                assessMaternalHealth()
            }
            lower.contains("patient is pregnant") || lower.contains("mark pregnant") ||
            lower.contains("pregnancy status pregnant") -> {
                setMaternalStatus("pregnant")
            }
            lower.contains("patient is postpartum") || lower.contains("mark postpartum") ||
            lower.contains("post partum") || lower.contains("just delivered") -> {
                setMaternalStatus("postpartum")
            }
            lower.contains("clear maternal") || lower.contains("not pregnant") ||
            lower.contains("clear pregnancy") -> {
                setMaternalStatus(null)
            }
            lower.contains("warning signs") && (lower.contains("maternal") || lower.contains("pregnancy") ||
            lower.contains("postpartum") || currentMaternalStatus != null) -> {
                // Show maternal warning signs
                showMaternalWarningSigns()
            }
            lower.contains("postpartum checklist") || lower.contains("postpartum check") ||
            (lower.contains("checklist") && currentMaternalStatus == "postpartum") -> {
                showPostpartumChecklist()
            }
            lower.contains("maternal risk") || lower.contains("pregnancy risk") ||
            lower.contains("ob risk") || lower.contains("obstetric risk") -> {
                showMaternalRiskLevel()
            }
            lower.contains("disparity data") || lower.contains("mortality data") ||
            lower.contains("maternal disparity") || lower.contains("maternal mortality") -> {
                showMaternalDisparityData()
            }
            lower.contains("preeclampsia") || lower.contains("pre eclampsia") ||
            lower.contains("eclampsia signs") -> {
                showPreeclampsiaWarning()
            }
            lower.contains("hemorrhage") || lower.contains("bleeding check") ||
            (lower.contains("heavy bleeding") && currentMaternalStatus != null) -> {
                showHemorrhageWarning()
            }
            lower.contains("postpartum depression") || lower.contains("ppd screen") ||
            lower.contains("edinburgh") || lower.contains("emotional check") -> {
                showPostpartumDepressionScreen()
            }
            // ═══ SDOH INTEGRATION COMMANDS (Feature #84) ═══
            lower.contains("sdoh") || lower.contains("social determinants") ||
            lower.contains("social needs") || lower.contains("social screening") -> {
                showSdohStatus()
            }
            lower.contains("food insecurity") || lower.contains("food insecure") ||
            (lower.contains("food") && lower.contains("access")) -> {
                addSdohFactor("food_insecurity")
            }
            lower.contains("housing") && (lower.contains("unstable") || lower.contains("insecure") ||
            lower.contains("homeless") || lower.contains("problem")) -> {
                addSdohFactor("housing_instability")
            }
            lower.contains("transportation") && (lower.contains("barrier") || lower.contains("issue") ||
            lower.contains("problem") || lower.contains("no")) -> {
                addSdohFactor("transportation_barrier")
            }
            lower.contains("no insurance") || lower.contains("uninsured") ||
            (lower.contains("insurance") && lower.contains("problem")) -> {
                addSdohFactor("no_insurance")
            }
            lower.contains("financial") && (lower.contains("strain") || lower.contains("hardship") ||
            lower.contains("difficulty") || lower.contains("problem")) -> {
                addSdohFactor("financial_strain")
            }
            lower.contains("health literacy") || (lower.contains("literacy") && lower.contains("low")) ||
            lower.contains("can't read") || lower.contains("difficulty reading") -> {
                addSdohFactor("low_health_literacy")
            }
            lower.contains("social isolation") || lower.contains("lives alone") ||
            lower.contains("no support") || lower.contains("isolated") -> {
                addSdohFactor("social_isolation")
            }
            lower.contains("domestic violence") || lower.contains("partner violence") ||
            lower.contains("intimate partner") || lower.contains("unsafe relationship") -> {
                addSdohFactor("domestic_violence")
            }
            lower.contains("sdoh screen") || lower.contains("screen for social") ||
            lower.contains("social assessment") -> {
                performSdohScreening()
            }
            lower.contains("sdoh interventions") || lower.contains("social interventions") ||
            lower.contains("sdoh resources") || lower.contains("social resources") -> {
                showSdohInterventions()
            }
            lower.contains("adherence risk") || lower.contains("adherence barriers") ||
            lower.contains("compliance barriers") -> {
                showAdherenceRiskFactors()
            }
            lower.contains("clear sdoh") || lower.contains("clear social") ||
            lower.contains("reset sdoh") -> {
                clearSdohFactors()
            }
            lower.contains("z codes") || lower.contains("sdoh codes") ||
            lower.contains("social codes") -> {
                showSdohZCodes()
            }
            // ═══ HEALTH LITERACY ASSESSMENT COMMANDS (Feature #85) ═══
            lower.contains("literacy") || lower.contains("reading level") ||
            lower.contains("health literacy") -> {
                showLiteracyStatus()
            }
            lower.contains("literacy screen") || lower.contains("assess literacy") ||
            lower.contains("literacy assessment") -> {
                showLiteracyScreeningQuestion()
            }
            lower.contains("low literacy") || lower.contains("can't read") ||
            lower.contains("inadequate literacy") -> {
                setLiteracyLevel("inadequate")
            }
            lower.contains("marginal literacy") || lower.contains("some difficulty") ||
            lower.contains("a little confident") -> {
                setLiteracyLevel("marginal")
            }
            lower.contains("adequate literacy") || lower.contains("confident") ||
            lower.contains("good literacy") -> {
                setLiteracyLevel("adequate")
            }
            lower.contains("proficient") || lower.contains("very confident") ||
            lower.contains("high literacy") -> {
                setLiteracyLevel("proficient")
            }
            lower.contains("simplify") && (lower.contains("discharge") || lower.contains("instructions")) -> {
                // Simplify discharge instructions for current condition
                showSimplifiedInstructions()
            }
            lower.contains("diabetes instructions") || lower.contains("diabetes discharge") -> {
                showSimplifiedInstructionsFor("diabetes")
            }
            lower.contains("heart failure instructions") || lower.contains("chf instructions") -> {
                showSimplifiedInstructionsFor("heart_failure")
            }
            lower.contains("blood pressure instructions") || lower.contains("hypertension instructions") -> {
                showSimplifiedInstructionsFor("hypertension")
            }
            lower.contains("blood thinner instructions") || lower.contains("anticoagulation instructions") ||
            lower.contains("warfarin instructions") -> {
                showSimplifiedInstructionsFor("anticoagulation")
            }
            lower.contains("antibiotic instructions") || lower.contains("infection instructions") -> {
                showSimplifiedInstructionsFor("infection")
            }
            lower.contains("surgery instructions") || lower.contains("post op instructions") ||
            lower.contains("post surgery") -> {
                showSimplifiedInstructionsFor("post_surgery")
            }
            lower.contains("teach back") || lower.contains("teach-back") ||
            lower.contains("verify understanding") -> {
                showTeachBackChecklist()
            }
            lower.contains("plain language") || lower.contains("medical terms") ||
            lower.contains("translate term") -> {
                showPlainLanguageGuide()
            }
            lower.contains("literacy accommodations") || lower.contains("accommodations") -> {
                showLiteracyAccommodations()
            }
            // ═══ INTERPRETER INTEGRATION COMMANDS (Feature #86) ═══
            lower.contains("interpreter") && (lower.contains("need") || lower.contains("request") || lower.contains("call")) -> {
                requestInterpreter()
            }
            lower.contains("interpreter status") || lower.contains("interpreter session") -> {
                showInterpreterStatus()
            }
            lower.contains("start interpreter") || lower.contains("begin interpreter") -> {
                startInterpreterSession()
            }
            lower.contains("end interpreter") || lower.contains("stop interpreter") ||
            lower.contains("disconnect interpreter") -> {
                endInterpreterSession()
            }
            lower.contains("spanish interpreter") || lower.contains("spanish speaking") -> {
                requestInterpreterForLanguage("es", "Spanish")
            }
            lower.contains("mandarin interpreter") || lower.contains("chinese interpreter") -> {
                requestInterpreterForLanguage("zh", "Chinese (Mandarin)")
            }
            lower.contains("vietnamese interpreter") -> {
                requestInterpreterForLanguage("vi", "Vietnamese")
            }
            lower.contains("arabic interpreter") -> {
                requestInterpreterForLanguage("ar", "Arabic")
            }
            lower.contains("russian interpreter") -> {
                requestInterpreterForLanguage("ru", "Russian")
            }
            lower.contains("korean interpreter") -> {
                requestInterpreterForLanguage("ko", "Korean")
            }
            lower.contains("portuguese interpreter") -> {
                requestInterpreterForLanguage("pt", "Portuguese")
            }
            lower.contains("sign language interpreter") || lower.contains("asl interpreter") ||
            lower.contains("deaf interpreter") -> {
                requestInterpreterForLanguage("asl", "ASL (American Sign Language)")
            }
            lower.contains("patient speaks") || lower.contains("language preference") ||
            lower.contains("preferred language") -> {
                showLanguagePreference()
            }
            lower.contains("set language") && lower.contains("spanish") -> {
                setPatientLanguagePreference("es", "Spanish")
            }
            lower.contains("set language") && (lower.contains("chinese") || lower.contains("mandarin")) -> {
                setPatientLanguagePreference("zh", "Chinese (Mandarin)")
            }
            lower.contains("set language") && lower.contains("vietnamese") -> {
                setPatientLanguagePreference("vi", "Vietnamese")
            }
            lower.contains("clinical phrases") || lower.contains("common phrases") ||
            lower.contains("translated phrases") -> {
                showClinicalPhrases()
            }
            lower.contains("say in spanish") || (lower.contains("spanish") && lower.contains("how do i say")) -> {
                val phrase = extractPhraseToTranslate(transcript)
                showPhrasesForLanguage("es", phrase)
            }
            lower.contains("say in chinese") || (lower.contains("chinese") && lower.contains("how do i say")) -> {
                val phrase = extractPhraseToTranslate(transcript)
                showPhrasesForLanguage("zh", phrase)
            }
            lower.contains("interpreter services") || lower.contains("language line") ||
            lower.contains("interpreter phone") -> {
                showInterpreterServices()
            }
            lower.contains("compliance checklist") || lower.contains("interpreter compliance") ||
            lower.contains("title vi") || lower.contains("title 6") -> {
                showInterpreterComplianceChecklist()
            }
            lower.contains("family interpreter declined") || lower.contains("no family interpreter") -> {
                setFamilyInterpreterDeclined(true)
            }
            lower.contains("video interpreter") -> {
                setInterpreterType("video")
            }
            lower.contains("phone interpreter") -> {
                setInterpreterType("phone")
            }
            lower.contains("in person interpreter") || lower.contains("in-person interpreter") -> {
                setInterpreterType("in_person")
            }
            lower.contains("document interpreter") || lower.contains("interpreter documentation") -> {
                documentInterpreterUse()
            }
            // Transcript preview voice commands
            lower.contains("generate note") || lower.contains("create note") || lower.contains("looks good") || lower.contains("that's good") -> {
                // Generate note from pending transcript
                pendingTranscript?.let { pending ->
                    hideDataOverlay()
                    generateClinicalNote(pending)
                    pendingTranscript = null
                } ?: run {
                    transcriptText.text = "No transcript to generate from"
                }
            }
            lower.contains("re-record") || lower.contains("rerecord") || lower.contains("record again") || lower.contains("try again") -> {
                // Start new transcription (discard current)
                pendingTranscript = null
                hideDataOverlay()
                toggleLiveTranscription()
            }
            lower.contains("scan") || lower.contains("wristband") -> {
                // Voice command to scan wristband
                startBarcodeScanner()
            }
            lower.contains("show vital") || lower.contains("vital") -> {
                // Show vitals only (matches both "vitals" and "vital")
                fetchPatientSection("vitals")
            }
            lower.contains("allergies") || lower.contains("allergy") -> {
                // Show allergies
                fetchPatientSection("allergies")
            }
            lower.contains("medication") || lower.contains("meds") || lower.contains("drugs") -> {
                // Show medications
                fetchPatientSection("medications")
            }
            lower.contains("labs") || lower.contains("laboratory") || lower.contains("results") -> {
                // Show lab results
                fetchPatientSection("labs")
            }
            lower.contains("procedure") || lower.contains("surgery") || lower.contains("operation") -> {
                // Show procedures
                fetchPatientSection("procedures")
            }
            lower.contains("immunization") || lower.contains("vaccine") || lower.contains("vaccination") || lower.contains("shot") -> {
                // Show immunizations
                fetchPatientSection("immunizations")
            }
            lower.contains("condition") || lower.contains("problem") || lower.contains("diagnosis") || lower.contains("diagnoses") -> {
                // Show conditions/problems
                fetchPatientSection("conditions")
            }
            lower.contains("care plan") || lower.contains("treatment plan") || lower.contains("care plans") -> {
                // Show care plans
                fetchPatientSection("care_plans")
            }
            lower.contains("clinical note") || lower.contains("show notes") || lower.contains("patient notes") || lower.contains("previous notes") || lower.contains("history notes") -> {
                // Show clinical notes from EHR
                fetchPatientSection("clinical_notes")
            }
            lower.contains("help") || lower.contains("what can i say") || lower.contains("voice commands") || lower.contains("show commands") || lower.contains("list commands") || lower.contains("available commands") -> {
                // Show voice command help
                showVoiceCommandHelp()
            }
            // Patient summary commands - spoken and visual
            lower.contains("tell me about") || lower.contains("read summary") || lower.contains("speak summary") ||
            lower.contains("brief me") || lower.contains("briefing") || lower.contains("tell me about patient") ||
            lower.contains("patient brief") || lower.contains("read patient") || lower.contains("summarize") -> {
                // Hands-free spoken summary while walking to patient
                speakPatientSummary()
            }
            lower.contains("patient summary") || lower.contains("summarize patient") || lower.contains("quick summary") ||
            lower.contains("show summary") || lower.contains("overview") -> {
                // Show visual summary (no TTS)
                showQuickPatientSummary()
            }
            // Pre-Visit Prep Alert (Feature #92 - Jarvis Wave 1)
            lower.contains("prep me") || lower.contains("patient prep") || lower.contains("pre-visit prep") ||
            lower.contains("pre visit prep") || lower.contains("heads up") || lower.contains("what should i know") -> {
                // Proactive AI briefing with care gaps, critical values, and suggested actions
                val patientId = currentPatientData?.optString("id") ?: currentPatientData?.optString("patient_id")
                if (patientId != null && patientId.isNotEmpty()) {
                    fetchPreVisitPrep(patientId)
                } else {
                    speakFeedback("No patient loaded")
                }
            }
            // Chief Complaint Workflows (Feature #94 - Jarvis Wave 1)
            lower.contains("suggest workup") || lower.contains("what workup") || lower.contains("which workup") ||
            lower.contains("recommended workup") || lower.contains("workflow") || lower.contains("work up") -> {
                // Detect chief complaint and suggest relevant workups
                val patientId = currentPatientData?.optString("id") ?: currentPatientData?.optString("patient_id")
                if (patientId != null && patientId.isNotEmpty()) {
                    fetchChiefComplaintWorkflow(patientId, null)
                } else {
                    speakFeedback("No patient loaded. Load a patient to get workflow suggestions.")
                }
            }
            lower.contains("workup for") || lower.contains("orders for") -> {
                // Suggest workup based on free text after "workup for" or "orders for"
                val afterFor = lower.substringAfter("for").trim()
                if (afterFor.isNotEmpty()) {
                    suggestWorkflowFromText(afterFor)
                } else {
                    speakFeedback("Say 'workup for' followed by the chief complaint, like 'workup for chest pain'")
                }
            }
            // Care Gap Detection (Feature #97 - Jarvis Wave 2)
            // Proactive identification of missing screenings, labs, and preventive care
            lower.contains("care gap") || lower.contains("care gaps") || lower.contains("what's overdue") ||
            lower.contains("screenings due") || lower.contains("overdue items") || lower.contains("preventive care") ||
            lower.contains("what screenings") || lower.contains("missing screenings") || lower.contains("preventive") -> {
                // Show all care gaps for the patient
                val patientId = currentPatientData?.optString("id") ?: currentPatientData?.optString("patient_id")
                if (patientId != null && patientId.isNotEmpty()) {
                    fetchCareGaps(patientId, null, null)
                } else {
                    speakFeedback("No patient loaded. Load a patient to check care gaps.")
                }
            }
            lower.contains("high priority") && (lower.contains("gap") || lower.contains("overdue")) -> {
                // Show only high priority care gaps
                val patientId = currentPatientData?.optString("id") ?: currentPatientData?.optString("patient_id")
                if (patientId != null && patientId.isNotEmpty()) {
                    fetchCareGaps(patientId, null, "high")
                } else {
                    speakFeedback("No patient loaded")
                }
            }
            lower.contains("vaccines due") || lower.contains("missing vaccines") || lower.contains("vaccination status") -> {
                // Show only vaccine care gaps
                val patientId = currentPatientData?.optString("id") ?: currentPatientData?.optString("patient_id")
                if (patientId != null && patientId.isNotEmpty()) {
                    fetchCareGaps(patientId, "vaccine", null)
                } else {
                    speakFeedback("No patient loaded")
                }
            }
            lower.contains("labs due") || lower.contains("overdue labs") -> {
                // Show only lab care gaps
                val patientId = currentPatientData?.optString("id") ?: currentPatientData?.optString("patient_id")
                if (patientId != null && patientId.isNotEmpty()) {
                    fetchCareGaps(patientId, "lab", null)
                } else {
                    speakFeedback("No patient loaded")
                }
            }
            // Indirect Commands (Feature #96 - Jarvis Wave 1)
            // Natural language queries like "check that potassium", "what's his blood pressure"
            (lower.startsWith("check") || lower.startsWith("what") || lower.startsWith("pull") ||
             lower.startsWith("get") || lower.startsWith("find") || lower.startsWith("look")) &&
            (lower.contains("potassium") || lower.contains("sodium") || lower.contains("creatinine") ||
             lower.contains("hemoglobin") || lower.contains("hgb") || lower.contains("glucose") ||
             lower.contains("a1c") || lower.contains("troponin") || lower.contains("bnp") ||
             lower.contains("blood pressure") || lower.contains("bp") || lower.contains("pulse") ||
             lower.contains("heart rate") || lower.contains("temp") || lower.contains("o2 sat") ||
             lower.contains("spo2") || lower.contains("cbc") || lower.contains("bmp") ||
             lower.contains("calcium") || lower.contains("magnesium") || lower.contains("inr") ||
             lower.contains("wbc") || lower.contains("platelets") || lower.contains("cholesterol") ||
             lower.contains("lipid") || lower.contains("thyroid") || lower.contains("tsh")) -> {
                // Parse natural language and execute inferred action
                parseAndExecuteIndirectCommand(transcript)
            }
            // SBAR Handoff report commands
            lower.contains("handoff report") || lower.contains("hand off report") || lower.contains("sbar report") ||
            lower.contains("sbar") || lower.contains("shift report") || lower.contains("handoff") -> {
                // Generate visual SBAR handoff report
                generateHandoffReport()
            }
            lower.contains("read handoff") || lower.contains("speak handoff") || lower.contains("tell me handoff") ||
            lower.contains("verbal handoff") || lower.contains("give handoff") -> {
                // Speak SBAR handoff report aloud
                speakHandoffReport()
            }
            // Discharge summary commands
            lower.contains("discharge summary") || lower.contains("discharge instructions") ||
            lower.contains("discharge") || lower.contains("patient instructions") -> {
                // Generate visual discharge summary
                generateDischargeSummary()
            }
            lower.contains("read discharge") || lower.contains("speak discharge") || lower.contains("explain discharge") ||
            lower.contains("tell patient") || lower.contains("patient education") -> {
                // Speak discharge instructions aloud
                speakDischargeInstructions()
            }
            // Procedure Checklist commands
            lower.contains("show checklists") || lower.contains("procedure checklists") || lower.contains("safety checklists") -> {
                showProcedureChecklists()
            }
            lower.contains("start") && lower.contains("checklist") -> {
                val checklistName = lower.replace("start", "").replace("checklist", "").trim()
                startProcedureChecklist(checklistName)
            }
            lower.contains("check all") -> {
                checkAllChecklistItems()
            }
            lower.contains("check ") && lower.matches(Regex(".*check\\s+\\d+.*")) -> {
                val num = lower.replace(Regex(".*check\\s+(\\d+).*"), "$1").toIntOrNull() ?: 0
                checkChecklistItem(num)
            }
            lower.contains("read checklist") || lower.contains("speak checklist") -> {
                readChecklist()
            }
            // Clinical Reminders commands
            lower.contains("clinical reminders") || lower.contains("reminders") || lower.contains("preventive care") ||
            lower.contains("care reminders") || lower.contains("health reminders") -> {
                generateClinicalReminders()
            }
            // Medication Reconciliation commands
            lower.contains("med reconciliation") || lower.contains("medication reconciliation") ||
            lower.contains("reconcile meds") || lower.contains("med rec") -> {
                startMedReconciliation()
            }
            lower.contains("add home med") -> {
                val med = lower.replace("add home med", "").replace("add home medication", "").trim()
                if (med.isNotEmpty()) addHomeMedication(med)
            }
            lower.contains("remove home med") -> {
                val num = lower.replace(Regex(".*remove home med\\w*\\s*(\\d+).*"), "$1").toIntOrNull() ?: 0
                if (num > 0) removeHomeMedication(num)
            }
            lower.contains("compare meds") || lower.contains("compare medications") || lower.contains("med comparison") -> {
                compareMedications()
            }
            lower.contains("clear home meds") || lower.contains("clear home medications") -> {
                clearHomeMedications()
            }
            // Referral Tracking commands
            lower.contains("show referrals") || lower.contains("referrals") || lower.contains("pending referrals") -> {
                showReferrals()
            }
            lower.contains("urgent referral to") || lower.contains("stat referral to") -> {
                val urgency = if (lower.contains("stat")) "stat" else "urgent"
                val afterTo = lower.substringAfter("referral to").trim()
                val parts = afterTo.split(" for ", limit = 2)
                val specialty = parts[0].trim()
                val reason = if (parts.size > 1) parts[1].trim() else "evaluation"
                createReferral(specialty, reason, urgency)
            }
            lower.contains("refer to") -> {
                val afterTo = lower.substringAfter("refer to").trim()
                val parts = afterTo.split(" for ", limit = 2)
                val specialty = parts[0].trim()
                val reason = if (parts.size > 1) parts[1].trim() else "evaluation"
                createReferral(specialty, reason)
            }
            lower.contains("mark referral") && lower.contains("scheduled") -> {
                val num = lower.replace(Regex(".*referral\\s*(\\d+).*"), "$1").toIntOrNull() ?: 0
                if (num > 0) updateReferralStatus(num, "scheduled")
            }
            lower.contains("mark referral") && (lower.contains("complete") || lower.contains("completed")) -> {
                val num = lower.replace(Regex(".*referral\\s*(\\d+).*"), "$1").toIntOrNull() ?: 0
                if (num > 0) updateReferralStatus(num, "completed")
            }
            lower.contains("clear referrals") -> {
                clearReferrals()
            }
            // ═══════════════════════════════════════════════════════════════════════════
            // SPECIALTY TEMPLATES - Feature #56
            // ═══════════════════════════════════════════════════════════════════════════
            lower.contains("list specialty templates") || lower.contains("specialty templates") ||
            lower.contains("show specialty templates") -> {
                showSpecialtyTemplates()
            }
            lower.contains("use template") || lower.contains("apply template") -> {
                // Extract template name: "use cardiology chest pain template"
                val templateKey = extractSpecialtyTemplateKey(lower)
                if (templateKey != null) {
                    applySpecialtyTemplate(templateKey)
                } else {
                    showSpecialtyTemplates()
                }
            }
            // ═══════════════════════════════════════════════════════════════════════════
            // NOTE VERSIONING - Feature #57
            // ═══════════════════════════════════════════════════════════════════════════
            lower.contains("version history") || lower.contains("note versions") || lower.contains("show versions") -> {
                showNoteVersionHistory()
            }
            lower.contains("restore version") -> {
                val num = lower.replace(Regex(".*version\\s*(\\d+).*"), "$1").toIntOrNull() ?: 0
                if (num > 0) restoreNoteVersion(num)
            }
            lower.contains("compare versions") || lower.contains("diff versions") || lower.contains("version diff") -> {
                compareNoteVersions()
            }
            lower.contains("clear version history") || lower.contains("clear versions") -> {
                clearNoteVersionHistory()
            }
            // ═══════════════════════════════════════════════════════════════════════════
            // DATA ENCRYPTION - Feature #60
            // ═══════════════════════════════════════════════════════════════════════════
            lower.contains("encryption status") || lower.contains("security status") -> {
                showEncryptionStatus()
            }
            lower.contains("wipe data") || lower.contains("secure wipe") || lower.contains("erase data") -> {
                secureWipeAllData()
            }
            lower.contains("stop talking") || lower.contains("stop speaking") || lower.contains("be quiet") || lower.contains("quiet") -> {
                // Stop any ongoing TTS
                stopSpeaking()
                transcriptText.text = "Speech stopped"
            }
            lower.contains("stop listening") || lower.contains("stop voice") || lower.contains("mute") -> {
                // Turn off continuous listening mode
                isContinuousListening = false
                speechRecognizer.stopListening()
                statusText.text = "MDx Vision"
                transcriptText.text = "Voice commands off. Tap MDX MODE to re-enable."
                speakFeedback("Voice commands disabled")
            }
            lower.contains("close") || lower.contains("dismiss") || lower.contains("back") || lower.contains("go away") -> {
                // Close any open overlay
                if (isLiveTranscribing) {
                    stopLiveTranscription()
                    hideLiveTranscriptionOverlay()
                }
                hideDataOverlay()
            }
            lower.contains("clear cache") || lower.contains("clear offline") -> {
                // Clear the offline cache
                clearCache()
                currentPatientData = null
                hideDataOverlay()
            }
            // Patient history voice commands
            lower.contains("show history") || lower.contains("recent patients") || lower.contains("patient history") -> {
                showHistoryOverlay()
            }
            lower.contains("clear history") -> {
                clearPatientHistory()
                hideDataOverlay()
            }

            // ═══════════════════════════════════════════════════════════════════════════
            // PATIENT WORKLIST - Daily schedule commands
            // ═══════════════════════════════════════════════════════════════════════════

            // Show worklist: "show worklist", "worklist", "today's patients", "my schedule"
            lower.contains("worklist") || lower.contains("today's patient") || lower.contains("todays patient") ||
            lower.contains("my schedule") || lower.contains("patient schedule") || lower.contains("daily schedule") -> {
                showWorklist()
            }
            // Who's next: "who's next", "next patient", "who is next"
            lower.contains("who's next") || lower.contains("whos next") || lower.contains("who is next") ||
            (lower.contains("next") && lower.contains("patient")) -> {
                getNextPatient()
            }
            // Check in patient: "check in 1", "check in patient 2", "check in 3 to room 5"
            lower.contains("check in") && (lower.contains(Regex("\\d"))) -> {
                val numberMatch = Regex("check in\\s*(?:patient\\s*)?(\\d+)").find(lower)
                val roomMatch = Regex("(?:to\\s+)?room\\s*(\\w+)").find(lower)
                if (numberMatch != null) {
                    val patientNum = numberMatch.groupValues[1].toIntOrNull() ?: 0
                    val room = roomMatch?.groupValues?.get(1)
                    checkInPatient(patientNum, room)
                }
            }
            // Mark patient status: "mark 1 completed", "patient 2 done", "start seeing 3"
            lower.contains("mark") && lower.contains(Regex("\\d")) &&
            (lower.contains("complete") || lower.contains("done") || lower.contains("finished")) -> {
                val numMatch = Regex("(\\d+)").find(lower)
                if (numMatch != null) {
                    val patientNum = numMatch.groupValues[1].toIntOrNull() ?: 0
                    updateWorklistStatus(patientNum, "completed")
                }
            }
            // Start encounter: "start seeing 1", "begin encounter 2", "seeing patient 3"
            (lower.contains("start seeing") || lower.contains("begin encounter") ||
             lower.contains("seeing patient")) && lower.contains(Regex("\\d")) -> {
                val numMatch = Regex("(\\d+)").find(lower)
                if (numMatch != null) {
                    val patientNum = numMatch.groupValues[1].toIntOrNull() ?: 0
                    updateWorklistStatus(patientNum, "in_progress")
                }
            }
            // Load from worklist: "load 1", "load patient 2", "open 3"
            (lower.startsWith("load ") || lower.startsWith("open ")) &&
            lower.contains(Regex("\\d")) && !lower.contains("patient id") -> {
                val numMatch = Regex("(\\d+)").find(lower)
                if (numMatch != null) {
                    val patientNum = numMatch.groupValues[1].toIntOrNull()?.minus(1) ?: -1
                    if (patientNum >= 0 && patientNum < worklistPatients.size) {
                        val patient = worklistPatients[patientNum]
                        fetchPatientData(patient.patientId)
                    } else {
                        // Check patient history instead
                        loadPatientFromHistory(patientNum + 1)
                    }
                }
            }

            // ═══════════════════════════════════════════════════════════════════════════
            // VOICE ORDERS - Order commands
            // ═══════════════════════════════════════════════════════════════════════════

            // Show orders: "show orders", "list orders", "pending orders"
            lower.contains("show order") || lower.contains("list order") || lower.contains("pending order") ||
            lower.contains("what are the order") -> {
                showOrdersForUpdate()  // Show with update/delete options
            }
            // List order sets: "list order sets", "show order sets", "available order sets"
            lower.contains("order set") && (lower.contains("list") || lower.contains("show") || lower.contains("available") || lower.contains("what")) -> {
                showOrderSetList()
            }
            // Preview order set: "what's in chest pain", "preview sepsis bundle", "show me chest pain workup"
            (lower.contains("what's in") || lower.contains("whats in") || lower.contains("preview") ||
             lower.contains("show me") && lower.contains("workup")) -> {
                val setName = lower.replace(Regex("(what's in|whats in|preview|show me|workup)"), "").trim()
                if (setName.isNotEmpty()) {
                    previewOrderSet(setName)
                } else {
                    speakFeedback("Say what's in followed by the order set name, like what's in chest pain.")
                }
            }
            // Update order: "update 1 to 500mg every 6 hours", "update tylenol to 650mg PRN"
            lower.startsWith("update ") && (lower.contains(" to ") || lower.contains(Regex("\\d"))) -> {
                updateOrder(transcript)
            }
            // Delete specific order by number or medication name:
            // "delete 1", "delete 2", "remove 3", "delete tylenol", "remove metformin"
            (lower.startsWith("delete ") || lower.startsWith("remove ")) &&
            (lower.contains(Regex("^(?:delete|remove)\\s*\\d")) ||
             lower.contains(Regex("^(?:delete|remove)\\s+[a-z]"))) -> {
                deleteOrderByNumber(transcript)
            }
            // Cancel order (last one): "cancel order", "remove order", "remove last order"
            lower.contains("cancel order") || lower.contains("remove order") ||
            lower.contains("remove last order") || lower.contains("delete order") -> {
                cancelLastOrder()
            }
            // Clear all orders: "clear all orders", "delete all orders"
            lower.contains("clear all order") || lower.contains("delete all order") -> {
                clearAllOrders()
            }
            // Confirmation: "yes", "confirm" (when order pending or order update pending)
            (lower == "yes" || lower == "confirm" || lower.contains("confirm order") ||
             lower.contains("place order") || lower.contains("go ahead")) -> {
                when {
                    pendingOrderUpdate != null -> confirmOrderUpdate()
                    pendingConfirmationOrder != null -> confirmPendingOrder()
                    else -> speakFeedback("Nothing to confirm")
                }
            }
            // Rejection: "no", "cancel" (when order pending or update pending)
            (lower == "no" || lower == "reject" || lower.contains("don't order") ||
             lower.contains("do not order") || lower == "cancel") -> {
                when {
                    pendingOrderUpdate != null -> cancelOrderUpdate()
                    pendingConfirmationOrder != null -> rejectPendingOrder()
                    else -> {} // Do nothing
                }
            }
            // Add medication to note: "add med aspirin", "add medication ibuprofen 400mg"
            lower.contains("add med") || lower.contains("add medication") -> {
                val medText = lower.substringAfter("add med").replace("ication", "").trim()
                addMedicationToNote(medText)
            }
            // Prescribe medication: "prescribe amoxicillin 500mg three times daily for 10 days"
            lower.contains("prescribe ") -> {
                val medText = lower.substringAfter("prescribe ").trim()
                processMedicationOrder(medText)
            }
            // Order command - determine type based on content (check order sets first)
            lower.contains("order ") -> {
                val orderText = lower.substringAfter("order ").trim()
                val orderSet = findOrderSet(orderText)
                when {
                    orderSet != null -> processOrderSet(orderSet)
                    isLabOrder(orderText) -> processLabOrder(orderText)
                    isImagingOrder(orderText) -> processImagingOrder(orderText)
                    isMedicationOrder(orderText) -> processMedicationOrder(orderText)
                    else -> speakFeedback("Order not recognized. Try: order CBC, order chest pain workup, or prescribe amoxicillin.")
                }
            }
            // ═══════════════════════════════════════════════════════════════════════════
            // VOICE VITALS ENTRY - Capture vitals by voice
            // ═══════════════════════════════════════════════════════════════════════════

            // Show captured vitals: "show vitals captured", "captured vitals", "my vitals"
            lower.contains("captured vital") || lower.contains("my vital") ||
            lower.contains("show captured") || lower.contains("vitals captured") -> {
                showCapturedVitals()
            }
            // Clear captured vitals: "clear vitals", "clear captured vitals", "reset vitals"
            lower.contains("clear vital") || lower.contains("reset vital") ||
            lower.contains("delete vital") -> {
                clearCapturedVitals()
            }
            // Add vitals to note: "add vitals to note", "insert vitals", "vitals to note"
            lower.contains("add vital") && lower.contains("note") ||
            lower.contains("insert vital") || lower.contains("vitals to note") -> {
                addVitalsToNote()
            }
            // Vital history: "vital history", "show vital history", "past vitals", "vitals over time"
            lower.contains("vital history") || lower.contains("vitals history") ||
            lower.contains("past vital") || lower.contains("vitals over time") ||
            lower.contains("previous vital") || lower.contains("historical vital") ||
            (lower.contains("history") && lower.contains("vital")) -> {
                fetchVitalHistory()
            }
            // Vital entry: "BP 120 over 80", "pulse 72", "temp 98.6", etc.
            isVitalEntry(lower) -> {
                processVitalEntry(lower)
            }
            // ═══════════════════════════════════════════════════════════════════════════
            // ENCOUNTER TIMER - Timer commands
            // ═══════════════════════════════════════════════════════════════════════════

            // Start timer: "start timer", "begin timer", "start encounter"
            lower.contains("start timer") || lower.contains("begin timer") ||
            lower.contains("start encounter") || lower.contains("start the timer") -> {
                startEncounterTimer()
            }
            // Stop timer: "stop timer", "end timer", "stop encounter"
            lower.contains("stop timer") || lower.contains("end timer") ||
            lower.contains("stop encounter") || lower.contains("end encounter") -> {
                stopEncounterTimer()
            }
            // Check time: "how long", "what's the time", "check timer", "elapsed time"
            lower.contains("how long") || lower.contains("what time") || lower.contains("check timer") ||
            lower.contains("elapsed time") || lower.contains("time elapsed") ||
            lower.contains("how much time") || lower.contains("time spent") -> {
                reportEncounterTime()
            }
            // Reset timer: "reset timer", "restart timer"
            lower.contains("reset timer") || lower.contains("restart timer") -> {
                resetEncounterTimer()
            }
            // Session timeout voice commands (HIPAA compliance)
            lower.contains("lock session") || lower == "lock" -> {
                lockSession()
            }
            lower.contains("unlock") -> {
                if (isSessionLocked) {
                    unlockSession()
                } else {
                    Toast.makeText(this, "Session is not locked", Toast.LENGTH_SHORT).show()
                }
            }
            lower.contains("timeout") && Regex("(\\d+)\\s*min").containsMatchIn(lower) -> {
                // Set timeout: "timeout 10 minutes", "set timeout 5 min"
                val match = Regex("(\\d+)\\s*min").find(lower)
                if (match != null) {
                    val minutes = match.groupValues[1].toIntOrNull() ?: DEFAULT_SESSION_TIMEOUT_MINUTES
                    setSessionTimeout(minutes)
                }
            }
            // Device authentication commands
            lower.contains("pair device") || lower.contains("pair glasses") || lower.contains("pair this device") -> {
                startDevicePairing()
            }
            lower.contains("device status") || lower.contains("pairing status") -> {
                showDeviceStatus()
            }
            // Voiceprint enrollment commands
            lower.contains("enroll my voice") || lower.contains("enroll voiceprint") || lower.contains("setup voiceprint") -> {
                startVoiceprintEnrollment()
            }
            lower.contains("voiceprint status") || lower.contains("voice print status") -> {
                showVoiceprintStatus()
            }
            lower.contains("delete voiceprint") || lower.contains("remove voiceprint") -> {
                deleteVoiceprintEnrollment()
            }
            // Feature #77: Continuous auth voice commands
            lower.contains("verify me") || lower.contains("verify my voice") || lower.contains("verify identity") -> {
                handleVerifyMeCommand()
            }
            lower.contains("verification status") || lower.contains("verify status") || lower.contains("auth status") -> {
                showVerificationStatus()
            }
            lower.contains("set verify interval") || lower.contains("set verification interval") -> {
                // Parse "set verify interval [N] minutes"
                val match = Regex("(\\d+)\\s*(?:minute|min)").find(lower)
                val minutes = match?.groupValues?.getOrNull(1)?.toIntOrNull() ?: 5
                setReVerifyInterval(minutes)
            }
            lower.contains("load ") && Regex("load\\s+(\\d+)").containsMatchIn(lower) -> {
                // Load patient from history by number (e.g., "load 1", "load 2")
                val match = Regex("load\\s+(\\d+)").find(lower)
                if (match != null) {
                    val index = match.groupValues[1].toIntOrNull() ?: 0
                    loadPatientFromHistory(index)
                }
            }
            // Voice Navigation Commands
            lower.contains("scroll down") || lower.contains("page down") || lower.contains("next page") -> {
                scrollDown()
            }
            lower.contains("scroll up") || lower.contains("page up") || lower.contains("previous page") -> {
                scrollUp()
            }
            lower.contains("go to top") || lower.contains("scroll to top") || lower.contains("top of page") -> {
                scrollToTop()
            }
            lower.contains("go to bottom") || lower.contains("scroll to bottom") || lower.contains("bottom of page") -> {
                scrollToBottom()
            }
            (lower.contains("go to") || lower.contains("jump to") || lower.contains("navigate to")) &&
                (lower.contains("subjective") || lower.contains("objective") ||
                 lower.contains("assessment") || lower.contains("plan") ||
                 lower.contains("chief complaint")) -> {
                // Navigate to specific section: "go to assessment", "jump to plan"
                val section = extractSectionFromCommand(lower)
                if (section != null) {
                    goToSection(section)
                }
            }
            lower.contains("show") && lower.contains("only") &&
                (lower.contains("subjective") || lower.contains("objective") ||
                 lower.contains("assessment") || lower.contains("plan")) -> {
                // Show only one section: "show plan only", "show assessment only"
                val section = extractSectionFromCommand(lower)
                if (section != null) {
                    showSectionOnly(section)
                }
            }
            (lower.contains("read") || lower.contains("read back") || lower.contains("say")) &&
                (lower.contains("subjective") || lower.contains("objective") ||
                 lower.contains("assessment") || lower.contains("plan") ||
                 lower.contains("chief complaint")) -> {
                // Read a section aloud: "read assessment", "read back the plan"
                val section = extractSectionFromCommand(lower)
                if (section != null) {
                    readSection(section)
                }
            }
            lower.contains("read note") || lower.contains("read entire note") || lower.contains("read the note") || lower.contains("read all") -> {
                // Read entire note aloud
                readEntireNote()
            }
            // Voice Dictation Mode Commands
            (lower.contains("dictate to") || lower.contains("dictate into") || lower.contains("start dictating")) &&
                (lower.contains("subjective") || lower.contains("objective") ||
                 lower.contains("assessment") || lower.contains("plan") ||
                 lower.contains("chief complaint") || lower.contains("history")) -> {
                // Start dictation to a specific section: "dictate to assessment", "start dictating subjective"
                val section = extractSectionFromCommand(lower)
                if (section != null) {
                    startDictation(section)
                } else {
                    Toast.makeText(this, "Say: dictate to [section]", Toast.LENGTH_SHORT).show()
                }
            }
            lower == "dictate" || lower.contains("start dictation") -> {
                // Start dictation to default section (plan is most common for orders)
                Toast.makeText(this, "Say 'dictate to [section]' (e.g., 'dictate to plan')", Toast.LENGTH_LONG).show()
                speakFeedback("Say dictate to and the section name. For example, dictate to plan.")
            }
            // Voice Template Commands
            lower.contains("use") && lower.contains("template") -> {
                // "Use diabetes template", "Use URI template", "Use my headache template"
                val templateName = lower
                    .replace("use", "")
                    .replace("template", "")
                    .replace("the", "")
                    .replace("my", "")
                    .trim()
                if (templateName.isNotEmpty()) {
                    val templateKey = findTemplateByName(templateName)
                    if (templateKey != null) {
                        applyTemplate(templateKey)
                    } else {
                        Toast.makeText(this, "Template not found: $templateName", Toast.LENGTH_SHORT).show()
                        speakFeedback("Template not found. Say list templates to see available options.")
                    }
                } else {
                    showTemplateListOverlay()
                }
            }
            lower.contains("list template") || lower.contains("show template") || lower.contains("available template") ||
            lower == "templates" || lower.contains("what template") -> {
                // List available templates
                showTemplateListOverlay()
            }
            lower.contains("my template") || lower.contains("custom template") || lower.contains("saved template") -> {
                // Show user templates
                val userTemplates = getUserTemplates()
                if (userTemplates.isEmpty()) {
                    Toast.makeText(this, "No custom templates saved", Toast.LENGTH_SHORT).show()
                    speakFeedback("No custom templates. Say save as template to create one.")
                } else {
                    showTemplateListOverlay()
                }
            }
            lower.contains("save as template") || lower.contains("save template") -> {
                // "Save as template headache", "Save template diabetes followup"
                val templateName = lower
                    .replace("save as template", "")
                    .replace("save template", "")
                    .trim()
                if (templateName.isNotEmpty()) {
                    saveAsTemplate(templateName)
                } else {
                    Toast.makeText(this, "Say 'save as template [name]'", Toast.LENGTH_SHORT).show()
                    speakFeedback("Say save as template followed by a name")
                }
            }
            lower.contains("delete template") || lower.contains("remove template") -> {
                // "Delete template headache"
                val templateName = lower
                    .replace("delete template", "")
                    .replace("remove template", "")
                    .trim()
                if (templateName.isNotEmpty()) {
                    deleteUserTemplate(templateName)
                } else {
                    Toast.makeText(this, "Say 'delete template [name]'", Toast.LENGTH_SHORT).show()
                }
            }
            // Offline note drafts voice commands
            lower.contains("sync notes") || lower.contains("sync drafts") || lower.contains("upload drafts") -> {
                val draftCount = getPendingDraftCount()
                if (draftCount > 0) {
                    if (isNetworkAvailable()) {
                        syncPendingDrafts()
                    } else {
                        Toast.makeText(this, "No network - cannot sync", Toast.LENGTH_SHORT).show()
                        speakFeedback("No network connection. Cannot sync drafts.")
                    }
                } else {
                    Toast.makeText(this, "No pending drafts", Toast.LENGTH_SHORT).show()
                }
            }
            lower.contains("show drafts") || lower.contains("view drafts") || lower.contains("pending notes") || lower.contains("pending drafts") -> {
                showPendingDraftsOverlay()
            }
            lower.contains("delete draft") -> {
                // Extract draft number from command
                val match = Regex("\\d+").find(lower)
                if (match != null) {
                    val draftIndex = match.value.toIntOrNull()?.minus(1) ?: -1
                    val drafts = getPendingDrafts()
                    if (draftIndex in drafts.indices) {
                        val draftId = drafts[draftIndex].optString("draft_id")
                        deleteDraft(draftId)
                        Toast.makeText(this, "Draft ${draftIndex + 1} deleted", Toast.LENGTH_SHORT).show()
                        speakFeedback("Draft deleted")
                    } else {
                        Toast.makeText(this, "Invalid draft number", Toast.LENGTH_SHORT).show()
                    }
                } else {
                    showPendingDraftsOverlay()
                    transcriptText.text = "Say 'delete draft [number]'"
                }
            }
            lower.contains("view draft") && Regex("\\d+").containsMatchIn(lower) -> {
                // View specific draft by number
                val match = Regex("\\d+").find(lower)
                if (match != null) {
                    val draftIndex = match.value.toIntOrNull()?.minus(1) ?: -1
                    val drafts = getPendingDrafts()
                    if (draftIndex in drafts.indices) {
                        showDraftDetails(drafts[draftIndex])
                    } else {
                        Toast.makeText(this, "Invalid draft number", Toast.LENGTH_SHORT).show()
                    }
                }
            }
            lower.contains("increase font") || lower.contains("bigger font") || lower.contains("larger font") || lower.contains("font bigger") || lower.contains("font larger") -> {
                // Voice command to increase font size
                increaseFontSize()
            }
            lower.contains("decrease font") || lower.contains("smaller font") || lower.contains("font smaller") -> {
                // Voice command to decrease font size
                decreaseFontSize()
            }
            lower.contains("font small") && !lower.contains("smaller") -> {
                setFontSize(FONT_SIZE_SMALL)
            }
            lower.contains("font medium") -> {
                setFontSize(FONT_SIZE_MEDIUM)
            }
            lower.contains("font large") && !lower.contains("larger") -> {
                setFontSize(FONT_SIZE_LARGE)
            }
            lower.contains("font extra large") || lower.contains("extra large font") -> {
                setFontSize(FONT_SIZE_EXTRA_LARGE)
            }
            lower.contains("auto scroll on") || lower.contains("enable auto scroll") || lower.contains("scroll on") -> {
                enableAutoScroll()
            }
            lower.contains("auto scroll off") || lower.contains("disable auto scroll") || lower.contains("scroll off") -> {
                disableAutoScroll()
            }
            lower.contains("toggle scroll") || lower.contains("toggle auto scroll") -> {
                toggleAutoScroll()
            }
            // Speech feedback toggle
            lower.contains("speech feedback") || lower.contains("voice feedback") || lower.contains("audio feedback") ||
            lower.contains("toggle feedback") || lower.contains("mute feedback") || lower.contains("unmute feedback") -> {
                toggleSpeechFeedback()
            }
            // Note type selection voice commands
            lower.contains("soap note") || lower.contains("note type soap") -> {
                setNoteType("SOAP")
            }
            lower.contains("progress note") || lower.contains("note type progress") -> {
                setNoteType("PROGRESS")
            }
            lower.contains("h&p note") || lower.contains("hp note") || lower.contains("history and physical") || lower.contains("note type hp") -> {
                setNoteType("HP")
            }
            lower.contains("consult note") || lower.contains("consultation note") || lower.contains("note type consult") -> {
                setNoteType("CONSULT")
            }
            lower.contains("auto note") || lower.contains("auto detect") || lower.contains("automatic note") || lower.contains("note type auto") -> {
                setNoteType("AUTO")
            }
            // Set clinician name: "my name is Dr. Smith" or "I am Dr. Jones" or "clinician name Dr. Brown"
            lower.contains("my name is") || lower.contains("i am dr") || lower.contains("clinician name") -> {
                // Extract name from transcript
                val name = when {
                    lower.contains("my name is") -> transcript.substringAfter("my name is", "").trim()
                    lower.contains("i am dr") -> "Dr." + transcript.substringAfter("i am dr", "").substringAfter("I am Dr", "").trim()
                    lower.contains("clinician name") -> transcript.substringAfter("clinician name", "").trim()
                    else -> ""
                }.replace(Regex("^\\s*\\.\\s*"), "").trim()
                if (name.isNotEmpty()) {
                    setClinicianName(name)
                } else {
                    transcriptText.text = "Say: My name is Dr. [Name]"
                }
            }
            // ═══════════════════════════════════════════════════════════════════════════
            // MEDICAL CALCULATOR - Voice-activated clinical calculations
            // ═══════════════════════════════════════════════════════════════════════════

            // Calculator list: "calculators", "show calculators", "medical calculators"
            lower.contains("calculator") || lower.contains("calculations") -> {
                if (lower.contains("bmi") || lower.contains("gfr") || lower.contains("calcium") ||
                    lower.contains("anion") || lower.contains("a1c") || lower.contains("map") ||
                    lower.contains("creatinine") || lower.contains("chads")) {
                    processCalculatorCommand(lower)
                } else {
                    showCalculatorList()
                }
            }
            // Calculate BMI: "calculate BMI", "what's the BMI", "BMI"
            lower.contains("calculate bmi") || lower.contains("what's the bmi") ||
            lower.contains("whats the bmi") || lower.contains("body mass index") ||
            (lower.contains("bmi") && !lower.contains("calculator")) -> {
                calculateAndShowBMI()
            }
            // Calculate eGFR: "calculate GFR", "what's the GFR", "kidney function"
            lower.contains("calculate gfr") || lower.contains("egfr") ||
            lower.contains("what's the gfr") || lower.contains("whats the gfr") ||
            lower.contains("kidney function") || lower.contains("glomerular") -> {
                calculateAndShowEGFR()
            }
            // Corrected Calcium: "corrected calcium", "calcium corrected"
            lower.contains("corrected calcium") || lower.contains("correct calcium") ||
            lower.contains("calcium correct") -> {
                calculateAndShowCorrectedCalcium()
            }
            // Anion Gap: "anion gap", "calculate anion"
            lower.contains("anion gap") || lower.contains("calculate anion") -> {
                calculateAndShowAnionGap()
            }
            // A1c conversions: "A1c to glucose", "convert A1c"
            lower.contains("a1c to glucose") || lower.contains("convert a1c") ||
            lower.contains("a1c conversion") -> {
                calculateAndShowA1cToGlucose()
            }
            lower.contains("glucose to a1c") -> {
                calculateAndShowGlucoseToA1c()
            }
            // MAP: "calculate MAP", "mean arterial pressure"
            lower.contains("calculate map") || lower.contains("mean arterial") ||
            (lower == "map" || lower.contains("what's the map") || lower.contains("whats the map")) -> {
                calculateAndShowMAP()
            }
            // Creatinine Clearance: "creatinine clearance", "CrCl", "cockcroft"
            lower.contains("creatinine clearance") || lower.contains("crcl") ||
            lower.contains("cockcroft") || lower.contains("calculate clearance") -> {
                calculateAndShowCrCl()
            }
            // CHADS-VASc: "CHADS VASc", "stroke risk"
            lower.contains("chads") || lower.contains("stroke risk") -> {
                calculateAndShowCHADSVASc()
            }

            // ═══════════════════════════════════════════════════════════════════════════
            // CUSTOM VOICE COMMANDS - User-defined macros and aliases
            // ═══════════════════════════════════════════════════════════════════════════

            // Create command: "create command [name] that does [actions]"
            lower.contains("create command") || lower.contains("make command") ||
            lower.contains("new command") || lower.contains("add command") ||
            lower.contains("create macro") || lower.contains("make macro") ||
            lower.contains("new macro") || lower.contains("add macro") ||
            lower.startsWith("when i say") || lower.startsWith("when I say") ||
            lower.startsWith("teach ") -> {
                if (!parseAndCreateCommand(transcript)) {
                    speakFeedback("Could not create command. Try: create command morning rounds that does show vitals then show meds")
                }
            }
            // Show custom commands: "my commands", "list commands", "show commands"
            lower.contains("my command") || lower.contains("list command") ||
            lower.contains("show command") || lower.contains("custom command") ||
            lower.contains("my macro") || lower.contains("list macro") -> {
                showCustomCommands()
            }
            // Delete command: "delete command [name]", "remove command [name]"
            lower.contains("delete command") || lower.contains("remove command") ||
            lower.contains("delete macro") || lower.contains("remove macro") -> {
                val commandName = lower
                    .replace("delete command", "")
                    .replace("remove command", "")
                    .replace("delete macro", "")
                    .replace("remove macro", "")
                    .trim()
                if (commandName.isNotEmpty()) {
                    deleteCustomCommand(commandName)
                } else {
                    speakFeedback("Say delete command followed by the command name")
                }
            }

            lower.contains("clear") || lower.contains("reset") -> {
                // Clear current patient data (not cache)
                currentPatientData = null
                hideDataOverlay()
                transcriptText.text = "Patient data cleared"
            }
            else -> {
                // Check for custom commands before falling through
                val customCommand = findCustomCommand(lower)
                if (customCommand != null) {
                    executeCustomCommand(customCommand)
                } else {
                    // Display transcribed text
                    transcriptText.text = "\"$transcript\""
                    Log.d(TAG, "Voice command: $transcript")
                }
            }
        }
    }

    private fun fetchPatientSection(section: String) {
        // Use cached patient data if available
        currentPatientData?.let { patient ->
            val title = section.uppercase().replace("_", " ")
            val content = when (section) {
                "vitals" -> formatVitals(patient)
                "allergies" -> formatAllergies(patient)
                "medications" -> formatMedications(patient)
                "labs" -> formatLabs(patient)
                "procedures" -> formatProcedures(patient)
                "immunizations" -> formatImmunizations(patient)
                "conditions" -> formatConditions(patient)
                "care_plans" -> formatCarePlans(patient)
                "clinical_notes" -> formatClinicalNotes(patient)
                else -> patient.optString("display_text", "No data")
            }
            showDataOverlay(title, content)
            return
        }

        // If no cached data, fetch fresh
        statusText.text = "Loading ${section}..."
        transcriptText.text = "Fetching from EHR"

        Thread {
            try {
                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/patient/$TEST_PATIENT_ID")
                    .get()
                    .build()

                httpClient.newCall(request).enqueue(object : Callback {
                    override fun onFailure(call: Call, e: IOException) {
                        Log.e(TAG, "Fetch error: ${e.message}")
                        runOnUiThread {
                            statusText.text = "Failed to load"
                            transcriptText.text = "Error: ${e.message}"
                        }
                    }

                    override fun onResponse(call: Call, response: Response) {
                        val body = response.body?.string()
                        Log.d(TAG, "Patient data for $section: $body")

                        runOnUiThread {
                            try {
                                val patient = JSONObject(body ?: "{}")
                                currentPatientData = patient
                                val title = section.uppercase().replace("_", " ")
                                val content = when (section) {
                                    "vitals" -> formatVitals(patient)
                                    "allergies" -> formatAllergies(patient)
                                    "medications" -> formatMedications(patient)
                                    "labs" -> formatLabs(patient)
                                    "procedures" -> formatProcedures(patient)
                                    "immunizations" -> formatImmunizations(patient)
                                    "conditions" -> formatConditions(patient)
                                    "care_plans" -> formatCarePlans(patient)
                                    "clinical_notes" -> formatClinicalNotes(patient)
                                    else -> patient.optString("display_text", "No data")
                                }
                                showDataOverlay(title, content)
                                notifyHudPatientUpdate()  // Update Vuzix HUD
                            } catch (e: Exception) {
                                showDataOverlay("Error", "Parse error: ${e.message}")
                            }
                        }
                    }
                })
            } catch (e: Exception) {
                Log.e(TAG, "Failed to fetch $section: ${e.message}")
            }
        }.start()
    }

    /**
     * Care Gap Detection (Feature #97 - Jarvis Wave 2)
     * Fetches care gaps (missing screenings, labs, vaccines) for the patient
     * Based on USPSTF, ADA, AHA, CDC/ACIP, KDIGO guidelines
     */
    private fun fetchCareGaps(patientId: String, category: String?, priority: String?) {
        statusText.text = "Checking care gaps..."
        transcriptText.text = "Analyzing preventive care needs"

        Thread {
            try {
                // Build URL with optional filters
                var url = "$EHR_PROXY_URL/api/v1/patient/$patientId/care-gaps"
                val params = mutableListOf<String>()
                if (category != null) params.add("category=$category")
                if (priority != null) params.add("priority=$priority")
                if (params.isNotEmpty()) url += "?" + params.joinToString("&")

                Log.d(TAG, "Fetching care gaps from: $url")

                val request = Request.Builder()
                    .url(url)
                    .get()
                    .build()

                httpClient.newCall(request).enqueue(object : Callback {
                    override fun onFailure(call: Call, e: IOException) {
                        Log.e(TAG, "Care gaps fetch error: ${e.message}")
                        runOnUiThread {
                            statusText.text = "Failed to load care gaps"
                            transcriptText.text = "Error: ${e.message}"
                            speakFeedback("Failed to load care gaps")
                        }
                    }

                    override fun onResponse(call: Call, response: Response) {
                        val body = response.body?.string()
                        Log.d(TAG, "Care gaps response: $body")

                        runOnUiThread {
                            try {
                                val data = JSONObject(body ?: "{}")
                                displayCareGaps(data)
                            } catch (e: Exception) {
                                Log.e(TAG, "Parse error: ${e.message}")
                                showDataOverlay("Error", "Parse error: ${e.message}")
                            }
                        }
                    }
                })
            } catch (e: Exception) {
                Log.e(TAG, "Failed to fetch care gaps: ${e.message}")
            }
        }.start()
    }

    /**
     * Display care gaps in overlay with priority indicators
     */
    private fun displayCareGaps(data: JSONObject) {
        val patientName = data.optString("patient_name", "Patient")
        val totalGaps = data.optInt("total_gaps", 0)
        val highPriority = data.optInt("high_priority", 0)
        val gaps = data.optJSONArray("gaps") ?: return

        val sb = StringBuilder()

        // Header with summary
        sb.append("📋 CARE GAPS FOR $patientName\n")
        sb.append("═".repeat(35) + "\n")

        if (totalGaps == 0) {
            sb.append("✅ All preventive care up to date!\n")
            sb.append("No overdue screenings or vaccinations.\n")
        } else {
            sb.append("Total: $totalGaps gaps | High Priority: $highPriority\n")
            sb.append("─".repeat(35) + "\n\n")

            // Group by priority
            val highItems = mutableListOf<JSONObject>()
            val mediumItems = mutableListOf<JSONObject>()
            val lowItems = mutableListOf<JSONObject>()

            for (i in 0 until gaps.length()) {
                val gap = gaps.getJSONObject(i)
                when (gap.optString("priority", "low")) {
                    "high" -> highItems.add(gap)
                    "medium" -> mediumItems.add(gap)
                    else -> lowItems.add(gap)
                }
            }

            // High priority (overdue)
            if (highItems.isNotEmpty()) {
                sb.append("🔴 OVERDUE\n")
                for (gap in highItems.take(5)) {
                    val name = gap.optString("name", "Unknown")
                    val guideline = gap.optString("guideline", "")
                    val category = gap.optString("category", "").uppercase()
                    sb.append("   • $name\n")
                    sb.append("     $category | $guideline\n")
                }
                sb.append("\n")
            }

            // Medium priority (due soon)
            if (mediumItems.isNotEmpty()) {
                sb.append("🟡 DUE SOON\n")
                for (gap in mediumItems.take(4)) {
                    val name = gap.optString("name", "Unknown")
                    sb.append("   • $name\n")
                }
                sb.append("\n")
            }

            // Low priority (recommended)
            if (lowItems.isNotEmpty()) {
                sb.append("🟢 RECOMMENDED\n")
                for (gap in lowItems.take(3)) {
                    val name = gap.optString("name", "Unknown")
                    sb.append("   • $name\n")
                }
            }
        }

        // Show overlay
        showDataOverlay("CARE GAPS", sb.toString())

        // Speak summary
        val spoken = data.optString("spoken_summary", "")
        if (spoken.isNotEmpty() && totalGaps > 0) {
            speakFeedback(spoken)
        } else if (totalGaps == 0) {
            speakFeedback("No care gaps found. Preventive care is up to date.")
        }

        // Update status
        statusText.text = if (totalGaps > 0) {
            "$totalGaps care gaps ($highPriority high priority)"
        } else {
            "✓ Preventive care up to date"
        }
    }

    private fun formatVitals(patient: JSONObject): String {
        val vitals = patient.optJSONArray("vitals") ?: return "No vitals recorded"
        if (vitals.length() == 0) return "No vitals available"

        val sb = StringBuilder()

        // Show critical vitals warning first if any
        val criticalVitals = patient.optJSONArray("critical_vitals")
        if (criticalVitals != null && criticalVitals.length() > 0) {
            sb.append("🚨 CRITICAL VITALS\n${"─".repeat(30)}\n")
            for (i in 0 until criticalVitals.length()) {
                val v = criticalVitals.getJSONObject(i)
                val interp = v.optString("interpretation", "")
                val flag = if (interp == "HH" || interp == "LL") "‼️" else "⚠️"
                sb.append("$flag ${v.getString("name")}: ${v.getString("value")} ${v.optString("unit", "")}")
                if (interp.isNotEmpty()) sb.append(" [$interp]")
                sb.append("\n")
            }
            sb.append("${"─".repeat(30)}\n\n")
        }

        sb.append("VITALS\n${"─".repeat(30)}\n")
        for (i in 0 until minOf(vitals.length(), 8)) {
            val v = vitals.getJSONObject(i)
            val interp = v.optString("interpretation", "")
            val isCritical = v.optBoolean("is_critical", false)
            val isAbnormal = v.optBoolean("is_abnormal", false)
            val trend = v.optString("trend", "")
            val delta = v.optString("delta", "")

            // Add interpretation flag
            val flag = when {
                interp == "HH" || interp == "LL" -> "‼️"
                interp == "H" -> "↑"
                interp == "L" -> "↓"
                isCritical -> "‼️"
                isAbnormal -> "⚠"
                else -> "•"
            }

            // Trend indicator
            val trendIcon = when (trend) {
                "rising" -> " ↗️"
                "falling" -> " ↘️"
                "stable" -> " →"
                "new" -> " 🆕"
                else -> ""
            }

            // Delta display
            val deltaStr = if (delta.isNotEmpty()) " ($delta)" else ""

            sb.append("$flag ${v.getString("name")}: ${v.getString("value")}${v.optString("unit", "")}$trendIcon$deltaStr")
            if (interp.isNotEmpty() && interp != "N") sb.append(" [$interp]")
            sb.append("\n")
        }
        return sb.toString()
    }

    private fun formatAllergies(patient: JSONObject): String {
        val allergies = patient.optJSONArray("allergies") ?: return "No allergies recorded"
        val sb = StringBuilder("⚠ ALLERGIES\n${"─".repeat(30)}\n")
        for (i in 0 until minOf(allergies.length(), 8)) {
            sb.append("• ${allergies.getString(i)}\n")
        }
        return sb.toString()
    }

    private fun formatMedications(patient: JSONObject): String {
        val meds = patient.optJSONArray("medications") ?: return "No medications recorded"
        val interactions = patient.optJSONArray("medication_interactions")

        val sb = StringBuilder()

        // Show drug interactions warning first if any
        if (interactions != null && interactions.length() > 0) {
            sb.append("⚠️ DRUG INTERACTIONS\n${"─".repeat(30)}\n")
            for (i in 0 until minOf(interactions.length(), 5)) {
                val inter = interactions.getJSONObject(i)
                val drug1 = inter.optString("drug1", "").split(" ").firstOrNull() ?: "Drug1"
                val drug2 = inter.optString("drug2", "").split(" ").firstOrNull() ?: "Drug2"
                val severity = inter.optString("severity", "moderate")
                val effect = inter.optString("effect", "Potential interaction")
                val shortEffect = effect.split(" - ").firstOrNull()?.take(40) ?: effect.take(40)

                val flag = when (severity) {
                    "high" -> "🔴"
                    "moderate" -> "🟡"
                    else -> "🟢"
                }
                sb.append("$flag $drug1 + $drug2\n")
                sb.append("   $shortEffect\n")
            }
            sb.append("${"─".repeat(30)}\n\n")
        }

        sb.append("💊 MEDICATIONS\n${"─".repeat(30)}\n")
        for (i in 0 until minOf(meds.length(), 8)) {
            sb.append("• ${meds.getString(i)}\n")
        }
        return sb.toString()
    }

    private fun formatLabs(patient: JSONObject): String {
        val labs = patient.optJSONArray("labs") ?: return "No lab results"
        if (labs.length() == 0) return "No lab results available"

        val sb = StringBuilder()

        // Show critical labs warning first if any
        val criticalLabs = patient.optJSONArray("critical_labs")
        if (criticalLabs != null && criticalLabs.length() > 0) {
            sb.append("🚨 CRITICAL LABS\n${"─".repeat(30)}\n")
            for (i in 0 until criticalLabs.length()) {
                val l = criticalLabs.getJSONObject(i)
                val interp = l.optString("interpretation", "")
                val flag = if (interp == "HH" || interp == "LL") "‼️" else "⚠️"
                val refRange = l.optString("reference_range", "")
                sb.append("$flag ${l.getString("name")}: ${l.getString("value")} ${l.optString("unit", "")}")
                if (interp.isNotEmpty()) sb.append(" [$interp]")
                if (refRange.isNotEmpty()) sb.append(" (ref: $refRange)")
                sb.append("\n")
            }
            sb.append("${"─".repeat(30)}\n\n")
        }

        sb.append("🔬 LAB RESULTS\n${"─".repeat(30)}\n")
        for (i in 0 until minOf(labs.length(), 10)) {
            val l = labs.getJSONObject(i)
            val interp = l.optString("interpretation", "")
            val isCritical = l.optBoolean("is_critical", false)
            val isAbnormal = l.optBoolean("is_abnormal", false)
            val trend = l.optString("trend", "")
            val delta = l.optString("delta", "")

            // Add interpretation flag
            val flag = when {
                interp == "HH" || interp == "LL" -> "‼️"
                interp == "H" -> "↑"
                interp == "L" -> "↓"
                isCritical -> "‼️"
                isAbnormal -> "⚠"
                else -> "•"
            }

            // Trend indicator
            val trendIcon = when (trend) {
                "rising" -> " ↗️"
                "falling" -> " ↘️"
                "stable" -> " →"
                "new" -> " 🆕"
                else -> ""
            }

            // Delta display
            val deltaStr = if (delta.isNotEmpty()) " ($delta)" else ""

            sb.append("$flag ${l.getString("name")}: ${l.getString("value")}${l.optString("unit", "")}$trendIcon$deltaStr")
            if (interp.isNotEmpty() && interp != "N") sb.append(" [$interp]")
            sb.append("\n")
        }
        return sb.toString()
    }

    private fun formatProcedures(patient: JSONObject): String {
        val procs = patient.optJSONArray("procedures") ?: return "No procedures recorded"
        if (procs.length() == 0) return "No procedures recorded"
        val sb = StringBuilder("🏥 PROCEDURES\n${"─".repeat(30)}\n")
        for (i in 0 until minOf(procs.length(), 8)) {
            val p = procs.getJSONObject(i)
            sb.append("• ${p.getString("name")}")
            val date = p.optString("date", "")
            if (date.isNotEmpty()) sb.append(" ($date)")
            sb.append("\n")
        }
        return sb.toString()
    }

    private fun formatImmunizations(patient: JSONObject): String {
        val imms = patient.optJSONArray("immunizations") ?: return "No immunizations recorded"
        if (imms.length() == 0) return "No immunizations recorded"
        val sb = StringBuilder("💉 IMMUNIZATIONS\n${"─".repeat(30)}\n")
        for (i in 0 until minOf(imms.length(), 10)) {
            val imm = imms.getJSONObject(i)
            sb.append("• ${imm.getString("name")}")
            val date = imm.optString("date", "")
            if (date.isNotEmpty()) sb.append(" ($date)")
            sb.append("\n")
        }
        return sb.toString()
    }

    private fun formatConditions(patient: JSONObject): String {
        val conds = patient.optJSONArray("conditions") ?: return "No conditions recorded"
        if (conds.length() == 0) return "No conditions/problems recorded"
        val sb = StringBuilder("📋 CONDITIONS/PROBLEMS\n${"─".repeat(30)}\n")
        for (i in 0 until minOf(conds.length(), 10)) {
            val cond = conds.getJSONObject(i)
            sb.append("• ${cond.getString("name")}")
            val status = cond.optString("status", "")
            if (status.isNotEmpty()) sb.append(" [$status]")
            val onset = cond.optString("onset", "")
            if (onset.isNotEmpty()) sb.append(" (since $onset)")
            sb.append("\n")
        }
        return sb.toString()
    }

    private fun formatCarePlans(patient: JSONObject): String {
        val plans = patient.optJSONArray("care_plans") ?: return "No care plans recorded"
        if (plans.length() == 0) return "No care plans recorded"
        val sb = StringBuilder("📑 CARE PLANS\n${"─".repeat(30)}\n")
        for (i in 0 until minOf(plans.length(), 10)) {
            val plan = plans.getJSONObject(i)
            sb.append("• ${plan.getString("title")}")
            val status = plan.optString("status", "")
            if (status.isNotEmpty()) sb.append(" [$status]")
            val intent = plan.optString("intent", "")
            if (intent.isNotEmpty()) sb.append(" ($intent)")
            sb.append("\n")
            // Show period if available
            val periodStart = plan.optString("period_start", "")
            val periodEnd = plan.optString("period_end", "")
            if (periodStart.isNotEmpty() || periodEnd.isNotEmpty()) {
                sb.append("  Period: ${periodStart.ifEmpty { "?" }} → ${periodEnd.ifEmpty { "ongoing" }}\n")
            }
            // Show description if available
            val description = plan.optString("description", "")
            if (description.isNotEmpty()) {
                sb.append("  ${description.take(100)}${if (description.length > 100) "..." else ""}\n")
            }
        }
        return sb.toString()
    }

    private fun formatClinicalNotes(patient: JSONObject): String {
        val notes = patient.optJSONArray("clinical_notes") ?: return "No clinical notes found"
        if (notes.length() == 0) return "No clinical notes found"
        val sb = StringBuilder("📄 CLINICAL NOTES\n${"─".repeat(30)}\n")
        for (i in 0 until minOf(notes.length(), 10)) {
            val note = notes.getJSONObject(i)
            sb.append("• ${note.getString("title")}")
            val docType = note.optString("doc_type", "")
            if (docType.isNotEmpty() && docType != note.getString("title")) {
                sb.append(" ($docType)")
            }
            sb.append("\n")
            // Show date and author
            val date = note.optString("date", "")
            val author = note.optString("author", "")
            if (date.isNotEmpty() || author.isNotEmpty()) {
                sb.append("  ")
                if (date.isNotEmpty()) sb.append("Date: $date")
                if (date.isNotEmpty() && author.isNotEmpty()) sb.append(" | ")
                if (author.isNotEmpty()) sb.append("By: $author")
                sb.append("\n")
            }
            // Show status
            val status = note.optString("status", "")
            if (status.isNotEmpty()) {
                sb.append("  Status: $status\n")
            }
            // Show content preview if available
            val preview = note.optString("content_preview", "")
            if (preview.isNotEmpty()) {
                sb.append("  ${preview.take(100)}${if (preview.length > 100) "..." else ""}\n")
            }
            sb.append("\n")
        }
        return sb.toString()
    }

    private fun searchPatients(name: String) {
        statusText.text = "Searching..."
        patientDataText.text = ""

        Thread {
            try {
                val encodedName = java.net.URLEncoder.encode(name, "UTF-8")
                val request = Request.Builder()
                    .url("$EHR_PROXY_URL/api/v1/patient/search?name=$encodedName")
                    .get()
                    .build()

                httpClient.newCall(request).enqueue(object : Callback {
                    override fun onFailure(call: Call, e: IOException) {
                        Log.e(TAG, "Search error: ${e.message}")
                        runOnUiThread {
                            statusText.text = "Search failed"
                            patientDataText.text = "Error: ${e.message}"
                        }
                    }

                    override fun onResponse(call: Call, response: Response) {
                        val body = response.body?.string()
                        Log.d(TAG, "Search results: $body")

                        runOnUiThread {
                            statusText.text = "Search Results"
                            try {
                                val results = org.json.JSONArray(body ?: "[]")
                                val sb = StringBuilder()
                                for (i in 0 until minOf(results.length(), 5)) {
                                    val p = results.getJSONObject(i)
                                    sb.append("${p.getString("name")} (${p.getString("patient_id")})\n")
                                }
                                patientDataText.text = if (sb.isEmpty()) "No results" else sb.toString()
                            } catch (e: Exception) {
                                patientDataText.text = body ?: "No results"
                            }
                        }
                    }
                })
            } catch (e: Exception) {
                Log.e(TAG, "Search failed: ${e.message}")
            }
        }.start()
    }

    override fun onResume() {
        super.onResume()
        // Update activity on resume and restart timeout checker
        updateLastActivity()
        if (sessionCheckHandler == null) {
            startSessionTimeoutChecker()
        }
        // Start proximity monitoring for auto-lock (skip in debug mode)
        if (!DEBUG_SKIP_AUTH) {
            startProximityMonitoring()
        }

        // Start gesture monitoring for Vuzix (Feature #75)
        startGestureMonitoring()

        // Check if TOTP is required (skip in debug mode)
        if (!DEBUG_SKIP_AUTH && isDevicePaired && sessionToken == null && !isSessionLocked) {
            showTotpLockScreen()
        }

        // Debug mode indicator
        if (DEBUG_SKIP_AUTH) {
            Log.w(TAG, "⚠️ DEBUG_SKIP_AUTH is enabled - authentication bypassed!")
        }
    }

    override fun onPause() {
        super.onPause()
        // Stop timeout checker when app is in background
        stopSessionTimeoutChecker()
        // Stop proximity monitoring
        stopProximityMonitoring()
        // Stop gesture monitoring (Feature #75)
        stopGestureMonitoring()
    }

    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)

        // Handle QR pairing result
        if (requestCode == QR_SCAN_REQUEST_CODE && resultCode == RESULT_OK) {
            val token = data?.getStringExtra(QrPairingActivity.EXTRA_PAIRING_TOKEN)
            val apiUrl = data?.getStringExtra(QrPairingActivity.EXTRA_API_URL)
            if (token != null) {
                completePairing(token, apiUrl)
            }
        }
        // Handle barcode scanner result (existing)
        else if (requestCode == 1002 && resultCode == RESULT_OK) {
            val mrn = data?.getStringExtra(BarcodeScannerActivity.EXTRA_MRN)
            if (mrn != null) {
                fetchPatientByMrn(mrn)
            }
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        if (::speechRecognizer.isInitialized) {
            speechRecognizer.destroy()
        }
        // Clean up audio streaming service
        audioStreamingService?.destroy()
        // Clean up Text-to-Speech
        textToSpeech?.stop()
        textToSpeech?.shutdown()
        // Clean up network callback
        unregisterNetworkCallback()
        // Clean up session timeout checker
        stopSessionTimeoutChecker()
        // Feature #77: Clean up continuous auth monitor
        stopContinuousAuthMonitor()
    }

    // ============ Touchpad Navigation (Feature #75) ============

    /**
     * Handle Vuzix touchpad DPAD events for hands-free navigation
     * Left/Right: Navigate worklist or sections
     * Up/Down: Scroll content or expand/collapse HUD
     * Center: Select/confirm
     */
    override fun onKeyDown(keyCode: Int, event: android.view.KeyEvent?): Boolean {
        if (!isVuzixDevice()) return super.onKeyDown(keyCode, event)

        updateLastActivity()

        when (keyCode) {
            android.view.KeyEvent.KEYCODE_DPAD_LEFT -> {
                handleTouchpadLeft()
                return true
            }
            android.view.KeyEvent.KEYCODE_DPAD_RIGHT -> {
                handleTouchpadRight()
                return true
            }
            android.view.KeyEvent.KEYCODE_DPAD_UP -> {
                handleTouchpadUp()
                return true
            }
            android.view.KeyEvent.KEYCODE_DPAD_DOWN -> {
                handleTouchpadDown()
                return true
            }
            android.view.KeyEvent.KEYCODE_DPAD_CENTER -> {
                handleTouchpadSelect()
                return true
            }
        }
        return super.onKeyDown(keyCode, event)
    }

    private fun handleTouchpadLeft() {
        // Navigate to previous patient in worklist
        if (worklistPatients.isNotEmpty() && worklistPosition > 0) {
            worklistPosition--
            speakFeedback("Patient ${worklistPosition + 1} of ${worklistPatients.size}")
            previewWorklistPatientByIndex(worklistPosition)
        } else {
            speakFeedback("Previous")
        }
    }

    private fun handleTouchpadRight() {
        // Navigate to next patient in worklist
        if (worklistPatients.isNotEmpty() && worklistPosition < worklistPatients.size - 1) {
            worklistPosition++
            speakFeedback("Patient ${worklistPosition + 1} of ${worklistPatients.size}")
            previewWorklistPatientByIndex(worklistPosition)
        } else {
            speakFeedback("Next")
        }
    }

    private fun handleTouchpadUp() {
        // Expand HUD or scroll up
        if (isVuzixDevice()) {
            sendHudCommand(VuzixHudService.ACTION_EXPAND)
        }
    }

    private fun handleTouchpadDown() {
        // Minimize HUD or scroll down
        if (isVuzixDevice()) {
            sendHudCommand(VuzixHudService.ACTION_MINIMIZE)
        }
    }

    private fun handleTouchpadSelect() {
        // Select current item (same as nod gesture)
        handleGestureConfirm()
    }

    private fun previewWorklistPatientByIndex(index: Int) {
        if (index in worklistPatients.indices) {
            val patient = worklistPatients[index]
            val preview = StringBuilder().apply {
                append(patient.name)
                patient.room?.let { if (it.isNotEmpty()) append(", Room ").append(it) }
                patient.chiefComplaint?.let { if (it.isNotEmpty()) append(". ").append(it) }
            }.toString()
            speakFeedback(preview)
        }
    }

    override fun dispatchTouchEvent(ev: android.view.MotionEvent?): Boolean {
        // Update activity on any touch event
        updateLastActivity()
        return super.dispatchTouchEvent(ev)
    }
}
